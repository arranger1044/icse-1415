   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*             Macintosh Version 3.3  04/02/96         */   /*                                                     */   /*               DIALOG MANAGER MODULE                 */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _DLOGMNGR_SOURCE_#include "setup.h"#include <string.h>#include <stdlib.h>#include <ctype.h>#include <stdio.h>#include <OSUtils.h>#include <Dialogs.h>#include <Events.h>#include <Lists.h>#include <Menus.h>#include <Fonts.h>#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_SC7 || MAC_SC8#define CTOPSTR C2PStr#else#define CTOPSTR c2pstr#endif#include <ToolUtils.h>#if MAC_SC7 || MAC_MCW || MAC_SC8#define SearchPtr ListSearchUPP#else#define SearchPtr SearchProcPtr#endif#include "commline.h"#include "dffctdef.h"#include "tmpltdef.h"#include "tmpltfun.h"#include "tmpltbsc.h"#include "watch.h"#include "ruledlt.h"#include "rulebsc.h"#include "router.h"#include "facthsh.h"#include "rulecom.h"#include "globldef.h"#include "drive.h"#include "ruledef.h"#include "engine.h"#include "crstrtgy.h"#include "incrrset.h"#include "exprnpsr.h"#include "dffctbsc.h"#include "globlcom.h"   #include "alpha.h"#include "dlogmngr.h"#include "macinit.h"#include "interface.h"#include "stnrdmac.h"#include "window.h"#include "kbstatw.h"#include "statusw.h"#include "menuhndl.h"struct stringStorage  {   char *sPtr;   struct stringStorage *next;  };   /***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static pascal short           GEString(Ptr,Ptr,short int,short int);   static void                  *AlphaSortNext(void *);   static void                   AlphaSortSwitch(void *,void *);   static char                  *AlphaSortWord(void *);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static unsigned long    LastEntryTime = 0;   #if (MAC_MCW && __powerc) || MAC_MCW   static RoutineDescriptor GEStringRD       = BUILD_ROUTINE_DESCRIPTOR(uppListSearchProcInfo,GEString);#define GEStringRef &GEStringRD#else#define GEStringRef GEString#endif/****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   int                     DoubleClickActive = false;   int                     ListKeyCurrentPos = 0;   int                     ListKeyRestartPos = 0;   char                    ListKeySelection[LIST_KEY_MAX];   void                  (*UpdateConstructManagerButtonsFunction)(DialogPtr,int);   ListHandle              Choices;   int                     SelectItem;   DialogPtr               ManagerDialog;   char                    DialogBuffer[DIALOG_BUFFER_SIZE];   GrafPtr                 DialogManagerSavePort;   int                     DV = 0;   int                     DH = 0;#if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor              SingleSelectFilterRD       = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterProcInfo,SingleSelectFilter);         RoutineDescriptor              DefaultConstructManagerClikloopRD       = BUILD_ROUTINE_DESCRIPTOR(uppListClickLoopProcInfo,DefaultConstructManagerClikloop);#endif/******************************************************************//* CreateDialogManager: Saves the current port, creates a manager *//*   dialog, then sets the current port to that dialog.           *//******************************************************************/void CreateDialogManager(dialogID,disableWatch)  int dialogID;  int disableWatch;  {   InitCursor();   ListKeyCurrentPos = 0;   ListKeyRestartPos = 0;   GetPort(&DialogManagerSavePort);   ManagerDialog = GetNewDialog(dialogID,NULL,(WindowPtr) -1L);   SetPort(ManagerDialog);   if (disableWatch) ActivateRouter(WTRACE);  }/************************************************//* PrepManager:                                 *//************************************************/int PrepManager(selectID,returnItemFunction,returnPprintFunction,           alphabetize,copyStrings,namePrefix)  int selectID;  VOID *(*returnItemFunction)(VOID *);  char *(*returnPprintFunction)(VOID *);  int alphabetize, copyStrings;  StringPtr namePrefix;  {   short int itemType;   Handle itemHandle;   Rect dispRect;   int numberOfItems = 0;   void *itemPtr;   char *itemStr;   Point theCell, cell_size;   Rect hdata_rect;   int i;   int maxLen = 0, tempLen;   struct stringStorage *arrayOfStrings, *sortedArray;   /*=================================================================*/   /* Get the information about the dialog item where the list of     */   /* rules will be displayed. Inset the display rectangle associated */   /* with the item by one so that the list of rules will be within   */   /* the rectangle. Reduce the right border by the additional amount */   /* that the scroll bar will take.                                  */   /*=================================================================*/   GetDItem(ManagerDialog,selectID,&itemType,&itemHandle,&dispRect);   InsetRect(&dispRect,1,1);   dispRect.right -= (SCROLL_BAR_WIDTH - 1);   /*==================================================================*/   /* Determine the number of items to be displayed in the dialog box. */   /*==================================================================*/   numberOfItems = 0;   itemPtr = NULL;   while ((itemPtr = (*returnItemFunction)(itemPtr)) != NULL)     { numberOfItems++; }   sprintf(DialogBuffer,"%d Item%s",numberOfItems,(numberOfItems == 1) ? "" : "s");   CTOPSTR(DialogBuffer);   ParamText((StringPtr) DialogBuffer,namePrefix,"\p","\p");   /*===============================================================*/   /* Create a rectangle for the LNew function which indicates that */   /* the list is to have one column with a number of rows equal to */   /* the number of items to be displayed.                          */   /*===============================================================*/   SetRect(&hdata_rect,0,0,1,numberOfItems);   /*======================================================*/   /* Create a point for the LNew function which indicates */   /* the height and width of a cell in the list.          */   /*======================================================*/   SetPt(&cell_size,(dispRect.right - dispRect.left),16);   /*========================================================*/   /* Call the LNew function to create a list for displaying */   /* the rules. The list will have a vertical scroll bar.   */   /*========================================================*/   Choices = LNew(&dispRect,&hdata_rect,cell_size,0,ManagerDialog,                  false,false,false,TRUE);   /*===================================================*/   /* Only one selection from the list will be allowed. */   /*===================================================*/   (*Choices)->selFlags = lOnlyOne;   /*========================================================*/   /* Store the names of the items in the cells of the list. */   /*========================================================*/   if (alphabetize)     {      /* Copy the values to an array. */      arrayOfStrings = malloc(sizeof(struct stringStorage) * numberOfItems);      i = 0;      itemPtr = (*returnItemFunction)(NULL);      while (itemPtr != NULL)        {         itemStr = (*returnPprintFunction)(itemPtr);         tempLen = strlen(itemStr);         if (tempLen > maxLen) maxLen = tempLen;         if (copyStrings)           {            arrayOfStrings[i].sPtr = malloc(tempLen + 1);            strcpy(arrayOfStrings[i].sPtr,itemStr);           }         else           { arrayOfStrings[i].sPtr = itemStr; }         itemPtr = (*returnItemFunction)(itemPtr);         if (itemPtr == NULL) arrayOfStrings[i].next = NULL;         else arrayOfStrings[i].next = &arrayOfStrings[i+1];         i++;        }      sortedArray = AlphaSort(arrayOfStrings,AlphaSortNext,AlphaSortSwitch,                               AlphaSortWord,maxLen);      i = 0;      while (sortedArray != NULL)        {         SetPt(&theCell,0,i);         LSetCell(sortedArray->sPtr,strlen(sortedArray->sPtr),theCell,Choices);         if (copyStrings) free(sortedArray->sPtr);         sortedArray = sortedArray->next;         i++;        }      free(arrayOfStrings);     }   else     {      i = 0;      itemPtr = NULL;      while ((itemPtr = (*returnItemFunction)(itemPtr)) != NULL)        {         SetPt(&theCell,0,i);         itemStr = (*returnPprintFunction)(itemPtr);         LSetCell(itemStr,strlen(itemStr),theCell,Choices);         i++;        }     }   /*=========================================*/   /* Select the first cell in the item list. */   /*=========================================*/   SetPt(&theCell,0,0);   LSetSelect((Boolean) TRUE,theCell,Choices);   /*==================================*/   /* Enable drawing of the item list. */   /*==================================*/   LDoDraw((Boolean) TRUE,Choices);   /*=========================*/   /* Display the dialog box. */   /*=========================*/   CenterWindowWithOffset(ManagerDialog,0.5,0.33,DH,DV);   ShowWindow(ManagerDialog);   /*============================================*/   /* Draw a rectangle around the list of items. */   /*============================================*/   EraseRect(&dispRect);   InsetRect(&dispRect,-1,-1);   FrameRect(&dispRect);   /*====================================*/   /* Force an update of the dialog box. */   /*====================================*/   LUpdate(ManagerDialog->visRgn,Choices);   return(numberOfItems);  }/***************************************************//* GEString:                                      *//***************************************************/static pascal short GEString(  Ptr aPtr,   Ptr bPtr,  short int aLen,   short int bLen)  {   int i = 0;   char ac, bc;   for (i = 0; i < aLen, i < bLen; i++)     {      ac = (isalpha(aPtr[i]) ? tolower(aPtr[i]) : aPtr[i]);      bc = (isalpha(bPtr[i]) ? tolower(bPtr[i]) : bPtr[i]);      if (ac < bc) return(1);      else if (ac > bc) return(0);     }   if (aLen >= bLen) return(0);   return(1);  }/***************************************************//* AlphaSortNext:                                      *//***************************************************/static void *AlphaSortNext(ptr)  void *ptr;  {   return ((struct stringStorage *) ptr)->next;  }/***************************************************//* AlphaSortSwitch:                                      *//***************************************************/static void AlphaSortSwitch(ptr1,ptr2)  void *ptr1, *ptr2;  {   struct stringStorage *cptr1, *cptr2;   cptr1 = ptr1;   cptr2 = ptr2;   cptr1->next = cptr2;   return;  }/***************************************************//* AlphaSortWord:                                      *//***************************************************/static char *AlphaSortWord(ptr)  void *ptr;  {   return ((struct stringStorage *) ptr)->sPtr;  }/******************************************************************//* CleanUpAfterManagerDialog: Disposes of the item selection list *//*   and the Manager dialog and then sets the port to the active  *//*   port before the dialog was created.                          *//******************************************************************/void CleanUpAfterManagerDialog(restoreWatch)  int restoreWatch;  {   LDispose(Choices);   DisposDialog(ManagerDialog);   SetPort(DialogManagerSavePort);   if (restoreWatch) DeactivateRouter(WTRACE);  }/***********************************************************//* SingleSelectFilter: Dialog filter function for handling *//*   mouse clicks inside of a list area in a dialog box.   *//***********************************************************/pascal Boolean SingleSelectFilter(DialogPtr theDialog,EventRecord *myEvent,short *itemNumber)  {   Point mouse_loc;   short int itemType;   Handle itemHandle;   Rect dispRect;   char ch;   Cell theCell;   int theSelection;   GrafPtr tempPort;   /*============================*/   /* Check for activate events. */   /*============================*/   if ((*myEvent).what == activateEvt)     {      GetPort(&tempPort);      DoActivate(myEvent);      SetPort(tempPort);      return(false);     }   /*=======================*/   /* Handle update events. */   /*=======================*/   if ((*myEvent).what == updateEvt)     {      GetPort(&tempPort);      DoUpdate(myEvent);      SetPort(tempPort);      return(false);     }   /*=====================================*/   /* Check for certain keypress actions. */   /*=====================================*/   if ((*myEvent).what == keyDown)     {      ch = (char) BitAnd(myEvent->message,charCodeMask);      if (BitAnd(myEvent->modifiers,cmdKey) != 0) return(false);      /*==========================================================*/      /* The return or enter key acts as if item #1 was selected. */      /*==========================================================*/      if ((ch == '\r') || (ch == '\n') || (ch == '\03'))        {         GetDItem(theDialog,1,&itemType,&itemHandle,&dispRect);         if ((*((ControlHandle) itemHandle))->contrlHilite == ACTIVE_VALUE)           {            *itemNumber = 1;            FlashButton((DialogPtr) theDialog,1);            return(TRUE);           }         else           { return(false); }        }      /*=================================*/      /* Process up and down arrow keys. */      /*=================================*/      if ((ch == DOWN_ARROW_KEY) || (ch == UP_ARROW_KEY))        {         SetPt(&theCell,0,0);         if (LGetSelect((Boolean) TRUE,&theCell,Choices))           {            LSetSelect((Boolean) false,theCell,Choices);            LDraw(theCell,Choices);            if (ch == DOWN_ARROW_KEY)              { if (theCell.v < ((*Choices)->dataBounds.bottom - 1)) theCell.v++; }            else              { if (theCell.v > 0) theCell.v--; }           }         else           {            if (ch == DOWN_ARROW_KEY) SetPt(&theCell,0,0);            else SetPt(&theCell,0,(*Choices)->dataBounds.bottom - 1);           }         LSetSelect((Boolean) TRUE,theCell,Choices);         LDraw(theCell,Choices);         LAutoScroll(Choices);         *itemNumber = SelectItem;         return (TRUE);        }      /*============================*/      /* Ignore control characters. */      /*============================*/      if ((ch == DELETE_KEY) || (ch <= DOWN_ARROW_KEY)) return(false);      /*============================*/      /* Allow selection by typing. */      /*============================*/      if (TickCount() > (LastEntryTime + GetDblTime()))        {         ListKeyCurrentPos = ListKeyRestartPos;        }      SetPt(&theCell,0,0);      if (LGetSelect((Boolean) TRUE,&theCell,Choices))        {         LSetSelect((Boolean) false,theCell,Choices);         LDraw(theCell,Choices);        }      SetPt(&theCell,0,0);      if (ListKeyCurrentPos < LIST_KEY_MAX)        { ListKeySelection[ListKeyCurrentPos++] = ch; }      if (LSearch(ListKeySelection,ListKeyCurrentPos,(SearchPtr) GEStringRef,&theCell,Choices))        {         LSetSelect((Boolean) TRUE,theCell,Choices);         LDraw(theCell,Choices);         LAutoScroll(Choices);        }      else        {         SetPt(&theCell,0,(*Choices)->dataBounds.bottom - 1);         LSetSelect((Boolean) TRUE,theCell,Choices);         LDraw(theCell,Choices);         LAutoScroll(Choices);        }      LastEntryTime = TickCount();      *itemNumber = SelectItem;      return (TRUE);     }   /*========================================*/   /* If the event is not a mouse-down, then */   /* allow the event to be handle normally. */   /*========================================*/   if ((*myEvent).what != mouseDown) return(false);   /*==============================================*/   /* Get Point in screen coordinates and convert  */   /* to window coordinates.                       */   /*==============================================*/   mouse_loc = myEvent->where;   GlobalToLocal(&mouse_loc);   /*======================================================*/   /* Get the location of the list area in the dialog box. */   /*======================================================*/   GetDItem(theDialog,SelectItem,&itemType,&itemHandle,&dispRect);   /*========================================================*/   /* If the mouse-down event occurred inside the list area, */   /* then call LClick to handle the event. Set the value    */   /* of the item hit to the list area and indicate that     */   /* the event has been handle by returning TRUE.           */   /*========================================================*/   if (PtInRect(mouse_loc,&dispRect))     {      int doubleClick;      /*===========================================*/      /* Track the click using LClick and remember */      /* the start and end times of the click.     */      /*===========================================*/      doubleClick = LClick(mouse_loc,myEvent->modifiers,Choices);      /*=============================================================*/      /* Determine the active selection. If the click occured in the */      /* scroll area, then this is not considered a selection.       */      /*=============================================================*/      theSelection = GetSingleSelection(Choices);      if (PtInRect(mouse_loc,&(*Choices)->rView) == false) theSelection = -1;      /*===========================*/      /* Check for a double click. */      /*===========================*/      if ((DoubleClickActive) && (doubleClick) &&          (theSelection >= 0))        {         *itemNumber = 1;         FlashButton((DialogPtr) theDialog,1);         return(TRUE);        }      /*=======================================*/      /* Item selection is the selection area. */      /*=======================================*/      *itemNumber = SelectItem;      return (TRUE);     }   /*=========================================*/   /* Allow the event to be handled normally. */   /*=========================================*/   return (false);  }/******************************************************************//* GetSingleSelection: Returns the current selection from a list. *//******************************************************************/int GetSingleSelection(choices_ptr)  ListHandle choices_ptr;  {   Cell theCell;   SetPt(&theCell,0,0);   if (LGetSelect(TRUE,&theCell,choices_ptr)) return(theCell.v);   else return(-1);  }/*******************************************//* PutSelectionNameInBuffer: *//*******************************************/int PutSelectionNameInBuffer()  {   short int selection, maxLen;   Cell theCell;   selection = GetSingleSelection(Choices);   if (selection >= 0)     {      maxLen = DIALOG_BUFFER_SIZE - 1;      SetPt(&theCell,0,selection);      LGetCell(DialogBuffer,&maxLen,theCell,Choices);      DialogBuffer[maxLen] = '\0';     }   else     { DialogBuffer[0] = '\0'; }   return(selection);  }/***************************************************************//* GenericPrintButton:                                        *//***************************************************************/void GenericPrintButton(findItemFunction,getPPFormFunction,printCommand,extraArg)  void *(*findItemFunction)(char *);  char *(*getPPFormFunction)(VOID *);  char *printCommand;  char *extraArg;  {#if ! RUN_TIME   void *theItem;   char *thePtr;   theItem = (*findItemFunction)(DialogBuffer);   if (theItem != NULL)     {      thePtr = (*getPPFormFunction)(theItem);      if (thePtr != NULL)        {         FlushCommandString();         PrintCLIPS("stdout",printCommand);         if (extraArg != NULL)           {            PrintCLIPS("stdout",extraArg);            PrintCLIPS("stdout"," ");           }         PrintCLIPS("stdout",DialogBuffer);         PrintCLIPS("stdout",")\n");         PrintCLIPS("stdout",thePtr);         PrintPrompt();        }     }#endif  }/***************************************************************//* GenericDeleteButton1:                                        *//***************************************************************/void GenericDeleteButton1(findItemFunction,deleteItemFunction,currentSelection,numberOfItems,namePrefix)  void *(*findItemFunction)(char *);  int (*deleteItemFunction)(VOID *);  int *currentSelection;  int *numberOfItems;  StringPtr namePrefix;  {   void *theItem;   Cell theCell;   char tempBuffer[30];   theItem = (*findItemFunction)(DialogBuffer);   if (theItem != NULL)     {      (*deleteItemFunction)(theItem);      LDelRow(1,*currentSelection,Choices);      (*numberOfItems)--;      if ((*currentSelection) >= (*numberOfItems)) (*currentSelection)--;      SetPt(&theCell,0,*currentSelection);      LSetSelect((Boolean) TRUE,theCell,Choices);      *currentSelection = PutSelectionNameInBuffer();      sprintf(tempBuffer,"%d Item%s",*numberOfItems,(*numberOfItems == 1) ? "" : "s");      CTOPSTR(tempBuffer);      ParamText((StringPtr) tempBuffer,namePrefix,"\p","\p");      DrawDialog(ManagerDialog);     }   }/***************************************************************//* GenericDeleteButton2:                                        *//***************************************************************/void GenericDeleteButton2(findItemFunction,deleteItemFunction,currentSelection,numberOfItems,namePrefix)  void *(*findItemFunction)(int);  int (*deleteItemFunction)(VOID *);  int *currentSelection;  int *numberOfItems;  StringPtr namePrefix;  {   void *theItem;   Cell theCell;   char tempBuffer[30];   theItem = (*findItemFunction)(*currentSelection + 1);   if (theItem != NULL)     {      (*deleteItemFunction)(theItem);      LDelRow(1,*currentSelection,Choices);      (*numberOfItems)--;      if ((*currentSelection) >= (*numberOfItems)) (*currentSelection)--;      SetPt(&theCell,0,*currentSelection);      LSetSelect((Boolean) TRUE,theCell,Choices);      *currentSelection = GetSingleSelection(Choices);      sprintf(tempBuffer,"%d Item%s",*numberOfItems,(*numberOfItems == 1) ? "" : "s");      CTOPSTR(tempBuffer);      ParamText((StringPtr) tempBuffer,namePrefix,"\p","\p");      DrawDialog(ManagerDialog);     }   }/*************************************************************//* DefaultConstructManagerClikloop:                          *//*************************************************************/pascal Boolean DefaultConstructManagerClikloop()  {   int selection;   selection = GetSingleSelection(Choices);   (*UpdateConstructManagerButtonsFunction)(ManagerDialog,selection);   return (TRUE);  }