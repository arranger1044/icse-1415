   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*           MACINTOSH INITIALIZATION MODULE           */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _MACINIT_SOURCE_#include "setup.h"#include <stdio.h>#include <stdlib.h>#define _STDIO_INCLUDED_#include <string.h>#include <ctype.h>#include <Fonts.h>#include <Memory.h>#include <QuickDraw.h>#include <Events.h>#include <Menus.h>#include <TextEdit.h>#include <Controls.h>#include <ToolUtils.h>#include <SegLoad.h>#include <Devices.h>/* #include <Desk.h> */#include <Retrace.h>/* #include <OSEvents.h> */#include <OsUtils.h>#if MAC_MCW || MAC_SC7 || MAC_MPW || MAC_SC8#include <Printing.h>#else#include <PrintTraps.h>#endif#include <Files.h>#include <Timer.h>#include <Errors.h>#include <AppleEvents.h>#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_SC7 || MAC_SC8#define PTOCSTR P2CStr#define CTOPSTR C2PStr#else#define PTOCSTR p2cstr#define CTOPSTR c2pstr#endif#if MAC_SC7 || MAC_MCW || MAC_SC8#define AppleEventProcPtr AEEventHandlerUPP#define VBLPtr VBLUPP#else#define AppleEventProcPtr ProcPtr#define VBLPtr VBLProcPtr#endif#include <StandardFile.h>#if MAC_SC7 || MAC_MPW || MAC_MCW || MAC_SC8#include <LowMem.h>#endif#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#define THE_PORT (qd.thePort)#include "constant.h"#include "commline.h"#include "agenda.h"#include "filecom.h"#include "engine.h"#include "utility.h"#include "clipsmem.h"#include "router.h"#include "filertr.h"#include "appevent.h"#include "apprsrcs.h"#include "dsplio.h"#include "prefernc.h"#include "stnrdmac.h"#include "clpscrap.h"#include "interface.h"#include "menuhndl.h"#include "displayw.h"#include "mainloop.h"#include "window.h"#include "filemenu.h"#include "editmenu.h"#include "menucmds.h"#include "kbstatw.h"#include "brwsmenu.h"#include "editdlog.h"#include "editwdrg.h"#include "macinit.h"/***************//* DEFINITIONS *//***************/#define CONTROL_C '\3'#define StopCantDoID 1009/********************************//* LOW MEMORY GLOBAL DEFINITION *//********************************/#if MAC_TC6   static char                   *CursorBusy = (char *) 0x8CD;#endif/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                    UpdateCursor(void);   static void                    SetUpRouters(void);   static int                     MacExitFunction(int);   static VOID                    MacExecFunction(void);   void                           ApplicationVBLTask(void);   static void                    SetUpVBLTask(void);   static int                     MacOutOfMemoryFunction(unsigned long);   static void                    CheckSystemVersion(short int *);   static void                    ApplicationMenuUpdate(WindowPtr,EventRecord *,int);   static BOOLEAN                 macfilefind(char *);   static int                     macfileprint(char *,char *);   static int                     macfilegetc(char *);   static int                     macfileungetc(int,char *);   static void                    DoReadMouseDown(EventRecord *);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static VBLTask          vTask;   static BOOLEAN          UpdateCursorFlag = TRUE;   static int              UseSaveCharacter = false;   static char             SaveCharacter;   #if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor              VBLTaskRD       = BUILD_ROUTINE_DESCRIPTOR(uppVBLProcInfo,ApplicationVBLTask);#define VBLTaskRef &VBLTaskRD#else#define VBLTaskRef ApplicationVBLTask#endif  /*************************************************************//* InitializeInterface: Initializes the Macintosh interface. *//*************************************************************/void InitializeInterface()  {   short int sysVRefNum;   extern void DefineMacFunctions(void);   /*=====================================================*/   /* Macintosh Incantation for initializing application. */   /*=====================================================*/   InitGraf(&THE_PORT);   InitFonts();   InitWindows();   InitMenus();   TEInit();   InitDialogs(0L);   InitCursor();   FlushEvents(everyEvent,0);   /*==============================*/   /* Set up apple event handlers. */    /*==============================*/   AEInstallEventHandler(kCoreEventClass,kAEOpenApplication,                              (AppleEventProcPtr) DoOpenApplicationHighLevelEventRef,                         0,false);   AEInstallEventHandler(kCoreEventClass,kAEOpenDocuments,                         (AppleEventProcPtr) DoOpenDocumentsHighLevelEventRef,0,false);   AEInstallEventHandler(kCoreEventClass,kAEPrintDocuments,                         (AppleEventProcPtr) DoPrintDocumentsHighLevelEventRef,0,false);   AEInstallEventHandler(kCoreEventClass,kAEQuitApplication,                         (AppleEventProcPtr) DoQuitApplicationHighLevelEventRef,0,false);                AEInstallEventHandler('CLIS','DOSC',                         (AppleEventProcPtr) DoCommandPromptHighLevelEventRef,0,true);     AEInstallEventHandler('CLIS','CMPL',                         (AppleEventProcPtr) DoCompileTextHighLevelEventRef,0,true);     AEInstallEventHandler('CLIS','BTCH',                         (AppleEventProcPtr) DoBatchTextHighLevelEventRef,0,true);                AEInstallEventHandler('CLIS','SWD=',                         (AppleEventProcPtr) DoSetWorkingDirectoryHighLevelEventRef,0,true);                /*===================================================*/   /* Check for appropriate system version and machine. */   /*===================================================*/   CheckSystemVersion(&sysVRefNum);   /*======================================*/   /* Determine various system attributes. */   /*======================================*/   if (! GetSystemAttributes())     { ExitToShell(); }   /*===============================*/   /* Set up the menus and cursors. */   /*===============================*/   StandardSetup();   SetUpResources();   /*===========================*/   /* Load the preference file. */   /*===========================*/   GetPreferences();   /*=======================*/   /* Initialize the Scrap. */   /*=======================*/   InitializeScrap(EditMenu,PasteItem);   /*============================*/   /* Install the menu routines. */   /*============================*/   SetApplicationMenuUpdateRoutine(ApplicationMenuUpdate);   /*================================================================*/   /* Set up routers for the interface and setup the display window. */   /*================================================================*/   SetUpRouters();   CreateDisplayWindow(DisplayApplicationHook);   /*=====================================================================*/   /* Set up the interrupt task looking for command-period and control-c. */   /*=====================================================================*/   SetUpVBLTask();   /*================================================================*/   /* Set up hook between the command loop and interface event loop. */   /*================================================================*/#if ! RUN_TIME   SetEventFunction(MainEvent);#endif   /*==================================================================*/   /* Add execution function to update interface between rule firings. */   /*==================================================================*/#if DEFRULE_CONSTRUCT   AddRunFunction("macint",MacExecFunction,0); #endif   AddPeriodicFunction("mac-pf",MacPeriodicFunction,0);   YieldTimeFunction = MacYieldTimeFunction;      /*===================================*/   /* Change the functions to be called */   /* for out of memory conditions.     */   /*===================================*/   SetOutOfMemoryFunction(MacOutOfMemoryFunction);   /*==========================*/   /* Add Macintosh functions. */   /*==========================*/   DefineMacFunctions();      SetupBackgroundMouseDrag();  }/******************************************************//* CheckSystemVersion: Determines if the  application *//*   can run with the installed OS version.           *//******************************************************/static void CheckSystemVersion(sysVRefNum)  short int *sysVRefNum;  {   SysEnvRec theWorld;   Str255 applicationName;      strncpy((char *) applicationName,APPLICATION_NAME,255);   applicationName[255] = '\0';   CTOPSTR((char *) applicationName);   if (SysEnvirons(2,&theWorld) == envNotPresent)     {      ParamText(applicationName,"\p requires System 4.1 or greater","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      ExitToShell();     }   else if ((theWorld.machineType < 0) || (theWorld.machineType == 1))     {      ParamText(applicationName,"\p will only run on a Mac Plus, SE, or II","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      ExitToShell();     }   *sysVRefNum = theWorld.sysVRefNum;  }/**************************************//* SetUpRouters: Sets up routers used *//*   by the Macintosh interface.      *//**************************************/static void SetUpRouters()  {   AddRouter("macexit",60,NULL,NULL,NULL,NULL,MacExitFunction);   AddRouter("macstdout",10,macfilefind,macfileprint,macfilegetc,macfileungetc,NULL);  }/********************************************************************//* MacExitFunction: routine to check an exit from the dialog window *//*   to make sure that the user has an opportunity to save files.   *//********************************************************************/static int MacExitFunction(num)  int num;  {   if (num >= 0) return(1);   DoQuit();   AbortExit();   return(1);  }/*******************************************************//* MacExecFunction: Execution function which is called *//*   between rule firings to update the interface.     *//*******************************************************/#if DEFRULE_CONSTRUCTstatic VOID MacExecFunction()  {   static unsigned long lastUpdate = 0;   long theTick;      theTick = TickCount();      if (theTick < (lastUpdate + 60)) return;    UpdateStatusWindows();   HandlePeriodicEvents();   lastUpdate = theTick;  }#endif/******************************************//* ApplicationVBLTask:                          *//******************************************/static void ApplicationVBLTask()  {   static int state = 1;   long oldA5;   extern int HandlingEvent;   /*=====================*/   /* Save the registers. */   /*=====================*/   oldA5 = SetCurrentA5();   /*=================================================*/   /* Check for command period and update the cursor. */   /*=================================================*/   if (state == 1) CheckForCommandPeriod();#if ! RUN_TIME   if ((EvaluatingTopLevelCommand | BatchActive()) && UpdateCursorFlag && (! HandlingEvent)) UpdateCursor();#else   if (BatchActive() && UpdateCursorFlag && (! HandlingEvent)) UpdateCursor();#endif   state = 1 - state;   /*=========================================*/   /* Don't check again for another 10 ticks. */   /*=========================================*/   vTask.vblCount = 10;   /*========================*/   /* Restore the registers. */   /*========================*/   SetA5(oldA5);  }/**********************************************//* CheckForCommandPeriod:                     *//**********************************************/void CheckForCommandPeriod()  {   QHdrPtr theQueue;   EvQElPtr myEvent;   char theChar;   theQueue = GetEvQHdr();   myEvent = (EvQElPtr) theQueue->qHead;   while (myEvent != NULL)     {      if ((myEvent->evtQWhat == keyDown) ||          (myEvent->evtQWhat == autoKey))        {         theChar = myEvent->evtQMessage & charCodeMask;         if ((BitAnd(myEvent->evtQModifiers,cmdKey) != 0) && (theChar == '.'))           {            if (BitAnd(myEvent->evtQModifiers,shiftKey) != 0)              {               SetHaltExecution(1);               CloseAllBatchSources();              }            else              {#if DEFRULE_CONSTRUCT               if (ExecutingRule != NULL) HaltRules = TRUE;               else#endif                 {                  SetHaltExecution(1);                  CloseAllBatchSources();                 }              }            myEvent->evtQMessage = BitAnd(myEvent->evtQMessage,BitNot(charCodeMask));            myEvent->evtQMessage = BitOr(myEvent->evtQMessage,BitAnd((long) 'y',0x000000FFL));            myEvent = NULL;           }         else           { myEvent = (EvQElPtr) myEvent->qLink; }        }      else        { myEvent = (EvQElPtr) myEvent->qLink; }     }   }/**********************************************//* SetUpVBLTask:                              *//**********************************************/static void SetUpVBLTask()  {   vTask.qType = vType;   vTask.vblAddr = (VBLPtr) VBLTaskRef;   vTask.vblCount = 10;   vTask.vblPhase = 0;   VInstall((QElemPtr) &vTask);  }/**********************************************//* RemoveVBLTask:                             *//**********************************************/void RemoveVBLTask()  {   VRemove((QElemPtr)&vTask);  }/**********************************************//* MacOutOfMemoryFunction:                    *//**********************************************/static int MacOutOfMemoryFunction(size)  unsigned long size;  {#if MAC_MPW || MAC_MCW#pragma unused(size)#endif   Str255 applicationName;      strncpy((char *) applicationName,APPLICATION_NAME,255);   applicationName[255] = '\0';   CTOPSTR((char *) applicationName);   ParamText(applicationName,"\p is out of memory!","\p","\p");   StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);   ExitToShell();   return(1);  }/********************************************************************//* MacBeforeResetFunction: Function called before performing reset. *//*   Returns TRUE if the reset should be done, otherwise false.     *//********************************************************************/int MacBeforeResetFunction()  {   Str255 pStringBuffer;      sprintf((char *) pStringBuffer,      "There are activations on the agenda. OK to reset the %s environment?",      APPLICATION_NAME);   CTOPSTR((char *) pStringBuffer);   #if DEFRULE_CONSTRUCT   if ((WarningsOption == TRUE) && (GetNextActivation(NULL) != NULL))     {      if (OKCancelAlertDialog(pStringBuffer) == 0)        { return(false); }     }#endif   SetCursor(*WatchCursor);   return(TRUE);  }/********************************************************************//* MacBeforeClearFunction: Function called before performing clear. *//*   Returns TRUE if the clear should be done, otherwise false.     *//********************************************************************/int MacBeforeClearFunction()  {   Str255 pStringBuffer;      sprintf((char *) pStringBuffer,"OK to clear the %s environment?",      APPLICATION_NAME);   CTOPSTR((char *) pStringBuffer);      if (WarningsOption == TRUE)     {      if (OKCancelAlertDialog(pStringBuffer) == false)        { return(false); }     }   SetCursor(*WatchCursor);   return(TRUE);  }/******************************************//* UpdateCursor: Changes the image of the *//*   cursor displayed when KB is "busy"   *//*   processing a command.                *//******************************************/static void UpdateCursor()  {   static int state = 1;#if MAC_SC6   if (*CursorBusy) return;#else   if (LMGetCrsrBusy()) return;#endif   switch (state)     {      case 1: SetCursor(*Atom1Cursor); break;      case 2: SetCursor(*Atom2Cursor); break;      case 3: SetCursor(*Atom3Cursor); break;      case 4: SetCursor(*Atom4Cursor); break;      case 5: SetCursor(*Atom5Cursor); break;      case 6: SetCursor(*Atom6Cursor); break;      case 7: SetCursor(*Atom7Cursor); break;      case 8: SetCursor(*Atom8Cursor); break;     }   state++;   if (state > 8) state = 1;  }/*********************************************//* SetUpdateCursorFlag:                      *//*********************************************/void SetUpdateCursorFlag(value)  int value;  {   UpdateCursorFlag = value;  }/*********************************************//* GetUpdateCursorFlag:                      *//*********************************************/int GetUpdateCursorFlag()  {   return(UpdateCursorFlag);  }/************************************************************//* ApplicationMenuUpdate:                              *//************************************************************/static void ApplicationMenuUpdate(whichWindow,myEvent,when)  WindowPtr whichWindow;  EventRecord *myEvent;  int when;  {#if MAC_MPW || MAC_MCW#pragma unused(myEvent)#endif   Str255 pStringBuffer;      if (when == POST_MENU_UPDATE) return;   /*=================================*/   /* Enable items in the Apple menu. */   /*=================================*/      sprintf((char *) pStringBuffer,"About %s...",APPLICATION_NAME);   CTOPSTR((char *) pStringBuffer);   SetItem(AppleMenu,AboutApplicationItem,pStringBuffer);      /*================================*/   /* Enable items in the File menu. */   /*================================*/#if ! RUN_TIME   if ((! EvaluatingTopLevelCommand) && (! BatchActive()))#else   if (! BatchActive())#endif     {      EnableItem(FileMenu,NewItem);      EnableItem(FileMenu,OpenItem);      EnableItem(FileMenu,LoadItem);      EnableItem(FileMenu,LoadBatchItem);      EnableItem(FileMenu,LoadBinaryItem);      EnableItem(FileMenu,SaveBinaryItem);      EnableItem(FileMenu,QuitItem);     }#if DEBUGGING_FUNCTIONS   EnableItem(FileMenu,OpenDribbleItem);   if (DribbleActive())     { SetItem(FileMenu,OpenDribbleItem,"\pTurn Dribble Off"); }   else     { SetItem(FileMenu,OpenDribbleItem,"\pTurn Dribble On...");  }#endif   EnableItem(FileMenu,PageSetupItem);   /*================================*/   /* Enable Items in the Edit menu. */   /*================================*/   EnableItem(EditMenu,PreferencesItem);   /*===================================*/   /* Enable Items in the Command menu. */   /*===================================*/         #if ! RUN_TIME   if ((! EvaluatingTopLevelCommand) && (! BatchActive()))#else   if (! BatchActive())#endif     {      EnableItem(CommandsMenu,SetCommandsItem);      EnableItem(CommandsMenu,Command1Item);      EnableItem(CommandsMenu,Command2Item);      EnableItem(CommandsMenu,Command3Item);      EnableItem(CommandsMenu,Command4Item);      EnableItem(CommandsMenu,Command5Item);      EnableItem(CommandsMenu,Command6Item);      EnableItem(CommandsMenu,Command7Item);      EnableItem(CommandsMenu,Command8Item);      EnableItem(CommandsMenu,Command9Item);      EnableItem(CommandsMenu,Command0Item);     }   EnableItem(CommandsMenu,WatchItem);   EnableItem(CommandsMenu,OptionsItem);   /*==================================*/   /* Enable Items in the Browse menu. */   /*==================================*/   UpdateBrowseMenu();   /*===================================*/   /* Enable Items in the Windows menu. */   /*===================================*/   EnableItem(WindowMenu,DisplayWindowItem);   EnableItem(WindowMenu,FactsWindowItem);   EnableItem(WindowMenu,AgendaWindowItem);   EnableItem(WindowMenu,InstancesWindowItem);   EnableItem(WindowMenu,GlobalsWindowItem);   EnableItem(WindowMenu,FocusWindowItem);   EnableItem(WindowMenu,AllAboveItem);   EnableWindowMenuItems();   if (whichWindow == DisplayWindow) CheckItem(WindowMenu,DisplayWindowItem,TRUE);   else if (whichWindow == FactsWindow) CheckItem(WindowMenu,FactsWindowItem,TRUE);   else if (whichWindow == AgendaWindow) CheckItem(WindowMenu,AgendaWindowItem,TRUE);   else if (whichWindow == InstancesWindow) CheckItem(WindowMenu,InstancesWindowItem,TRUE);   else if (whichWindow == GlobalsWindow) CheckItem(WindowMenu,GlobalsWindowItem,TRUE);   else if (whichWindow == FocusWindow) CheckItem(WindowMenu,FocusWindowItem,TRUE);   UpdateWindowMenuCheck(whichWindow,TRUE);  }/*****************************************************//* MACFILEFIND: Router function which recognizes I/O *//*   directed to the display window.                 *//*****************************************************/static BOOLEAN macfilefind(logicalName)  char *logicalName;  {   if ( (strcmp(logicalName,"stdout") == 0) ||        (strcmp(logicalName,"stdin") == 0) ||        (strcmp(logicalName,WCLIPS) == 0) ||        (strcmp(logicalName,WTRACE) == 0) ||        (strcmp(logicalName,WERROR) == 0) ||        (strcmp(logicalName,WWARNING) == 0) ||        (strcmp(logicalName,WDISPLAY) == 0) ||        (strcmp(logicalName,WDIALOG) == 0) )     { return(TRUE); }    return(false);  }/*********************************************************************//* MACFILEPRINT: Router function which prints to the display window. *//*********************************************************************/static int macfileprint(logicalName,str)  char *logicalName, *str;  {   FILE *fptr;   fptr = FindFptr(logicalName);   if (fptr == stdout)     { DisplayPrint(str); }   else     { fprintf(fptr,"%s",str); }   return(1);  }/*******************************************************************//* MACFILEGETC: Router function to get stdout written to terminal  *//*******************************************************************/static int macfilegetc(logicalName)  char *logicalName;  {   FILE *fptr;   char inp[2];   char theChar;   EventRecord myEvent;   fptr = FindFptr(logicalName);   if (fptr != stdin) return(getc(fptr));   if (UseSaveCharacter == TRUE)     {      UseSaveCharacter = false;      return(SaveCharacter);     }   SetUpdateCursorFlag(false);   SetCursor(*ReadCursor);   for (; ; )     {      while (GetTheEvent(everyEvent & (~highLevelEventMask),&myEvent) == 0)        { /* Do Nothing */ }      switch (myEvent.what)        {         case updateEvt:           DoUpdate(&myEvent);           break;         case mouseDown:           DoReadMouseDown(&myEvent);           break;         case activateEvt:           DoActivate(&myEvent);           break;         case keyDown:         case autoKey:           theChar = myEvent.message & charCodeMask;           if ((myEvent.modifiers & cmdKey) == 0)             {              if ((theChar == '\b') && (CLIPSInputCount == 0)) break;              inp[0] = theChar;              inp[1] = '\0';              PrintCLIPS("stdout",inp);              SelectDisplayWindow();              if ((theChar == '\n') || (theChar == '\r')) ShowDisplayEnd(TRUE);              else ShowDisplayEnd(FALSE);              SetUpdateCursorFlag(TRUE);              return(theChar);             }           else if ((BitAnd(myEvent.modifiers,cmdKey) != 0) &&                    (theChar == '.'))             {              if (BitAnd(myEvent.modifiers,shiftKey) != 0)                {                 SetHaltExecution(1);                 CloseAllBatchSources();                }              else                {#if DEFRULE_CONSTRUCT                 if (ExecutingRule != NULL) HaltRules = TRUE;                 else#endif                   {                    SetHaltExecution(1);                    CloseAllBatchSources();                   }                }              return(EOF);             }           else if ((BitAnd(myEvent.modifiers,controlKey) != 0) &&                    (theChar == CONTROL_C))             {              if (BitAnd(myEvent.modifiers,shiftKey) != 0)                { SetHaltExecution(1); }              else                {#if DEFRULE_CONSTRUCT                 if (ExecutingRule != NULL) HaltRules = TRUE;                 else #endif                   { SetHaltExecution(1); }                }              return(EOF);             }           break;        }     }  }/***********************************************************//* DoReadMouseDown: Handle mouse-down event during a read. *//***********************************************************/static void DoReadMouseDown(myEvent)  EventRecord *myEvent;  {   WindowPtr whichWindow;   /*============================================*/   /* Where on the screen was the mouse pressed? */   /*============================================*/   switch (FindWindow(myEvent->where,&whichWindow ))     {      case inSysWindow:        SystemClick(myEvent,whichWindow);        break;      case inMenuBar:        SysBeep(20);        break;      case inContent:        DoContent(whichWindow,myEvent);        break;      case inDrag:        DoDrag(whichWindow,myEvent);        break;      case inGrow:        DoGrow(whichWindow,myEvent);        break;      case inGoAway:        DoGoAway(whichWindow,myEvent);        break;      case inZoomIn:        DoZoom(whichWindow,inZoomIn,myEvent);        break;      case inZoomOut:        DoZoom(whichWindow,inZoomOut,myEvent);        break;     }  }/******************************************************//* macfileungetc:  Returns a pointer to a file stream *//*   for a given file id tag.                         *//******************************************************/static int macfileungetc(ch,logicalName)  int ch;  char *logicalName;  {   FILE *fptr;   return(EOF);   fptr = FindFptr(logicalName);   if (fptr == stdin)     {      UseSaveCharacter = TRUE;      SaveCharacter = ch;     }   else     { ungetc(ch,fptr); }  }