   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.3  04/22/94          */   /*                                                     */   /*                MENU COMMANDS MODULE                 */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*      Brian L. Donnell                                     *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _MENUCMDS_SOURCE_#include "setup.h"#include <string.h>#include <ctype.h>#include <Memory.h>#include <Files.h>#include <Packages.h>#include <Devices.h>/* #include <Desk.h> */#include <TextEdit.h>#include <Menus.h>#include <Windows.h>#include <Dialogs.h>#if MAC_MCW || MAC_SC7 || MAC_MPW || MAC_SC8#include <Printing.h>#else#include <PrintTraps.h>#endif#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#include <Events.h>#include <Controls.h>#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#if MAC_SC7 || MAC_SC8#define PTOCSTR P2CStr#define CTOPSTR C2PStr#else#define PTOCSTR p2cstr#define CTOPSTR c2pstr#endif#define PSTRCAST StringPtr#include "commline.h"#include "router.h"#include "filecom.h"#include "appevent.h"#include "apprsrcs.h"#include "interface.h"#include "menucmds.h"#include "displayw.h"#include "kbstatw.h"#include "statusw.h"#include "editmenu.h"#include "filemenu.h"#include "window.h"#include "mainloop.h"#include "editw.h"#include "dlogmngr.h"#include "macinit.h"#include "prcddlog.h"#include "gnrcdlog.h"#include "ruledlog.h"#include "execdlog.h"#include "editdlog.h"#include "factdlog.h"#include "cooldlog.h"/***************//* DEFINITIONS *//***************/#define StopCantDoID 1009/****************************************************************//* DoLoad: Performs Load..., Load Batch..., and Load Binary...  *//*   commands found under file menu.  Uses standard file dialog *//*   to request the load file.                                  *//****************************************************************/void DoLoad(loadType)  int loadType;  {#if ! RUN_TIME   SFTypeList theTypeList;   StandardFileReply theReply;   int numTypes;   char *commandPrefix, *commandPostfix = "\")\n", *theString;   /*===============================*/   /* Restrict the file types based */   /* on the type of load.          */   /*===============================*/   if (loadType == BINARY_FILE)     { numTypes = -1; }   else if (loadType == TEXT_FILE)     {      numTypes = 1;      theTypeList[0] = 'TEXT';     }   else if (loadType == BATCH_FILE)     {      numTypes = 2;      theTypeList[0] = 'TEXT';      theTypeList[1] = 'BTCH';     }   /*==========================*/   /* Get file name from user. */   /*==========================*/   StandardGetFile(NULL,numTypes,theTypeList,&theReply);   /*=====================================*/   /* Exit if file request was cancelled. */   /*=====================================*/   if (theReply.sfGood == false) return;   /*===================================================*/   /* Send an AppleEvent to reset the current volume so */   /* that the UNIX fopen function will find the file.  */   /*===================================================*/      SendSetWorkingDirectoryCommand(&theReply.sfFile);       /*==========================================================*/   /* Construct the load command string and send an AppleEvent */   /* to execute the command at the command prompt.            */   /*==========================================================*/   if (loadType == BINARY_FILE) commandPrefix = "(bload \"";   else if (loadType == TEXT_FILE) commandPrefix = "(load \"";   else if (loadType == BATCH_FILE) commandPrefix = "(batch \"";   PTOCSTR((PSTRCAST) theReply.sfFile.name);      theString = NewPtr(strlen(commandPrefix) +                       strlen((char *) theReply.sfFile.name) +                      strlen(commandPostfix) + 1);   theString[0] = 0;   strcat(theString,commandPrefix);   strcat(theString,(char *) theReply.sfFile.name);    strcat(theString,commandPostfix);                     SendAEPromptCommand(theString,'DOSC');                  DisposePtr(theString);   CTOPSTR((char *) theReply.sfFile.name);#endif  }/*****************************************//* DoSaveBinary: Performs Save Binary... *//*   command found under the file menu.  *//*****************************************/void DoSaveBinary()  {#if ! RUN_TIME   StandardFileReply theReply;   Str255 theTitle = "\pconstructs.bin";   char *commandPrefix, *commandPostfix = "\")\n", *theString;   /*====================*/   /* Get the file name. */   /*====================*/   StandardPutFile("\pSave Binary Image as:",theTitle,&theReply);   /*=====================================*/   /* Exit if file request was cancelled. */   /*=====================================*/   if (theReply.sfGood == false) return;      /*===================================================*/   /* Send an AppleEvent to reset the current volume so */   /* that the UNIX fopen function will find the file.  */   /*===================================================*/   SendSetWorkingDirectoryCommand(&theReply.sfFile);    /*===========================================================*/   /* Construct the bsave command string and send an AppleEvent */   /* to execute the command at the command prompt.             */   /*===========================================================*/   commandPrefix = "(bsave \"";      PTOCSTR((PSTRCAST) theReply.sfFile.name);   theString = NewPtr(strlen(commandPrefix) +                       strlen((char *) theReply.sfFile.name) +                      strlen(commandPostfix) + 1);   theString[0] = 0;   strcat(theString,commandPrefix);   strcat(theString,(char *) theReply.sfFile.name);    strcat(theString,commandPostfix);                     SendAEPromptCommand(theString,'DOSC');                  DisposePtr(theString);   CTOPSTR((char *) theReply.sfFile.name);#endif  }/*************************************************//* DoLoadOrBatchSelection: Handle Load Selection *//*  and Batch Selection commands.                *//*************************************************/void DoLoadOrBatchSelection(myText,whichOne)  TEHandle myText;  int whichOne;  {   Handle sel_hnd;   char *sel_ptr, *str;   long int selectionLength, i;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*===============================================*/   /* Get the length of the selection to be loaded. */   /*===============================================*/   selectionLength = (**myText).selEnd - (**myText).selStart;   /*==============================================*/   /* Selected text should not be larger than 32K. */   /*==============================================*/   if (selectionLength != (int) selectionLength)     {      SysBeep(10);      HUnlock( (Handle) myText);      return;     }   /*========================================*/   /* If no text is selected, simply return. */   /*========================================*/   if (selectionLength <= 0)     {      HUnlock( (Handle) myText);      return;     }   /*=====================================================*/   /* Get the text handle of the edit record and lock it. */   /*=====================================================*/   sel_hnd = (**myText).hText;   HLock(sel_hnd);   /*=======================================================*/   /* Get a pointer to the beginning of the text selection. */   /*=======================================================*/   sel_ptr = *sel_hnd;   sel_ptr = &sel_ptr[(**myText).selStart];   /*======================================================*/   /* Allocate enough memory to copy the string. If memory */   /* cannot be allocated, then return.                    */   /*======================================================*/   str = (char *) NewPtr(selectionLength + 1);   if (str == NULL)     {      HUnlock(sel_hnd);      HUnlock( (Handle) myText);      ParamText("\pUnable to allocate enough memory to load/batch selection",                   "\p","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      return;     }   /*==========================*/   /* Copy the selection text. */   /*==========================*/   for (i = 0 ; i < selectionLength ; i++)     { str[i] = sel_ptr[i]; }   str[i] = '\0';   /*=========================================*/   /* Unlock text handle and the edit record. */   /*=========================================*/   HUnlock(sel_hnd);   HUnlock( (Handle) myText);   /*===================================*/   /* Send the appropriate Apple Event. */   /*===================================*/#if (! BLOAD_ONLY) && (! RUN_TIME)   if (whichOne == LOAD_SELECTION)     { SendAESingleArgumentTextCommand(str,'CMPL'); }   else#endif   if (whichOne == BATCH_SELECTION)     { SendAESingleArgumentTextCommand(str,'BTCH'); }   /*=======================================*/   /* Return the copy of the text selection */   /* to the pool of free memory.           */   /*=======================================*/      DisposePtr(str);  }/*********************************************//* DoLoadBuffer: Handle Load Buffer command. *//*********************************************/void DoLoadBuffer(myText)  TEHandle myText;  {   int old_start, old_end;   /*=========================*/   /* Save the old selection. */   /*=========================*/   old_start = (**myText).selStart;   old_end = (**myText).selEnd;   /*=============================*/   /* Select the entire document. */   /*=============================*/   TESetSelect(0,(**myText).teLength,myText);   /*=====================*/   /* Compile the buffer. */   /*=====================*/   DoLoadOrBatchSelection(myText,LOAD_SELECTION);   /*============================*/   /* Restore the old selection. */   /*============================*/   TESetSelect(old_start,old_end,myText);  }/*******************************************//* DoDribble: Handles the Dribble command. *//*******************************************/void DoDribble()  {   /*===============================================*/   /* If a dribble file is active, then perform the */   /* Dribble Off command. Otherwise perform the    */   /* Dribble On... command.                        */   /*===============================================*/#if DEBUGGING_FUNCTIONS   if (DribbleActive())     { DoCloseDribble(); }   else     { DoOpenDribble(); }#endif  }/************************************************//* DoOpenDribble: Handle Dribble On... command. *//************************************************/void DoOpenDribble()  {   StandardFileReply theReply;   Str255 theTitle = "\pdribble.txt";   char *commandPrefix, *commandPostfix = "\")\n", *theString;      /*====================*/   /* Get the file name. */   /*====================*/   StandardPutFile("\pSave Dialog Output As",theTitle,&theReply);   /*=====================================*/   /* Exit if file request was cancelled. */   /*=====================================*/   if (theReply.sfGood == false) return;      /*===================================================*/   /* Send an AppleEvent to reset the current volume so */   /* that the UNIX fopen function will find the file.  */   /*===================================================*/   SendSetWorkingDirectoryCommand(&theReply.sfFile);    /*===========================================================*/   /* Construct the bsave command string and send an AppleEvent */   /* to execute the command at the command prompt.             */   /*===========================================================*/#if DEBUGGING_FUNCTIONS#if ! RUN_TIME   if (EvaluatingTopLevelCommand || BatchActive())     {      PTOCSTR((PSTRCAST) theReply.sfFile.name);      DribbleOn((char *) theReply.sfFile.name);      CTOPSTR((char *) theReply.sfFile.name);     }   else     {      commandPrefix = "(dribble-on \"";      PTOCSTR((PSTRCAST) theReply.sfFile.name);      theString = NewPtr(strlen(commandPrefix) +                          strlen((char *) theReply.sfFile.name) +                         strlen(commandPostfix) + 1);      theString[0] = 0;      strcat(theString,commandPrefix);      strcat(theString,(char *) theReply.sfFile.name);       strcat(theString,commandPostfix);                        SendAEPromptCommand(theString,'DOSC');                     DisposePtr(theString);      CTOPSTR((char *) theReply.sfFile.name);     }#else   PTOCSTR((PSTRCAST) theReply.sfFile.name);   DribbleOn((char *) theReply.sfFile.name);   CTOPSTR((char *) theReply.sfFile.name);#endif#endif  }/***********************************************//* DoCloseDribble: Handle Dribble Off command. *//***********************************************/void DoCloseDribble()  {#if DEBUGGING_FUNCTIONS#if ! RUN_TIME   if (EvaluatingTopLevelCommand || BatchActive())     { DribbleOff(); }   else     { SendAEPromptCommand("(dribble-off)\n",'DOSC'); }#else   DribbleOff();#endif#endif  }  /*******************************************************//* DoModuleChoice: Handle choice from the Module menu. *//*******************************************************/void DoModuleChoice(item)  int item;  {   Str255 moduleName;      GetItem(ModuleMenu,item,moduleName);   PTOCSTR((PSTRCAST) moduleName);   SetCurrentModule((VOID *) FindDefmodule((char *) moduleName));  }  /*******************************************************//* DoBrowseChoice: Handle choice from the Browse menu. *//*******************************************************/void DoBrowseChoice(item)  int item;  {   switch (item)     {            /*=====================================*/      /* Handle the Rule Manager... command. */      /*=====================================*/      case DefruleManagerItem:#if DEFRULE_CONSTRUCT        DoDefruleManager();#endif        break;      /*=========================================*/      /* Handle the Deffacts Manager... command. */      /*=========================================*/      case DeffactsManagerItem:#if DEFFACTS_CONSTRUCT        DoDeffactsManager();#endif        break;      /*============================================*/      /* Handle the Deftemplate Manager... command. */      /*============================================*/      case DeftemplateManagerItem:#if DEFTEMPLATE_CONSTRUCT        DoDeftemplateManager();#endif        break;      /*============================================*/      /* Handle the Deffunction Manager... command. */      /*============================================*/      case DeffunctionManagerItem:#if DEFFUNCTION_CONSTRUCT        DoDeffunctionManager();#endif        break;              /*==========================================*/      /* Handle the Defglobal Manager... command. */      /*==========================================*/      case DefglobalManagerItem:#if DEFGLOBAL_CONSTRUCT        DoDefglobalManager();#endif        break;      /*=============================================*/      /* Handle the Definstances Manager... command. */      /*=============================================*/      case DefinstancesManagerItem:#if DEFINSTANCES_CONSTRUCT        DoDefinstancesManager();#endif        break;      /*=========================================*/      /* Handle the Defclass Manager... command. */      /*=========================================*/      case DefclassManagerItem:#if OBJECT_SYSTEM        DoDefclassManager();#endif        break;      /*===========================================*/      /* Handle the Defgeneric Manager... command. */      /*===========================================*/      case DefgenericManagerItem:#if DEFGENERIC_CONSTRUCT        DoDefgenericManager();#endif        break;      /*=======================================*/      /* Handle the Agenda Manager... command. */      /*=======================================*/      case AgendaManagerItem:#if DEFRULE_CONSTRUCT        DoAgendaManager();#endif        break;      default:        break;     }  }/*******************************************************//* DoWindowChoice: Handle choice from the Window menu. *//*******************************************************/void DoWindowChoice(item)  int item;  {   switch (item)     {      /*===================================================*/      /* Handle the Display Window command. If the display */      /* window  is inactive, then activate it.            */      /*===================================================*/      case DisplayWindowItem:        SelectDisplayWindow();        break;      /*======================================================*/      /* Handle the Facts Window command. If the facts window */      /* is inactive, then activate it. If the facts window   */      /* is active, then select it.                           */      /*======================================================*/#if DEFTEMPLATE_CONSTRUCT      case FactsWindowItem:        if (FactsWindow == NULL) InitializeFactsWindow();        else SelectFactsWindow();        break;#endif      /*========================================================*/      /* Handle the Agenda Window command. If the agenda window */      /* is inactive, then activate it. If the agenda window is */      /* active, then select it.                                */      /*========================================================*/      case AgendaWindowItem:        if (AgendaWindow == NULL) InitializeAgendaWindow();        else SelectAgendaWindow();        break;      /*========================================================*/      /* Handle the Instances Window command. If the instances  */      /* window is inactive, then activate it. If the instances */      /* window is active, then select it.                      */      /*========================================================*/      case InstancesWindowItem:        if (InstancesWindow == NULL)  InitializeInstancesWindow();        else SelectInstancesWindow();        break;      /*========================================================*/      /* Handle the Instances Window command. If the instances  */      /* window is inactive, then activate it. If the instances */      /* window is active, then select it.                      */      /*========================================================*/      case GlobalsWindowItem:        if (GlobalsWindow == NULL)  InitializeGlobalsWindow();        else SelectGlobalsWindow();        break;              /*=======================================================*/      /* Handle the Focus Window command. If the focus window  */      /* is inactive, then activate it. If the focus window is */      /* active, then select it.                               */      /*=======================================================*/      case FocusWindowItem:        if (FocusWindow == NULL) InitializeFocusWindow();        else SelectFocusWindow();        break;      /*=================================*/      /* Open all of the status windows. */      /*=================================*/      case AllAboveItem:#if DEFTEMPLATE_CONSTRUCT        if (FactsWindow == NULL) InitializeFactsWindow();        else SelectFactsWindow();        HandlePeriodicEvents();#endif#if DEFRULE_CONSTRUCT        if (AgendaWindow == NULL)  InitializeAgendaWindow();        else SelectAgendaWindow();        HandlePeriodicEvents();#endif#if OBJECT_SYSTEM        if (InstancesWindow == NULL)  InitializeInstancesWindow();        else SelectInstancesWindow();        HandlePeriodicEvents();#endif#if DEFGLOBAL_CONSTRUCT        if (GlobalsWindow == NULL)  InitializeGlobalsWindow();        else SelectGlobalsWindow();        HandlePeriodicEvents();#endif#if DEFRULE_CONSTRUCT        if (FocusWindow == NULL)  InitializeFocusWindow();        else SelectFocusWindow();        HandlePeriodicEvents();#endif        SelectDisplayWindow();        break;      default:        SelectWindowFromMenu(item);        break;     }  }/*******************************************************//* DoExecution: Handle choice from the Execution menu. *//*******************************************************/void DoExecutionChoice(item)  int item;  {   char itemString[257];      switch (item)     {      case Command1Item:      case Command2Item:      case Command3Item:      case Command4Item:      case Command5Item:      case Command6Item:      case Command7Item:      case Command8Item:      case Command9Item:      case Command0Item:        GetItem(CommandsMenu,item,(unsigned char *) itemString);                PTOCSTR((unsigned char *) itemString);        strcat(itemString,"\n");                if (! CompleteCommand(itemString))          { itemString[strlen(itemString) - 1] = 0; }                  SendAEPromptCommand(itemString,'DOSC');        break;              /*====================================*/      /* Handle the SetCommands... command. */      /*====================================*/      case SetCommandsItem:        DoSetCommandsDialog();        break;              /*==============================*/      /* Handle the Watch... command. */      /*==============================*/      case WatchItem:        DoWatchDialog();        break;      /*==============================*/      /* Handle the Options... command. */      /*==============================*/      case OptionsItem:        DoOptionsDialog();        break;      default:        break;     }  }/*********************************************************//* OKCancelAlertDialog: Performs OK/Cancel Alert Dialog. *//*********************************************************/int OKCancelAlertDialog(s)  StringPtr s;  {   int ov;   ov = GetUpdateCursorFlag();   SetUpdateCursorFlag(false);   ParamText(s,"\p","\p","\p");   InitCursor();   if (Alert(OKCancelAlertID,(ModalPtr) DefaultDialogFilterRef) == 1)     {      SetUpdateCursorFlag(ov);      return(1);     }   SetUpdateCursorFlag(ov);   return(0);  }/********************************************//* OKAlertDialog: Performs OK Alert Dialog. *//********************************************/int OKAlertDialog(s)  StringPtr s;  {   ParamText(s,"\p","\p","\p");   return(Alert(OKAlertID,(ModalPtr) DefaultDialogFilterRef) );  }/*************************************************//* LowerString: Converts a string to lower case. *//*************************************************/static void LowerString(str)  char *str;  {   int index;   for (index = 0 ; str[index] != '\0'; index++)     if (isupper(str[index])) str[index] = tolower(str[index]);  }/****************************************************************//* DoCommandCompletion:                                  *//****************************************************************/void DoCommandCompletion(whichWindow)  WindowPtr whichWindow;  {   char *buffer, *strPtr, *partialCompleteStr;   int numberOfMatches;   struct symbolMatch *matches;   int length;   WDHandle theData;   Handle dataHandle;   TEHandle myText;   EWDHandle theEditData;   Handle textHandle;   char *textPtr;   int i,commonPrefixLength = 0, partialCompleteSz;   /*================================*/   /* Get the string for completion. */   /*================================*/   if (whichWindow == NULL)     {      SysBeep(10);      return;     }   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   if ((*theData)->windowType == DISPLAY_WINDOW)    {#if ! RUN_TIME     buffer = GetCommandString();     if (buffer != NULL)       {        length = strlen(buffer);        buffer = GetCommandCompletionString(buffer,length);       }#endif    }   else if ((*theData)->windowType == EDIT_WINDOW)    {     theEditData = (EWDHandle) theData;     myText = (**theEditData).editRec;     textHandle = (**myText).hText;     HLock(textHandle);     textPtr = *textHandle;     i = 0;     while ((i < (**myText).nLines) ?            ((**myText).lineStarts[i] <= (**myText).selEnd) : false)       { i++; }     if ((**myText).selStart == (**myText).selEnd)       {        buffer = &textPtr[(**myText).lineStarts[i - 1]];        length = (**myText).selEnd - (**myText).lineStarts[i - 1];       }     else if ((**myText).lineStarts[i - 1] < (**myText).selStart)       {        buffer = &textPtr[(**myText).selStart];        length = (**myText).selEnd - (**myText).selStart;       }     else       {        buffer = &textPtr[(**myText).lineStarts[i - 1]];        length = (**myText).selEnd - (**myText).lineStarts[i - 1];       }     buffer = GetCommandCompletionString(buffer,length);     HUnlock(textHandle);    }   else    { buffer = NULL; }   if (buffer == NULL)     {      SysBeep(10);      return;     }   /*======================================*/   /* Determine the number of completions. */   /*======================================*/      matches = FindSymbolMatches(buffer,&numberOfMatches,                               CommandCompletionDialog ? NULL : &commonPrefixLength);   if (numberOfMatches == 0) SysBeep(10);   else if (numberOfMatches == 1)     {      length = strlen(buffer);      if ((*theData)->windowType == DISPLAY_WINDOW)        {#if ! RUN_TIME         AppendCommandString(&(matches->match->contents[length]));         PrintCLIPS("stdout",&(matches->match->contents[length]));#endif        }      else if ((*theData)->windowType == EDIT_WINDOW)        {         TESetSelect((long int) (**myText).selEnd,(long int) (**myText).selEnd,myText);         i = length;         while (matches->match->contents[i] != '\0')           {            DoEditTyping(whichWindow,matches->match->contents[i],0);            i++;           }        }     }   else if (CommandCompletionDialog ? FALSE :           ((length = strlen(buffer)) < commonPrefixLength))     {      partialCompleteSz = (int) (sizeof(char) * (commonPrefixLength - length + 1));      partialCompleteStr = (char *) NewPtr(partialCompleteSz);      strncpy(partialCompleteStr,&(matches->match->contents[length]),              commonPrefixLength-length);      partialCompleteStr[partialCompleteSz - 1] = '\0';      if ((*theData)->windowType == DISPLAY_WINDOW)        {#if ! RUN_TIME         AppendCommandString(partialCompleteStr);         PrintCLIPS("stdout",partialCompleteStr);#endif        }      else if ((*theData)->windowType == EDIT_WINDOW)        {         TESetSelect((long int) (**myText).selEnd,(long int) (**myText).selEnd,myText);         i = 0;         while (partialCompleteStr[i] != '\0')           {            DoEditTyping(whichWindow,partialCompleteStr[i],0);            i++;           }        }      DisposePtr(partialCompleteStr);      SysBeep(10);     }   else     {      strPtr = DoCommandCompletionDialog(matches,buffer);      if (strPtr != NULL)        {         length = strlen(buffer);         if ((*theData)->windowType == DISPLAY_WINDOW)           {#if ! RUN_TIME            AppendCommandString(&(strPtr[length]));            PrintCLIPS("stdout",&(strPtr[length]));#endif           }         else if ((*theData)->windowType == EDIT_WINDOW)           {            TESetSelect((long int) (**myText).selEnd,(long int) (**myText).selEnd,myText);            i = length;            while (strPtr[i] != '\0')              {               DoEditTyping(whichWindow,strPtr[i],0);               i++;              }           }        }     }   ReturnSymbolMatches(matches);  }