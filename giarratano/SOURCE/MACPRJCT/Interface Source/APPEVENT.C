   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  09/15/96          */   /*                                                     */   /*                 APPLE EVENTS MODULE                 */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _APPEVENT_SOURCE_#include "setup.h"#include <Aliases.h>#include <Types.h>#if THINK_C /* Defined by the Think C Environment */#include <pascal.h>#else#include <strings.h>#endif#if MAC_SC7#define PTOCSTR P2CStr#define CTOPSTR C2PStr#else#define PTOCSTR p2cstr#define CTOPSTR c2pstr#endif#define PSTRCAST StringPtr#include <string.h>#include "commline.h"#include "constant.h"#include "cstrcpsr.h"#include "filecom.h"#include "filemenu.h"#include "mainloop.h"#include "clipsmem.h"#include "print.h"#include "router.h"#include "strngrtr.h"#include "displayw.h"#include "appevent.h"/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static OSErr                   GetRequiredParameters(AppleEvent *);   /****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/#if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor              DoOpenDocumentsHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoOpenDocumentsHighLevelEvent);         RoutineDescriptor              DoPrintDocumentsHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoPrintDocumentsHighLevelEvent);   RoutineDescriptor              DoQuitApplicationHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoQuitApplicationHighLevelEvent);         RoutineDescriptor              DoOpenApplicationHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoOpenApplicationHighLevelEvent);   RoutineDescriptor              DoCommandPromptHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoCommandPromptHighLevelEvent);   RoutineDescriptor              DoCompileTextHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoCompileTextHighLevelEvent);   RoutineDescriptor              DoBatchTextHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoBatchTextHighLevelEvent);   RoutineDescriptor              DoSetWorkingDirectoryHighLevelEventRD       = BUILD_ROUTINE_DESCRIPTOR(uppAEEventHandlerProcInfo,DoSetWorkingDirectoryHighLevelEvent);#endif /***********************************************************//* DoOpenDocumentsHighLevelEvent: Handle open apple event. *//***********************************************************/pascal OSErr DoOpenDocumentsHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr myErr;   AEDescList docList;   long int index, itemsInList;   AEKeyword keyWord;   Size actualSize;   FSSpec myFSS;   FInfo finderInfo;   DescType returnedType;   short int wdRefNum;      /*========================================*/   /* Get the direct parameter, a descriptor */   /* list, and put it into docList.         */   /*========================================*/      myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&docList);   if (myErr != noErr)      {      SysBeep(10);      return(myErr);     }        /*========================================*/   /* Check for missing required parameters. */   /*========================================*/      myErr = GetRequiredParameters(theAppleEvent);   if (myErr != noErr)      {      SysBeep(10);      return(myErr);     }        /*=====================================================*/   /* Count the number of descriptor records in the list. */   /*=====================================================*/      AECountItems(&docList,&itemsInList);        /*==================================================*/   /* Get each descriptor record from the list, coerce */   /* the returned data to an FSSpec record, and open  */   /* the associated file.                             */   /*==================================================*/      for (index = 1L; index <= itemsInList; index++)     {      myErr = AEGetNthPtr(&docList,index,typeFSS,&keyWord,&returnedType,                          &myFSS,sizeof(myFSS),&actualSize);                        if (myErr != noErr)        {         SysBeep(10);         return(myErr);        }      myErr = FSpGetFInfo(&myFSS,&finderInfo);            if (myErr != noErr)        {         SysBeep(10);         return(myErr);        }               if (finderInfo.fdType == 'TEXT')        { DoOpenFile(&myFSS,finderInfo.fdType); }      else if (finderInfo.fdType == 'BTCH')        {         OpenWD(myFSS.vRefNum,myFSS.parID,CREATOR_CODE,&wdRefNum);         SetVol(NULL,wdRefNum);         PTOCSTR((PSTRCAST) myFSS.name);         OpenBatch((char *) myFSS.name,TRUE);         CTOPSTR((char *) myFSS.name);         CloseWD(wdRefNum);        }     }        /*=================================*/   /* Dispose of the descriptor list. */   /*=================================*/      AEDisposeDesc(&docList);      /*=================================================*/   /* Return noErr to indicate successful completion. */   /*=================================================*/      return(noErr);  }  /*************************************************************//* DoPrintDocumentsHighLevelEvent: Handle print apple event. *//*************************************************************/pascal OSErr DoPrintDocumentsHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr myErr;   AEDescList docList;   long int index, itemsInList;   AEKeyword keyWord;   Size actualSize;   FSSpec myFSS;   FInfo finderInfo;   DescType returnedType;   WindowPtr theWindow;      /*========================================*/   /* Get the direct parameter, a descriptor */   /* list, and put it into docList.         */   /*========================================*/      myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,typeAEList,&docList);   if (myErr != noErr)      {      SysBeep(10);      return(myErr);     }        /*========================================*/   /* Check for missing required parameters. */   /*========================================*/      myErr = GetRequiredParameters(theAppleEvent);   if (myErr != noErr)      {      SysBeep(10);      return(myErr);     }        /*=====================================================*/   /* Count the number of descriptor records in the list. */   /*=====================================================*/      AECountItems(&docList,&itemsInList);        /*==================================================*/   /* Get each descriptor record from the list, coerce */   /* the returned data to an FSSpec record, and open  */   /* the associated file.                             */   /*==================================================*/      for (index = 1L; index <= itemsInList; index++)     {      myErr = AEGetNthPtr(&docList,index,typeFSS,&keyWord,&returnedType,                          &myFSS,sizeof(myFSS),&actualSize);      if (myErr != noErr)        {         SysBeep(10);         return(myErr);        }      myErr = FSpGetFInfo(&myFSS,&finderInfo);            if (myErr != noErr)        {         SysBeep(10);         return(myErr);        }               if ((finderInfo.fdType == 'TEXT') ||          (finderInfo.fdType == 'BTCH'))        {          theWindow = DoOpenFile(&myFSS,finderInfo.fdType);         if (theWindow != NULL)           {            DoPrint(theWindow);            CloseTextWindow(theWindow);           }        }     }        /*=================================*/   /* Dispose of the descriptor list. */   /*=================================*/      AEDisposeDesc(&docList);      /*=================================================*/   /* Return noErr to indicate successful completion. */   /*=================================================*/      return(noErr);  }  /*************************************************************//* DoQuitApplicationHighLevelEvent: Handle quit apple event. *//*************************************************************/pascal OSErr DoQuitApplicationHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   Quitting = TRUE;   return(noErr);  }  /************************************************//* DoOpenApplicationHighLevelEvent: Handle open *//*   application apple event.                   *//************************************************/pascal short DoOpenApplicationHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   return(noErr);  }/********************************************************************//* GetRequiredParameters: Checks for a missedKeywordAttr attribute. *//********************************************************************/static OSErr GetRequiredParameters(theAppleEvent)  AppleEvent *theAppleEvent;  {   DescType returnedType;   Size actualSize;   OSErr myErr;      myErr = AEGetAttributePtr(theAppleEvent,keyMissedKeywordAttr,typeWildCard,                             &returnedType,NULL,0,&actualSize);                                if (myErr == errAEDescNotFound) return(noErr);   else if (myErr == noErr) return(errAEEventNotHandled);      return(myErr);  }/******************************************//* DoCommandPromptHighLevelEvent: Handles *//*   a command prompt apple event.        *//******************************************/pascal OSErr DoCommandPromptHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr myErr;   AEDesc theCommand;      long length;   char *theString;      myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,                          typeChar,&theCommand);   if (myErr != noErr) return(myErr);   HLock(theCommand.dataHandle);      length = GetHandleSize(theCommand.dataHandle);      theString = *theCommand.dataHandle;   if (theString[length-1] == '\0') length--;      PrintNCLIPS("stdout",theString,length);   SetNCommandString(theString,length);              HUnlock(theCommand.dataHandle);      AEDisposeDesc(&theCommand);						 							        return(noErr);  }/******************************************************//* SendAEPromptCommand: Creates an AppleEvent message *//*   for a do script event which indicates that the   *//*   specified text string should be entered at the   *//*   command prompt.                                  *//******************************************************/void SendAEPromptCommand(  char *theCommand,  long commandType)  {    AppleEvent theAppleEvent;   AppleEvent theReply;   OSErr myErr;   AEDesc theTarget;   char *theSignature = CREATOR_STRING;        /*================================================*/   /* Create an address descriptor so the AppleEvent */   /* manager knows where to send this event.        */   /*================================================*/   myErr = AECreateDesc(typeApplSignature,theSignature,                         sizeof(ProcessSerialNumber),&theTarget);   if (myErr) return;      /*=======================*/   /* Create an AppleEvent. */   /*=======================*/      myErr = AECreateAppleEvent('CLIS',                                               commandType,      /* 'DOSC' */                                             &theTarget,                                           kAutoGenerateReturnID,                                kAnyTransactionID,                                    &theAppleEvent);          if (myErr)      {      AEDisposeDesc(&theTarget);      return;     }   /*===========================*/   /* Add the string parameter. */   /*===========================*/      myErr = AEPutParamPtr(&theAppleEvent, keyDirectObject,                           typeChar,theCommand,                          strlen(theCommand) + 1);                                if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }      /*========================================*/   /* Create a descriptor for the parameter. */   /*========================================*/      /* Don't know if one is actually needed. */   /*======================*/   /* Send the AppleEvent. */   /*======================*/      myErr = AESend(&theAppleEvent,                   &theReply,                   kAENoReply + kAENeverInteract,                   kAENormalPriority,                    kAEDefaultTimeout,                   NULL,                   NULL);   if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }	   /*============================*/   /* Deallocate the AppleEvent. */   /*============================*/      AEDisposeDesc(&theAppleEvent);  }/*************************************************//* SendAEOpenCommand: Creates an open AppleEvent *//*   and sends it to the application.            *//*************************************************/void SendAEOpenCommand(  FSSpec *theFSSpec)  {      AppleEvent theAppleEvent;   AppleEvent theReply;   OSErr myErr;   AEDesc theTarget;   AEDescList theList;   AEDesc docDesc;   char *theSignature = CREATOR_STRING;   AliasHandle fileAlias;      /*================================================*/   /* Create an address descriptor so the AppleEvent */   /* manager knows where to send this event.        */   /*================================================*/   myErr = AECreateDesc(typeApplSignature,theSignature,                         sizeof(ProcessSerialNumber),&theTarget);   if (myErr) return;      /*=======================*/   /* Create an AppleEvent. */   /*=======================*/      myErr = AECreateAppleEvent(kCoreEventClass,                                               kAEOpenDocuments,                                                 &theTarget,                                           kAutoGenerateReturnID,                                kAnyTransactionID,                                    &theAppleEvent);          if (myErr)      {      AEDisposeDesc(&theTarget);      return;     }       /*==================================================*/   /* Create a list for the alaises. For this function */   /* there is only one, but a list is still needed.   */   /*==================================================*/   myErr = AECreateList(NULL,0,false,&theList);   if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      return;     }         /*=======================================================*/   /* Create an alias out of the file spec. Original author */   /* was not sure why he did this since there is a system  */   /* coercion handler for alias to FSSpec.                 */   /*=======================================================*/      myErr = NewAlias(NULL,theFSSpec,&fileAlias);   if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      AEDisposeDesc(&theList);      return;     }       /*=============================*/   /* Create an alias descriptor. */   /*=============================*/   HLock((Handle) fileAlias);      myErr = AECreateDesc(typeAlias, (Ptr) *fileAlias,                         GetHandleSize((Handle) fileAlias),                        &docDesc);   HUnlock((Handle) fileAlias);      if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      AEDisposeDesc(&theList);      DisposHandle((Handle) fileAlias);      return;     }    /*============================*/   /* Put the alias in the list. */   /*============================*/      AEPutDesc(&theList,0,&docDesc);   AEPutParamDesc(&theAppleEvent,keyDirectObject,&theList);      /*======================*/   /* Send the AppleEvent. */   /*======================*/      myErr = AESend(&theAppleEvent,                   &theReply,                   kAENoReply + kAENeverInteract,                   kAENormalPriority,                    kAEDefaultTimeout,                   NULL,                   NULL);	   /*=======================================*/   /* Deallocate the AppleEvent structures. */   /*=======================================*/      myErr = AEDisposeDesc(&theTarget);   myErr = AEDisposeDesc(&theAppleEvent);   myErr = AEDisposeDesc(&theList);   DisposHandle((Handle) fileAlias);   myErr = AEDisposeDesc(&docDesc);  }                                                        /************************************************//* SendAELoadCommand: Creates a load AppleEvent *//*   and sends it to the application.           *//************************************************/void SendAELoadCommand(  FSSpec *theFSSpec)  {      AppleEvent theAppleEvent;   AppleEvent theReply;   OSErr myErr;   AEDesc theTarget;   AEDescList theList;   AEDesc docDesc;   char *theSignature = CREATOR_STRING;   AliasHandle fileAlias;      /*================================================*/   /* Create an address descriptor so the AppleEvent */   /* manager knows where to send this event.        */   /*================================================*/   myErr = AECreateDesc(typeApplSignature,theSignature,                         sizeof(ProcessSerialNumber),&theTarget);   if (myErr) return;      /*=======================*/   /* Create an AppleEvent. */   /*=======================*/      myErr = AECreateAppleEvent('CLIS',                                               'LOAD',                                                 &theTarget,                                           kAutoGenerateReturnID,                                kAnyTransactionID,                                    &theAppleEvent);          if (myErr)      {      AEDisposeDesc(&theTarget);      return;     }       /*==================================================*/   /* Create a list for the alaises. For this function */   /* there is only one, but a list is still needed.   */   /*==================================================*/   myErr = AECreateList(NULL,0,false,&theList);   if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      return;     }         /*=======================================================*/   /* Create an alias out of the file spec. Original author */   /* was not sure why he did this since there is a system  */   /* coercion handler for alias to FSSpec.                 */   /*=======================================================*/      myErr = NewAlias(NULL,theFSSpec,&fileAlias);   if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      AEDisposeDesc(&theList);      return;     }       /*=============================*/   /* Create an alias descriptor. */   /*=============================*/   HLock((Handle) fileAlias);      myErr = AECreateDesc(typeAlias, (Ptr) *fileAlias,                         GetHandleSize((Handle) fileAlias),                        &docDesc);   HUnlock((Handle) fileAlias);      if (myErr)      {      AEDisposeDesc(&theTarget);      AEDisposeDesc(&theAppleEvent);      AEDisposeDesc(&theList);      DisposHandle((Handle) fileAlias);      return;     }    /*============================*/   /* Put the alias in the list. */   /*============================*/      AEPutDesc(&theList,0,&docDesc);   AEPutParamDesc(&theAppleEvent,keyDirectObject,&theList);      /*======================*/   /* Send the AppleEvent. */   /*======================*/      myErr = AESend(&theAppleEvent,                   &theReply,                   kAENoReply + kAENeverInteract,                   kAENormalPriority,                    kAEDefaultTimeout,                   NULL,                   NULL);	   /*=======================================*/   /* Deallocate the AppleEvent structures. */   /*=======================================*/      myErr = AEDisposeDesc(&theTarget);   myErr = AEDisposeDesc(&theAppleEvent);   myErr = AEDisposeDesc(&theList);   DisposHandle((Handle) fileAlias);   myErr = AEDisposeDesc(&docDesc);  } /**********************************************************//* SendAESingleArgumentTextCommand: Creates an AppleEvent *//*   message for an apple event which accepts as input a  *//*   single string argument.                              *//**********************************************************/void SendAESingleArgumentTextCommand(  char *theText,  long commandType)  {    AppleEvent theAppleEvent;   AppleEvent theReply;   OSErr myErr;   AEDesc theTarget;   char *theSignature = CREATOR_STRING;        /*================================================*/   /* Create an address descriptor so the AppleEvent */   /* manager knows where to send this event.        */   /*================================================*/   myErr = AECreateDesc(typeApplSignature,theSignature,                         sizeof(ProcessSerialNumber),&theTarget);   if (myErr) return;      /*=======================*/   /* Create an AppleEvent. */   /*=======================*/      myErr = AECreateAppleEvent('CLIS',                                               commandType,                                             &theTarget,                                           kAutoGenerateReturnID,                                kAnyTransactionID,                                    &theAppleEvent);          if (myErr)      {      AEDisposeDesc(&theTarget);      return;     }   /*===========================*/   /* Add the string parameter. */   /*===========================*/      myErr = AEPutParamPtr(&theAppleEvent, keyDirectObject,                           typeChar,theText,                          strlen(theText) + 1);                                if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }      /*======================*/   /* Send the AppleEvent. */   /*======================*/      myErr = AESend(&theAppleEvent,                   &theReply,                   kAENoReply + kAENeverInteract,                   kAENormalPriority,                    kAEDefaultTimeout,                   NULL,                   NULL);   if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }	   /*============================*/   /* Deallocate the AppleEvent. */   /*============================*/      AEDisposeDesc(&theAppleEvent);  }/*********************************************************//* SendSetWorkingDirectoryCommand: Creates an AppleEvent *//*   message for the set working directory AppleEvent.   *//*********************************************************/void SendSetWorkingDirectoryCommand(  FSSpec *theFile)  {    AppleEvent theAppleEvent;   AppleEvent theReply;   OSErr myErr;   AEDesc theTarget;   char *theSignature = CREATOR_STRING;        /*================================================*/   /* Create an address descriptor so the AppleEvent */   /* manager knows where to send this event.        */   /*================================================*/   myErr = AECreateDesc(typeApplSignature,theSignature,                         sizeof(ProcessSerialNumber),&theTarget);   if (myErr) return;      /*=======================*/   /* Create an AppleEvent. */   /*=======================*/      myErr = AECreateAppleEvent('CLIS',                                               'SWD=',                                             &theTarget,                                           kAutoGenerateReturnID,                                kAnyTransactionID,                                    &theAppleEvent);          if (myErr)      {      AEDisposeDesc(&theTarget);      return;     }   /*===========================*/   /* Add the FSSpec parameter. */   /*===========================*/      myErr = AEPutParamPtr(&theAppleEvent, keyDirectObject,                           typeFSS,theFile,sizeof(FSSpec));                                if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }      /*======================*/   /* Send the AppleEvent. */   /*======================*/      myErr = AESend(&theAppleEvent,                   &theReply,                   kAENoReply + kAENeverInteract,                   kAENormalPriority,                    kAEDefaultTimeout,                   NULL,                   NULL);   if (myErr)      {      AEDisposeDesc(&theAppleEvent);      return;     }	   /*============================*/   /* Deallocate the AppleEvent. */   /*============================*/      AEDisposeDesc(&theAppleEvent);  }  /****************************************//* DoCompileTextHighLevelEvent: Handles *//*   a compile text apple event.        *//****************************************/pascal OSErr DoCompileTextHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr theErr;   AEDesc theCommand;      long length;   char *theString;   Boolean compileResult;      theErr = AEGetParamDesc(theAppleEvent,keyDirectObject,                          typeChar,&theCommand);   if (theErr != noErr) return(theErr);   HLock(theCommand.dataHandle);      length = GetHandleSize(theCommand.dataHandle);      theString = *theCommand.dataHandle;      SelectDisplayWindow();   ShowDisplayEnd(TRUE);   PrintCLIPS("stdout","Loading Selection...\n");      FlushCommandString();   OpenTextSource("aecompiletext",theString,0,length);   SetPrintWhileLoading(TRUE);   compileResult = LoadConstructsFromLogicalName("aecompiletext");   SetPrintWhileLoading(false);   CloseStringSource("aecompiletext");   PrintCLIPS("stdout",COMMAND_PROMPT);           HUnlock(theCommand.dataHandle);      AEDisposeDesc(&theCommand);		      theErr = AEPutParamPtr(reply,keyDirectObject,typeBoolean,                          &compileResult,sizeof(Boolean));				 							        return(theErr);  }  /**************************************//* DoBatchTextHighLevelEvent: Handles *//*   a batch text apple event.        *//**************************************/pascal OSErr DoBatchTextHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr myErr;   AEDesc theCommand;      long length;   char *theString, *newString;      myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,                          typeChar,&theCommand);   if (myErr != noErr) return(myErr);   HLock(theCommand.dataHandle);      length = GetHandleSize(theCommand.dataHandle);      theString = *theCommand.dataHandle;   if (theString[length-1] == '\0')     {      newString = gm2(length);      strcpy(newString,theString);     }   else     {      newString = gm2(length+1);      newString[length] = '\0';      strncpy(newString,theString,length);     }      SelectDisplayWindow();      OpenStringBatch("aebatchtext",newString,false);         HUnlock(theCommand.dataHandle);      AEDisposeDesc(&theCommand);						 							        return(noErr);  }  /************************************************//* DoSetWorkingDirectoryHighLevelEvent: Handles *//*   a set working directory apple event.       *//************************************************/pascal OSErr DoSetWorkingDirectoryHighLevelEvent(  AppleEvent *theAppleEvent,  AppleEvent *reply,  long handlerRefCon)  {#if MAC_MPW || MAC_MCW#pragma unused(theAppleEvent)#pragma unused(reply)#pragma unused(handlerRefCon)#endif   OSErr myErr;   AEDesc theFile;      FSSpec *theSpec;      myErr = AEGetParamDesc(theAppleEvent,keyDirectObject,                          typeFSS,&theFile);   if (myErr != noErr) return(myErr);   HLock(theFile.dataHandle);         theSpec = (FSSpec *) *theFile.dataHandle;   SetDirectory(theSpec);   HUnlock(theFile.dataHandle);   AEDisposeDesc(&theFile);						 							        return(noErr);  }