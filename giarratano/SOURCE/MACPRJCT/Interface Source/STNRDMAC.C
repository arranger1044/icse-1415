   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*              STANDARD MACINTOSH MODULE              */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _STNRDMAC_SOURCE_#include <stdlib.h>#include <ToolUtils.h>#include <OSUtils.h>#include <Menus.h>#include <Devices.h>#include <Events.h>/* #include <Desk.h> *//* #include <GestaltEqu.h> */#include <Gestalt.h>#include <Folders.h>#include <Errors.h>#include "setup.h"#include "interface.h"#include "window.h"#include "stnrdmac.h"/***************//* Definitions *//***************/#define WNETrapNum       0x60#define UnImplTrapNum    0x9F#define GestaltTrapNum   0xA1AD#define InitGrafTrapNum  0xA86E#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static short                  NumToolboxTraps(void);   static TrapType               GetTrapType(int);   static int                    TrapAvailable(int);   /****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   CursHandle              IBeamCursor;   CursHandle              WatchCursor;   int                     WNEIsImplemented = false;   int                     Suspended = false;   long                    DragManagerPresent = false;   long                    TEHasGetHiliteRgn = false;   long                    TEFeatureFlagPresent = false;   short                   ApplicationVRefNum;   long                    ApplicationDirID;/*********************************//* StandardSetup:                *//*********************************/void StandardSetup()  {   IBeamCursor = GetCursor(iBeamCursor);   WatchCursor = GetCursor(watchCursor);  }/****************************************************************//* GetSystemAttributes: Determines if certain system attributes *//*   are available by using the gestalt function.               *//****************************************************************/Boolean GetSystemAttributes()  {   long theFeature;   Str255 volName;   HGetVol(volName,&ApplicationVRefNum,&ApplicationDirID);      WNEIsImplemented = TrapAvailable(WNETrapNum);         if (! TrapAvailable(GestaltTrapNum))      {      InitCursor();      ParamText("\pCLIPS requires the Gestalt system service ",                "\pwhich is not available","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);       return(false);     }   if (Gestalt(gestaltFindFolderAttr,&theFeature) == noErr)     {      if (! BitTst(&theFeature,31 - (int) gestaltFindFolderPresent))        {         InitCursor();         ParamText("\pCLIPS requires the FindFolder system service ",                   "\pwhich is not available","\p","\p");         StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);          return(false);        }     }        if (Gestalt(gestaltDragMgrAttr,&theFeature) == noErr)     {      DragManagerPresent = BitTst(&theFeature,31 - (int) gestaltDragMgrPresent);     }       if (Gestalt(gestaltTEAttr,&theFeature) == noErr)     {      TEHasGetHiliteRgn = BitTst(&theFeature,31 - (int) gestaltTEHasGetHiliteRgn);     }        if (Gestalt(gestaltTextEditVersion,&theFeature) == noErr)     {      if (theFeature >= gestaltTE4)        { TEFeatureFlagPresent = TRUE; }     }/*gestaltAppleEventsAttrgestaltStandardFileAttr*/        return(true);  }/********************************************************************//* GetSystemFolder: Returns the volume reference number and the     *//*   directory ID of the System folder. Both values are returned in *//*   the calling arguments provided and the value TRUE is returned  *//*   if the folder was found, otherwise false is returned.          *//********************************************************************/int GetSystemFolder(  short *theVRefNum,  long *theDirID)  {   if (FindFolder(kOnSystemDisk,kSystemFolderType,kDontCreateFolder,                                theVRefNum,theDirID) == noErr) return(TRUE);   else return(false);  }/**************************************//* GetTheEvent: Grabs the next event. *//**************************************/int GetTheEvent(eventMask,thisEvent)  int eventMask;  EventRecord *thisEvent;  {     int rv;   EventRecord CheckEvent;      if (Suspended)      {      rv = EventAvail(osEvt,&CheckEvent);     }   if (WNEIsImplemented)     { return(WaitNextEvent(eventMask,thisEvent,0L,NULL)); }   else     {      SystemTask();      return(GetNextEvent(eventMask,thisEvent));     }  }/***********************************************************************//* NumToolboxTraps: Checks the size of the trap dispatch table. Relies *//*   on the fact that the InitGraf trap (trap number $A86E) is always  *//*   implemented. If the trap dispatch table is large enough (that is, *//*   has more than $200 entries), then $AA6E always points to either   *//*   Unimplemented or something else, but never to InitGraf. As a      *//*   result, you can check the size of the trap dispatch table by      *//*   checking to see if the address of trap $AE6E is that same as      *//*   $AA6E. This function was copied from page 3-8 of Inside           *//*   Macintosh, Volume VI.                                             *//***********************************************************************/static short int NumToolboxTraps()  {   if (NGetTrapAddress(InitGrafTrapNum,ToolTrap) == NGetTrapAddress(0xAA6E,ToolTrap))     { return(0x200); }   else     { return(0x400); }  }/*****************************************************************************//* GetTrapType: Returns the trap type of a trap (either a tool or OS trap.   *//*    This function was copied from page 3-8 of Inside Macintosh, Volume VI. *//*****************************************************************************/static TrapType GetTrapType(theTrap)  int theTrap;  {   if (BitAnd(theTrap,0x0800) > 0) return(ToolTrap);   else return(OSTrap);  }/*************************************************************************//* TrapAvailable: Determines if a given trap is available. This function *//*    was copied from page 3-8 of Inside Macintosh, Volume VI.           *//*************************************************************************/static int TrapAvailable(theTrap)  int theTrap;  {   TrapType tType;   tType = GetTrapType(theTrap);   if (tType == ToolTrap)     {      theTrap = BitAnd(theTrap,0x07FF);      if (theTrap >= NumToolboxTraps()) theTrap = UnImplTrapNum;     }   return ((NGetTrapAddress(theTrap,tType) !=            NGetTrapAddress(UnImplTrapNum,ToolTrap)));  }/**************************************************//* DropLocationIsFinderTrash: Returns TRUE if the *//*   given dropLocation AEDesc is a descriptor of *//*   the Finder's Trash.                          *//**************************************************/Boolean DropLocationIsFinderTrash(  AEDesc *dropLocation)  {   OSErr result;   AEDesc dropSpec;   FSSpec *theSpec;   CInfoPBRec thePB;   short trashVRefNum;   long trashDirID;   /*=====================================================*/   /* Coerce the dropLocation descriptor to an FSSpec. If */   /* there's no dropLocation or it can't be coerced into */   /* an FSSpec, then it couldn't have been the Trash.    */   /*=====================================================*/   if ((dropLocation->descriptorType == typeNull) ||       (AECoerceDesc(dropLocation, typeFSS, &dropSpec) != noErr))     { return(false); }        HLock(dropSpec.dataHandle);   theSpec = (FSSpec *) *dropSpec.dataHandle;   /*=============================*/   /* Get the directory ID of the */   /* given dropLocation object.  */   /*=============================*/   thePB.dirInfo.ioCompletion = 0L;   thePB.dirInfo.ioNamePtr = (StringPtr) &theSpec->name;   thePB.dirInfo.ioVRefNum = theSpec->vRefNum;   thePB.dirInfo.ioFDirIndex = 0;   thePB.dirInfo.ioDrDirID = theSpec->parID;   result = PBGetCatInfo(&thePB, false);   HUnlock(dropSpec.dataHandle);   AEDisposeDesc(&dropSpec);   if (result != noErr)      { return(false); }   /*===================================*/   /* If the result is not a directory, */   /* it must not be the Trash.         */   /*===================================*/		   if (!(thePB.dirInfo.ioFlAttrib & (1 << 4)))     { return(false); }   /*=========================================*/   /* Get information about the Trash folder. */   /*=========================================*/      FindFolder(theSpec->vRefNum,kTrashFolderType,kCreateFolder,               &trashVRefNum,&trashDirID);      /*======================================================*/   /* If the directory ID of the dropLocation object is    */   /* the same as the directory ID returned by FindFolder, */   /* then the drop must have occurred into the Trash.     */   /*======================================================*/   if (thePB.dirInfo.ioDrDirID == trashDirID)     { return(TRUE); }   return(false);  }/*********************************************//* IsTextDragTypeAvailable: Returns TRUE if  *//*   all of the drag items contains a 'TEXT' *//*   type, otherwise FALSE is returned.      *//*********************************************/  Boolean IsTextDragTypeAvailable(  DragReference theDrag)  {    unsigned short items, index;   FlavorFlags theFlags;   ItemReference theItem;   OSErr result;   CountDragItems(theDrag, &items);      for (index = 1; index <= items; index++)     {      GetDragItemReferenceNumber(theDrag, index, &theItem);      result = GetFlavorFlags(theDrag,theItem,'TEXT',&theFlags);      if (result == noErr) continue;      return(false);     }        return(TRUE);  }