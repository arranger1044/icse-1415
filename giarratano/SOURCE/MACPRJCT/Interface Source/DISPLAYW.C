   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*               DISPLAY WINDOW MODULE                 */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _DISPLAYW_SOURCE_#include "setup.h"#include <stdio.h>#define _STDIO_INCLUDED_#include <string.h>#include <OSUtils.h>#include <ToolUtils.h>#include <Devices.h>/* #include <Desk.h> */#include <Scrap.h>#include <Memory.h>#include <Windows.h>#include <Controls.h>#include <Events.h>#include <Menus.h>#include <SegLoad.h>#include <Fonts.h>#define ARROW (qd.arrow)#include "router.h"#include "commline.h"#include "apprsrcs.h"#include "clpscrap.h"#include "dsplscrl.h"#include "dsplio.h"#include "dsplwdrg.h"#include "editdlog.h"#include "interface.h"#include "menuhndl.h"#include "prefernc.h"#include "stnrdmac.h"#include "undo.h"#include "window.h"#include "displayw.h"#if MAC_SC7 || MAC_MCW || MAC_SC8#define ControlProcPtr ControlActionUPP#else#define ControlProcPtr ProcPtr#endif/***************//* DEFINITIONS *//***************/#define LEFT_WINDOW_MARGIN 5#define DisplayWindowID  131/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void             DoDisplayClose(WindowPtr);   static void             DisplayMenuUpdateRoutine(WindowPtr);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static int              DisplayLineDescent;      static int              DisplayActive = 0;   /****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   WindowPtr               DisplayWindow;   ControlHandle           DisplayVScroll;   ControlHandle           DisplayHScroll;   int                     DisplayStartLine;   int                     LinesInUse = 1;   int                     CharacterWidth;   int                     LinesInDisplayWindow;   int                     CursorVisible = false;   int                     SelectionLineStart = 0;   int                     SelectionLineEnd = 0;   int                     SelectionCharStart = 0;   int                     SelectionCharEnd = 0;   int                     DisplayLineHeight;   int                     TopDisplayNumber;   int                     LeftWindowMargin = 0;   int                     LeftMarginNumber;   int                     LinesLost = 0;   struct lineRecord       DisplayText[MAX_DISPLAY_LINES];   int                     ZeroDisplayLine = 0;   int                     AppendDisplayLine = 0;   short                   CursorHideLock = false;/*********************************************************//* CreateDisplayWindow:  Initializes the display window. *//*********************************************************/void CreateDisplayWindow(applicationHookPtr)  int (*applicationHookPtr)(WindowPtr,EventRecord *,THPrint,char,int);  {   WDHandle theData;   Handle dataHandle;   Rect scrollRect;   int height;   FontInfo finfo;   short hsize, vsize, wleft, wtop;   short compileBatchAreaWidth;   /*=============================================================*/   /* Create the display window from the display window template. */   /*=============================================================*/   DisplayWindow = GetNewWindow(DisplayWindowID,(Ptr) NULL,(WindowPtr) -1L);   SetPort(DisplayWindow);   /*========================================================================*/   /* Set the font style to monaco and the font size to 9. Set text transfer */   /* mode so that new text overwrites whatever is on the window.            */   /*========================================================================*/   TextFont(monaco);   TextSize(9);   TextMode(srcCopy);   /*===================================================================*/   /* Size and Place the window in the upper left corner of the screen. */   /*===================================================================*/   if ((HonorEnvironmentWindowState == FALSE) ||       (RecallPositionPreferences(dialogPositionResID,&wtop,&wleft,                                  &vsize,&hsize) == FALSE))     {      hsize = 0.60 * (GetWorkingScreenWidth() - (6 + 6 + 6));      vsize = ((2.0 / 3.0) * (GetWorkingScreenHeight() - (46 + 26 + 26 + 6))) + 26;      wleft = 6;      wtop = 46;     }      SizeWindow(DisplayWindow,hsize,vsize,false);   MoveWindow(DisplayWindow,wleft,wtop,false);   ShowWindow(DisplayWindow);   /*=======================================================*/   /* Create the vertical scroll bar in the display window. */   /*=======================================================*/   scrollRect = (*DisplayWindow).portRect;   scrollRect.left = scrollRect.right-15;   scrollRect.right += 1;   scrollRect.bottom -= 14;   scrollRect.top -= 1;   DisplayVScroll = NewControl(DisplayWindow, &scrollRect, "\p", 1, 0, 0, 0,        scrollBarProc, 0L);   /*=========================================================*/   /* Create the horizontal scroll bar in the display window. */   /*=========================================================*/   compileBatchAreaWidth = ((*CompileAreaBWPic)->picFrame.right -                            (*CompileAreaBWPic)->picFrame.left) +                           ((*BatchAreaBWPic)->picFrame.right -                            (*BatchAreaBWPic)->picFrame.left) - 2;   scrollRect = (*DisplayWindow).portRect;   scrollRect.top = scrollRect.bottom-15;   scrollRect.bottom += 1;   scrollRect.right -= 14;   scrollRect.left += (compileBatchAreaWidth - 1);   DisplayHScroll = NewControl(DisplayWindow, &scrollRect, "\p", 1, 0, 0, 0,        scrollBarProc, 0L);   /*=============================================*/   /* Allocate the window's data record and store */   /* it as the window's reference constant.      */   /*=============================================*/   dataHandle = NewHandle((Size) sizeof(WindowData));   SetWRefCon(DisplayWindow,(long int) dataHandle);   /*=====================================================*/   /* Lock the data record and convert to a typed handle. */   /*=====================================================*/   HLock(dataHandle);   theData = (WDHandle) dataHandle;   /*=================================================*/   /* Store display window values in the data record. */   /*=================================================*/   (**theData).windowType = DISPLAY_WINDOW;   (**theData).growRoutine = GrowDisplayWindow;   (**theData).zoomRoutine = GrowDisplayWindow;   (**theData).contentRoutine = DoDisplayContent;   (**theData).updateRoutine = UpdateDisplayWindow;   (**theData).activateRoutine = DoDisplayActivate;   (**theData).deactivateRoutine = DoDisplayDeactivate;   (**theData).closeRoutine = DoDisplayClose;   (**theData).cursorRoutine = FixDisplayCursor;   (**theData).printRoutine = DisplayPrintRoutine;   (**theData).menuUpdateRoutine = DisplayMenuUpdateRoutine;   (**theData).keystrokeRoutine = DisplayKeystrokeRoutine;   (**theData).vScrollBar = DisplayVScroll;   (**theData).hScrollBar = DisplayHScroll;   (**theData).applicationHook = applicationHookPtr;   /*=======================*/   /* Set up drag and drop. */   /*=======================*/      SetupDisplayWindowDragAndDrop(DisplayWindow);   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*====================================*/   /* Get the window's font information. */   /*====================================*/   GetFontInfo(&finfo);   /*==========================================================*/   /* Determine the location on which to begin the first line, */   /* the height of a line, the amount of space between lines, */   /* the height of the display window, the number of lines    */   /* that can be placed in the window, and the index of the   */   /* line in the display history displayed at the top of the  */   /* window.                                                  */   /*==========================================================*/   DisplayStartLine = finfo.ascent + finfo.leading;   DisplayLineHeight = finfo.ascent + finfo.descent + finfo.leading;   DisplayLineDescent = finfo.descent;   CharacterWidth = finfo.widMax;   LeftWindowMargin = CharacterWidth;   height = (*DisplayWindow).portRect.bottom - ((*DisplayWindow).portRect.top + SCROLL_BAR_WIDTH);   LinesInDisplayWindow = height / DisplayLineHeight;   TopDisplayNumber = 0;   /*=============================*/   /* Draw the window's grow box. */   /*=============================*/   DrawGrowIcon(DisplayWindow);   SelectDisplayWindow();  }/********************************************************************//* UpdateDisplayWindow: Handle update event for the display window. *//********************************************************************/void UpdateDisplayWindow(whichWindow)  WindowPtr whichWindow;  {   int y;   GrafPtr savePort;   RgnHandle theHandle;   Rect viewRect;   int startX;   int x, count;   RgnHandle theRegion;   int cursorHidden = false;   /*========================================================*/   /* Save the old port. Set the port to the display window. */   /*========================================================*/   GetPort(&savePort);   SetPort(whichWindow);   /*=======================*/   /* Reset the scroll bar. */   /*=======================*/   SetDisplayScroll();   ScrollDisplay();      /*=====================================================*/   /* Begin the update of the display window. Temporarily */   /* restricts the visible region of the window by       */   /* intersecting it with the update region.             */   /*=====================================================*/   BeginUpdate(DisplayWindow);   /*================================================*/   /* Erase the visible region of the window. Redraw */   /* the grow box and any window controls.          */   /*================================================*/   EraseRect(&(*DisplayWindow).portRect);   DrawGrowIcon(DisplayWindow);   DrawControls(DisplayWindow);      if (! CursorHideLock)     {       cursorHidden = TRUE;       CursorHideLock = TRUE;     }        CursorVisible = false;   /*====================================*/   /* Draw the Compile/Batch drop areas. */   /*====================================*/   DrawCompileBatchArea(false,false);   /*===============================*/   /* Save the old clipping region. */   /*===============================*/   theHandle = NewRgn();   GetClip(theHandle);   /*=================================================*/   /* Prevent output from spilling into scroll areas. */   /*=================================================*/   viewRect = (*DisplayWindow).portRect;   viewRect.right -= (SCROLL_BAR_WIDTH - 1);   viewRect.bottom = DisplayLineHeight * LinesInDisplayWindow;   ClipRect(&viewRect);      /*===================================================*/   /* Position the pen in the upper left of the window. */   /*===================================================*/   startX = LeftWindowMargin - (GetCtlValue(DisplayHScroll) * CharacterWidth);   y = DisplayStartLine;   MoveTo(startX,y);   /*==========================================*/   /* Print Display information to the window. */   /*==========================================*/   x = (ZeroDisplayLine + TopDisplayNumber) % MAX_DISPLAY_LINES;   count = 0;   while ((x != AppendDisplayLine) && (count <= LinesInDisplayWindow))     {      if (DisplayText[x].insertPoint != 0)        { DrawText(DisplayText[x].lineInfo,0,DisplayText[x].insertPoint); }      y += DisplayLineHeight;      MoveTo(startX,y);      x = (x + 1) % MAX_DISPLAY_LINES;      count++;     }   if (DisplayText[x].insertPoint != 0)     { DrawText(DisplayText[x].lineInfo,0,DisplayText[x].insertPoint); }   if (cursorHidden && CursorShouldBeDrawn())     {       DrawCursor();       CursorVisible = TRUE;      CursorHideLock = false;     }   else if (cursorHidden)     { CursorHideLock = false; }   /*==================================*/   /* Highlight the current selection. */   /*==================================*/   theRegion = DisplaySelectionRegion(DisplayWindow);      if ((DisplayWindow == FrontWindow()) && DisplayActive)     { InvertRgn(theRegion); }   else     { FrameRgn(theRegion); }        DisposeRgn(theRegion);        /*==================================*/   /* Restore the old clipping region. */   /*==================================*/   SetClip(theHandle);   DisposeRgn(theHandle);   /*====================================================*/   /* End the update of the agenda window. This restores */   /* the old visible region of the window.              */   /*====================================================*/   EndUpdate(DisplayWindow);   /*=======================*/   /* Restore the old port. */   /*=======================*/   SetPort(savePort);  }/*****************************************************//* GrowDisplayWindow: Recomputes the number of lines *//*   in the display window. Normally called after    *//*   the display window has been resized.            *//*****************************************************/void GrowDisplayWindow(  WindowPtr whichWindow)  {   int height;   short compileBatchAreaWidth;   compileBatchAreaWidth = ((*CompileAreaBWPic)->picFrame.right -                            (*CompileAreaBWPic)->picFrame.left) +                           ((*BatchAreaBWPic)->picFrame.right -                            (*BatchAreaBWPic)->picFrame.left) - 2;   FixScrollBar(DisplayVScroll,DisplayHScroll,whichWindow,                compileBatchAreaWidth,0,0,0);   height = (*DisplayWindow).portRect.bottom -             ((*DisplayWindow).portRect.top + SCROLL_BAR_WIDTH);   LinesInDisplayWindow = height / DisplayLineHeight;  }/************************************************************************//* SelectDisplayWindow: Makes the display window the front-most window. *//************************************************************************/void SelectDisplayWindow()  {   SelectWindow(DisplayWindow);   HandleWindowEvents();  }/**********************************************************//* ShowDisplayEnd: Sets the display's vertical scroll bar *//*   to its maximum value so that input can be seen.      *//**********************************************************/void ShowDisplayEnd(forceUpdate)  int forceUpdate;  {   SetDisplayScroll();   if (forceUpdate ||       (GetCtlValue(DisplayVScroll) != GetCtlMax(DisplayVScroll)))     {      SetCtlValue(DisplayVScroll,GetCtlMax(DisplayVScroll));      UpdateDisplayWindow(DisplayWindow);     }  }/*************************************************//* ShowDisplayBegin: Sets the display's vertical *//*   bar to its minimum value so that the top of *//*   the scroll dialog window can be seen.       *//*************************************************/void ShowDisplayBegin(forceUpdate)  int forceUpdate;  {   SetDisplayScroll();   if (forceUpdate ||       (GetCtlValue(DisplayVScroll) != GetCtlMin(DisplayVScroll)))     {      SetCtlValue(DisplayVScroll,GetCtlMin(DisplayVScroll));      UpdateDisplayWindow(DisplayWindow);     }  }    /*********************************************************//* DrawCursor: Handles drawing the cursor in the display *//*   window. Drawing is done using xor so if the cursor  *//*   is already visible, then it is erased, otherwise it *//*   is drawn.                                           *//*********************************************************/void DrawCursor()  {   int x, y, savey;   Point savepoint;      /*===================================*/   /* Adjust and save the pen position. */   /*===================================*/   GetPen(&savepoint);   x = savepoint.h - 1;   savey = savepoint.v;   y = savey + (DisplayLineDescent - 1);   MoveTo(x,y);   /*===================================*/   /* Cursor is simply a vertical line. */   /*===================================*/   PenMode(patXor);   LineTo(x, y - (DisplayLineHeight - 1));   MoveTo(x+1, savey);   /*=====================*/   /* Reset the pen mode. */   /*=====================*/   PenMode(patCopy);  }/*****************************************************************//* ClearDisplayWindow: Clears all lines from the display window. *//*****************************************************************/VOID ClearDisplayWindow()  {   int i;   TopDisplayNumber = 0;   LeftMarginNumber = 0;   ZeroDisplayLine = 0;   AppendDisplayLine = 0;   LinesInUse = 1;   LinesLost = 0;   SelectionLineStart = 0;   SelectionLineEnd = 0;   SelectionCharStart = 0;   SelectionCharEnd = 0;   for (i = 0; i < MAX_DISPLAY_LINES; i++)     {      DisplayText[i].lineSize = 0;      DisplayText[i].insertPoint = 0;      if (DisplayText[i].lineInfo != NULL)        {         DisposPtr(DisplayText[i].lineInfo);         DisplayText[i].lineInfo = NULL;        }     }   InvalRect(&DisplayWindow->portRect);   ShowDisplayEnd(TRUE);  }/******************************************************************//* DisplayPaste: Handles the paste command in the display window. *//******************************************************************/void DisplayPaste()  {   Handle textHandle;   char *textPtr;   long int offset, length, i, t;   char pasteBuffer[STANDARD_LINE_LENGTH + 1];      /*===================================================*/   /* Copy the TextEdit scrap to the desk scrap so it   */   /* can be retrieved. since we are using the TextEdit */   /* scrap as our primary scrap.                       */   /*===================================================*/   WriteDeskScrap();   /*=========================================*/   /* Get any TEXT scrap from the desk scrap. */   /*=========================================*/   if ((textHandle = NewHandle((Size) 0)) == NULL) return;   length = GetScrap(textHandle,'TEXT',&offset);   /*======================================*/   /* If there is nothing to paste (mainly */   /* due to an error), then return.       */   /*======================================*/   if (length <= 0)     {      DisposHandle(textHandle);      return;     }   /*===============================================*/   /* Paste the desk scrap into the display window. */   /*===============================================*/   ShowDisplayEnd(TRUE);   HLock(textHandle);   textPtr = *textHandle;   for (i = 0, t = 0; i < length; i++)     {      pasteBuffer[t] = textPtr[i];      if (((t + 1) == STANDARD_LINE_LENGTH) || ((i + 1) == length))        {         pasteBuffer[t+1] = '\0';         PrintCLIPS("stdout",pasteBuffer);#if ! RUN_TIME         AppendCommandString(pasteBuffer);#endif         t = 0;        }      else        { t++; }     }   HUnlock(textHandle);   DisposHandle(textHandle);  }/****************************************************************//* DisplayCopy: Handles the copy command in the display window. *//****************************************************************/void DisplayCopy()  {   char *textPtr;   long int length;   /*==================================*/   /* Get a copy of the selected text. */   /*==================================*/      textPtr = DisplaySelectionText(&length);      if (textPtr == NULL)        {      SysBeep(10);      return;     }      /*================================*/   /* Put the text on the clipboard. */   /*================================*/      ZeroScrap();   PutScrap(length,'TEXT',textPtr);   DisposPtr(textPtr);   /*===================================================*/   /* Copy the desk scrap to the TextEdit scrap so it   */   /* can be retrieved since we are using the TextEdit  */   /* scrap as our primary scrap.                       */   /*===================================================*/   ReadDeskScrap();  }  /***********************************************//* DisplaySelectionText: Returns a copy of the *//*   selected text in the display window.      *//***********************************************/char *DisplaySelectionText(  long *length)  {   struct lineRecord *linePtr;   char *textPtr, *tempPtr;   long tempLength;   int i;   if ((SelectionLineStart == SelectionLineEnd) &&       (SelectionCharStart == SelectionCharEnd))     {      *length = 0;      return(NULL);     }      if (SelectionLineStart == SelectionLineEnd)     {      *length = SelectionCharEnd - SelectionCharStart;      textPtr = NewPtr(*length);                  tempPtr = DisplayText[(ZeroDisplayLine + SelectionLineStart) % MAX_DISPLAY_LINES].lineInfo;      tempPtr = &tempPtr[SelectionCharStart];            strncpy(textPtr,tempPtr,*length);      return(textPtr);     }   /* count the first line. */   linePtr = &DisplayText[(ZeroDisplayLine + SelectionLineStart) % MAX_DISPLAY_LINES];   tempLength = (linePtr->insertPoint - SelectionCharStart) + 1;   /* count the lines in between. */   for (i = SelectionLineStart + 1; i < SelectionLineEnd; i++)     {      linePtr = &DisplayText[(ZeroDisplayLine + i) % MAX_DISPLAY_LINES];      tempLength += linePtr->insertPoint + 1;     }   /* Count characters in the last line of the selection. */   tempLength += SelectionCharEnd;   /* Allocate space. */   textPtr = NewPtr(tempLength);   if (textPtr == NULL)     {      *length = 0;      return(NULL);     }   /* Copy the first line. */   tempLength = 0;   linePtr = &DisplayText[(ZeroDisplayLine + SelectionLineStart) % MAX_DISPLAY_LINES];   strncpy(&textPtr[tempLength],           &(linePtr->lineInfo[SelectionCharStart]),           linePtr->insertPoint - SelectionCharStart);   tempLength += linePtr->insertPoint - SelectionCharStart;   textPtr[tempLength] = MAC_CR;   tempLength++;      /* Copy the lines in between. */   for (i = SelectionLineStart + 1; i < SelectionLineEnd; i++)     {      linePtr = &DisplayText[(ZeroDisplayLine + i) % MAX_DISPLAY_LINES];      strncpy(&textPtr[tempLength],linePtr->lineInfo,linePtr->insertPoint);      tempLength += linePtr->insertPoint;      textPtr[tempLength] = MAC_CR;      tempLength++;     }   /* Copy characters in the last line of the selection. */   linePtr = &DisplayText[(ZeroDisplayLine + SelectionLineEnd) % MAX_DISPLAY_LINES];   strncpy(&textPtr[tempLength],linePtr->lineInfo,SelectionCharEnd);   tempLength += SelectionCharEnd;   *length = tempLength;   return(textPtr);  }  /****************************************************************//* DoDisplayActivate: Handle activate event for display window. *//****************************************************************/void DoDisplayActivate(  WindowPtr whichWindow)  {   RgnHandle theRegion;      DrawGrowIcon(whichWindow);   if (! DisplayActive)     {       theRegion = DisplaySelectionRegion(whichWindow);      PenMode(patXor);      FrameRgn(theRegion);       InvertRgn(theRegion);      PenMode(patCopy);      DisposeRgn(theRegion);     }        DisplayActive = 1;   HiliteControl(DisplayVScroll,ACTIVE_VALUE);   HiliteControl(DisplayHScroll,ACTIVE_VALUE);  }/********************************************************************//* DoDisplayDeactivate: Handle deactivate event for display window. *//********************************************************************/void DoDisplayDeactivate(whichWindow)  WindowPtr whichWindow;  {   RgnHandle theRegion;      DrawGrowIcon(whichWindow);   if (DisplayActive)     {       theRegion = DisplaySelectionRegion(whichWindow);      PenMode(patXor);      InvertRgn(theRegion);      FrameRgn(theRegion);       PenMode(patCopy);      DisposeRgn(theRegion);     }        DisplayActive = 0;   HiliteControl(DisplayVScroll,INACTIVE_VALUE);   HiliteControl(DisplayHScroll,INACTIVE_VALUE);  }/***********************************************************//* FixDisplayCursor: Changes the cursor to its appropriate *//*   icon when the cursor is in the display window.        *//***********************************************************/void FixDisplayCursor(  WindowPtr myWindow)  {   Point mousePoint;   Rect textRect;   GrafPtr savePort;   RgnHandle theRegion;      /*============================================*/   /* Save the previous port and make the window */   /* to be updated the current port.            */   /*============================================*/   GetPort(&savePort);   SetPort(myWindow);      /*=============================================================*/   /* Get the mouse position and the window's text rectangle (the */   /* window's area minus horizontal and vertical scroll bars).   */   /*=============================================================*/   GetMouse(&mousePoint);   textRect = (*myWindow).portRect;   textRect.right -= (SCROLL_BAR_WIDTH - 1);   textRect.bottom -= (SCROLL_BAR_WIDTH - 1);   /*===================================================*/   /* If the mouse is within the text rectangle and not */   /* within a selected region, then use the I-beam     */   /* cursor, otherwise use the arrow cursor.           */   /*===================================================*/   if (PtInRect(mousePoint,&textRect))     {       theRegion = DisplaySelectionRegion(myWindow);            if (PtInRgn(mousePoint,theRegion))        { SetCursor(&ARROW); }      else        { SetCursor(*IBeamCursor); }      DisposeRgn(theRegion);     }   else     { SetCursor(&ARROW); }        /*============================*/   /* Restore the original port. */   /*============================*/   SetPort(savePort);  }/****************************************************//* DoDisplayClose: Handle close for display window. *//****************************************************/static void DoDisplayClose(whichWindow)  WindowPtr whichWindow;  {   Handle dataHandle;   PositionRSRCHdl theResource;   short top, left, bottom, right, width, height;      /*=============================================*/   /* Remember the position of the dialog window. */   /*=============================================*/   if (RememberEnvironmentWindowState)     {      GetGlobalWindowPosition(whichWindow,&top,&left,&bottom,&right);      height = bottom - top;      width = right - left;      theResource = CreatePositionResource(top,left,height,width);      RememberPreferences(positionResType,dialogPositionResID,(Handle) theResource);     }   /*==================*/   /* Get window data. */   /*==================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   /*================================*/   /* Dispose of window data record. */   /*================================*/   DisposHandle(dataHandle);   /*===========================================================*/   /* Destroy the window. DisposeWindow  automatically disposes */   /* of any controls associated with the window.               */   /*===========================================================*/   DisposeWindow(whichWindow);   /*==================================*/   /* Update the DisplayWindow global. */   /*==================================*/   DisplayWindow = NULL;  }/***********************************************************************//* DisplayMenuUpdateRoutine: Handles menu update for a display window. *//***********************************************************************/static void DisplayMenuUpdateRoutine(whichWindow)  WindowPtr whichWindow;  {   WDHandle theData;   Handle dataHandle;   /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (WDHandle) dataHandle;   /*============================*/   /* Enable various menu items. */   /*============================*/   EnableStandardMenuItem(STANDARD_MENU_ITEM_PRINT);   if ((SelectionLineStart != SelectionLineEnd) ||       (SelectionCharStart != SelectionCharEnd))     { EnableStandardMenuItem(STANDARD_MENU_ITEM_COPY); }   if (TEGetScrapLen() != 0) EnableStandardMenuItem(STANDARD_MENU_ITEM_PASTE);   EnableItem(EditMenu,SelectAllItem);   /*============================*/   /* Call the application hook. */   /*============================*/   if ((**theData).applicationHook != NULL)     { (*(**theData).applicationHook)(whichWindow,NULL,NULL,' ',MENU_UPDATE_MESSAGE); }  }/*****************************************************************//* DisplaySelectionRegion                                        *//*****************************************************************/RgnHandle DisplaySelectionRegion(  WindowPtr whichWindow)  {   Rect theRect;   int numberOfLines;   RgnHandle theRegion = NewRgn(), tempRegion;   /*=========================================*/   /* If the selection is not being extended, */   /* then nothing needs to be done.          */   /*=========================================*/   if ((SelectionLineStart == SelectionLineEnd) &&        (SelectionCharStart == SelectionCharEnd))     { return(theRegion); }      /*=================================================*/   /* Handle the first line of the current selection. */   /*=================================================*/   theRect.left = whichWindow->portRect.left + LeftWindowMargin +                  (SelectionCharStart * CharacterWidth) -                  (LeftMarginNumber * CharacterWidth);   if (SelectionCharStart == 0) theRect.left -= LeftWindowMargin;   if (SelectionLineStart == SelectionLineEnd)     {      theRect.right = whichWindow->portRect.left + LeftWindowMargin +                      (SelectionCharEnd * CharacterWidth) -                      (LeftMarginNumber * CharacterWidth);     }   else     { theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1); }   theRect.top = (SelectionLineStart - TopDisplayNumber) * DisplayLineHeight;   theRect.bottom = theRect.top + DisplayLineHeight;        CropScrollBarSpillage(&theRect,whichWindow);   tempRegion = NewRgn();   RectRgn(tempRegion,&theRect);   UnionRgn(tempRegion,theRegion,theRegion);   /*==================================*/   /* Handle the lines between the top */   /* and bottom lines selected.       */   /*==================================*/             numberOfLines = (SelectionLineEnd - SelectionLineStart) + 1;   if (numberOfLines > 2)     {      theRect.left = whichWindow->portRect.left;      theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1);      theRect.top = ((SelectionLineStart + 1) - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + (DisplayLineHeight * (numberOfLines - 2));      CropScrollBarSpillage(&theRect,whichWindow);      RectRgn(tempRegion,&theRect);      UnionRgn(tempRegion,theRegion,theRegion);     }   /*=======================*/   /* Handle the last line. */   /*=======================*/      if ((SelectionCharEnd != 0) && (numberOfLines > 1))     {      theRect.left = whichWindow->portRect.left;      theRect.right = whichWindow->portRect.left + LeftWindowMargin +                      (SelectionCharEnd * CharacterWidth) -                      (LeftMarginNumber * CharacterWidth);      theRect.top = (SelectionLineEnd - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + DisplayLineHeight;      CropScrollBarSpillage(&theRect,whichWindow);      RectRgn(tempRegion,&theRect);      UnionRgn(tempRegion,theRegion,theRegion);     }   /*=============================================*/   /* Return the region of the current selection. */   /*=============================================*/      DisposeRgn(tempRegion);   return(theRegion);  }/*****************************************************************//* CursorShouldBeDrawn                                        *//*****************************************************************/Boolean CursorShouldBeDrawn()  {   int x, count;      /*=======================================*/   /* If the cursor is already drawn, there */   /* is no need to draw it again.          */   /*=======================================*/      if (CursorVisible) return (false);      /*=========================================================*/   /* Determine if the line with the cursor on it is visible. */   /*=========================================================*/      x = (ZeroDisplayLine + TopDisplayNumber) % MAX_DISPLAY_LINES;   count = 0;   while ((x != AppendDisplayLine) && (count <= LinesInDisplayWindow))     {      x = (x + 1) % MAX_DISPLAY_LINES;      count++;     }   if (x != AppendDisplayLine) return(false);      /*====================================*/   /* If the current selection is empty, */   /* then draw the cursor.              */   /*====================================*/      if ((SelectionCharStart == SelectionCharEnd) &&       (SelectionLineStart == SelectionLineEnd))     { return(TRUE); }        /*====================================*/   /* If the cursor overlaps the current */   /* selection, then don't draw it.     */   /*====================================*/      if ((SelectionLineEnd == AppendDisplayLine) &&       (DisplayText[AppendDisplayLine].insertPoint == SelectionCharEnd))     { return(false); }        /*=============================*/   /* Otherwise, draw the cursor. */   /*=============================*/      return(TRUE);  }