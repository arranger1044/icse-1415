   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                    SEARCH MODULE                    */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _SEARCH_SOURCE_#include "setup.h"#include <stddef.h>#include <ctype.h>#include <string.h>#include <OSUtils.h>#if THINK_C#include <BDC.h>#endif#include <Packages.h>#include <ToolUtils.h>#include <Memory.h>#include <Dialogs.h>#include <Menus.h>#include <Controls.h>#include <Events.h>#include <Types.h>#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#include "apprsrcs.h"#include "clpscrap.h"#include "editscrl.h"#include "editw.h"#include "editwdrg.h"#include "interface.h"#include "menucmds.h"#include "stnrdmac.h"#include "window.h"#include "search.h"#if MAC_SC7 || MAC_SC8#define CTOPSTR C2PStr#else#define CTOPSTR c2pstr#endif/***************//* DEFINITIONS *//***************/#define FindButton       1#define DontFindButton   2#define CancelButton     3#define MatchWordsCheck  4#define SearchTextEdit   7#define ReplaceTextEdit  8#define IgnoreCaseCheck  9#define ReplaceID 270/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   DoFind(TEHandle,WindowPtr);   static int                    DoFindAgain(TEHandle,WindowPtr);   static void                   DoReplace(TEHandle,WindowPtr);   static void                   DoReplaceAndFind(TEHandle,WindowPtr);   static void                   DoReplaceAll(TEHandle,WindowPtr);   static void                   SetFindButton(DialogPtr,int,int,int);   static void                   SetEditText(DialogPtr,int,int);   static void                   CopyEditText(DialogPtr,int,int);   static pascal Boolean         FindFilter(DialogPeek,EventRecord *,short int *);   static long int               FindString(Str255,long,long,char *,int,int);   static void                   DoEnterFindString(TEHandle);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static int               MatchWordsValue = 0;   static int               IgnoreCaseValue = 1;   static int               CurrentDefaultButton;   static Str255            SearchForText = "\p";   static Str255            ReplaceWithText = "\p";#if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor              FindFilterRD       = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterProcInfo,FindFilter);#define FindFilterRef &FindFilterRD#else#define FindFilterRef FindFilter#endif/***************************************************//* DOBUFFERCHOICE: Handle choice from buffer menu. *//***************************************************/void DoBufferChoice(theItem,whichWindow)  int theItem;  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Retrieve pointers to window's text record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*================================*/   /* Handle the buffer menu choice. */   /*================================*/   switch(theItem)     {      /*=========================*/      /* Handle Find... command. */      /*=========================*/      case FindItem:        DoFind(myText,whichWindow);        break;      /*============================*/      /* Handle Find Again command. */      /*============================*/      case FindAgainItem:        DoFindAgain(myText,whichWindow);        break;            /*======================================*/      /* Handle Enter Find String... command. */      /*======================================*/             case EnterFindStringItem:        DoEnterFindString(myText);        break;      /*================================*/      /* Handle Find Selection command. */      /*================================*/             case FindSelectionItem:        DoEnterFindString(myText);        DoFindAgain(myText,whichWindow);        break;            /*=========================*/      /* Handle Replace command. */      /*=========================*/      case ReplaceItem:        DoReplace(myText,whichWindow);        break;      /*==================================*/      /* Handle Replace and Find command. */      /*==================================*/      case ReplaceAndFindItem:        DoReplaceAndFind(myText,whichWindow);        break;      /*=============================*/      /* Handle Replace All command. */      /*=============================*/      case ReplaceAllItem:        DoReplaceAll(myText,whichWindow);        break;      /*================================*/      /* Handle Load Selection command. */      /*================================*/      case LoadSelectionItem:        DoLoadOrBatchSelection(myText,LOAD_SELECTION);        break;      /*================================*/      /* Handle Load Selection command. */      /*================================*/      case BatchSelectionItem:        DoLoadOrBatchSelection(myText,BATCH_SELECTION);        break;      /*================================*/      /* Handle Load Buffer command. */      /*================================*/      case LoadBufferItem:        DoLoadBuffer(myText);        break;     }  }/***********************************//* DOFIND: Handle Find... command. *//***********************************/static void DoFind(myText,whichWindow)  TEHandle myText;  WindowPtr whichWindow;  {   DialogPtr dptr;   short int itemNumber = 0;   GrafPtr savePort;   int done, find;   int OldMatchValue, OldIgnoreValue;   /*===========================================*/   /* Save the old port. Create the find dialog */   /* box and make it the current port.         */   /*===========================================*/   GetPort(&savePort);   dptr = GetNewDialog(265,NULL,(WindowPtr) -1L);   SetPort(dptr);   /*=========================*/   /* Display the dialog box. */   /*=========================*/   CenterWindow(dptr,0.5,0.33);   ShowWindow(dptr);   /*=================================================*/   /* Restore normal cursor before displaying dialog. */   /*=================================================*/   InitCursor();   /*====================================================*/   /* Set dialog values to current values and save them. */   /*====================================================*/   SetCheckBox(dptr,MatchWordsCheck,MatchWordsValue);   SetCheckBox(dptr,IgnoreCaseCheck,IgnoreCaseValue);   SetEditText(dptr,SearchTextEdit,ReplaceTextEdit);   SetFindButton(dptr,FindButton,DontFindButton,SearchTextEdit);   OldMatchValue = MatchWordsValue;   OldIgnoreValue = IgnoreCaseValue;   /*=====================*/   /* Conduct the dialog. */   /*=====================*/   done = 0;   find = 0;   while (! done)     {      /*=============================================================*/      /* Get the next dialog event. Use a filter to allow the return */      /* key to exit the dialog and editing commands to be used.     */      /*=============================================================*/      ModalDialog((ModalPtr) FindFilterRef,&itemNumber);      /*===========================*/      /* Process the dialog event. */      /*===========================*/      switch(itemNumber)        {         /*====================================================*/         /* User clicked Find button. Dialog is completed. The */         /* find command will be executed. Copy dialog search  */         /* and replace strings to global variables.           */         /*====================================================*/         case FindButton:           done = 1;           find = 1;           CopyEditText(dptr,SearchTextEdit,ReplaceTextEdit);           break;         /*===========================================================*/         /* User clicked Don't Find button. Dialog is completed. The  */         /* find command will not be executed, However, dialog search */         /* and replace strings will be copied to global variables.   */         /*===========================================================*/         case DontFindButton:           done = 1;           find = 0;           CopyEditText(dptr,SearchTextEdit,ReplaceTextEdit);           break;         /*======================================================*/         /* User clicked Cancel button. Dialog is completed. The */         /* find command will not be executed. Restore global    */         /* variables to values used before entering dialog.     */         /*======================================================*/         case CancelButton:           done = 1;           find = 0;           MatchWordsValue = OldMatchValue;           IgnoreCaseValue = OldIgnoreValue;           break;         /*============================================*/         /* User clicked Match Words check box. Toggle */         /* value and copy to global variable.         */         /*============================================*/         case MatchWordsCheck:           MatchWordsValue = ToggleCheckBox(dptr,MatchWordsCheck);           break;         /*============================================*/         /* User clicked Ignore Case check box. Toggle */         /* value and copy to global variable.         */         /*============================================*/         case IgnoreCaseCheck:           IgnoreCaseValue = ToggleCheckBox(dptr,IgnoreCaseCheck);           break;         /*===============================================*/         /* User clicked in Search For editable text box. */         /* Determine if find button needs to be active   */         /* or inactive.                                  */         /*===============================================*/         case SearchTextEdit:           SetFindButton(dptr,FindButton,DontFindButton,SearchTextEdit);           break;         /*=================================================*/         /* User clicked in Replace With editable text box. */         /* Do nothing.                                     */         /*=================================================*/         case ReplaceTextEdit:           break;        }     }   /*=============================================*/   /* Remove the dialog and restore the old port. */   /*=============================================*/   DisposDialog(dptr);   SetPort(savePort);   /*================================================*/   /* Handle any update or activate events triggered */   /* by displaying and removing the search dialog.  */   /*================================================*/      HandleWindowEvents();   /*=====================*/   /* Perform the search. */   /*=====================*/   if (find == 1)     { DoFindAgain(myText,whichWindow); }   /*===================================*/   /* Enable/disable search menu items. */   /*===================================*/   FixSearchMenu();  }/*******************************************//* DoFindAgain: Handle Find Again command. *//*******************************************/static int DoFindAgain(myText,whichWindow)  TEHandle myText;  WindowPtr whichWindow;  {   long int endAt;   Handle textHandle;   /*=====================================================*/   /* If search string is empty or no edit record exists, */   /* then the command cannot be performed. Note that     */   /* myText should never be NULL if this function is     */   /* entered.                                            */   /*=====================================================*/   if (SearchForText[0] == 0) return(0);   if (myText == NULL) return(0);   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*=========================================*/   /* Get the text handle of the edit record. */   /*=========================================*/   textHandle = (**myText).hText;   /*=======================*/   /* Lock the text handle. */   /*=======================*/   HLock(textHandle);   /*=======================================================*/   /* Search for the search string in the text beginning at */   /* the end of the current selection or insertion point.  */   /*=======================================================*/   endAt = FindString(SearchForText,(long int) (**myText).selEnd,             (long int) (**myText).teLength, *textHandle,             IgnoreCaseValue,MatchWordsValue);   /*=============================================*/   /* Unlock the text handle and the edit record. */   /*=============================================*/   HUnlock(textHandle);   HUnlock( (Handle) myText);   /*======================================================*/   /* If search string was not found, then beep and return */   /* a value indicating the search was unsuccessful.      */   /*======================================================*/   if (endAt < 0)     {      SysBeep(10);      return(0);     }   /*=========================================================*/   /* Set the current selection to the string that was found. */   /*=========================================================*/   TESetSelect(endAt,endAt + (long int) SearchForText[0],myText);   /*=====================================*/   /* Make sure the selection is visible. */   /*=====================================*/   ScrollToSelection(TRUE,whichWindow);   /*==========================================*/   /* Adjust the text to match the scroll bar. */   /*==========================================*/   EditAdjustText(whichWindow);   /*======================================================*/   /* Return a value indicating the search was successful. */   /*======================================================*/   return(1);  }/**************************************//* DOREPLACE: Handle Replace command. *//**************************************/static void DoReplace(myText,whichWindow)  TEHandle myText;  WindowPtr whichWindow;  {   /*======================================================*/   /* If no edit record exists, then the command cannot be */   /* performed. Note that myText should never be NULL if  */   /* this function is entered.                            */   /*======================================================*/   if (myText == NULL) return;   /*=====================================*/   /* Make sure the selection is visible. */   /*=====================================*/   ScrollToSelection(TRUE,whichWindow);   /*===============================*/   /* Remove the current selection. */   /*===============================*/   TEDelete(myText);   /*=================================================*/   /* If the replace string is not empty, then insert */   /* the replace string at the insertion point.      */   /*=================================================*/   if (ReplaceWithText[0] != 0)     { TEInsert(&ReplaceWithText[1],(long int) ReplaceWithText[0],myText); }   /*==================================================================*/   /* Adjust the scroll bar to the length of the text, adjust the text */   /* to match the scroll bar, and keep the insertion point visible.   */   /*===================================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(TRUE,whichWindow);   /*===========================*/   /* Mark the window as dirty. */   /*===========================*/   WindowDirty(whichWindow,TRUE);  }/******************************************************//* DOREPLACEANDFIND: Handle Replace and Find command. *//******************************************************/static void DoReplaceAndFind(myText,whichWindow)  TEHandle myText;  WindowPtr whichWindow;  {   DoReplace(myText,whichWindow);   DoFindAgain(myText,whichWindow);  }/*********************************************//* DoReplaceAll: Handle Replace All command. *//*********************************************/static void DoReplaceAll(myText,whichWindow)  TEHandle myText;  WindowPtr whichWindow;  {   long int replacements = 0;   long int oldStart, oldEnd;   Str255 stringNumber;   /*=====================================================*/   /* If search string is empty or no edit record exists, */   /* then the command cannot be performed. Note that     */   /* myText should never be NULL if this function is     */   /* entered.                                            */   /*=====================================================*/   if (SearchForText[0] == 0) return;   if (myText == NULL) return;   /*=========================================================*/   /* Save the start and end points of the current selection. */   /*=========================================================*/   HLock( (Handle) myText);   oldStart = (long int) (**myText).selStart;   oldEnd = (long int) (**myText).selEnd;   HUnlock( (Handle) myText);   /*==========================================================*/   /* Set the insertion point before the current selection so  */   /* that it can be replaced if it matches the search string. */   /*==========================================================*/   TESetSelect(oldStart,oldStart,myText);   /*==============================================*/   /* Search for and replace all occurences of the */   /* search string with the replace string. Keep  */   /* track of the number of replacements made.    */   /*==============================================*/   while (DoFindAgain(myText,whichWindow) == 1)     {      DoReplace(myText,whichWindow);      replacements++;     }   /*==========================================================*/   /* Restore previous selection if no replacements were made. */   /*==========================================================*/   if (replacements == 0)     {      TESetSelect(oldStart,oldEnd,myText);      return;     }   /*==================================================================*/   /* Display an alert box indicating how many replacements were made. */   /*==================================================================*/   NumToString(replacements,stringNumber);   ParamText(stringNumber,"\p","\p","\p");   Alert(ReplaceID,(ModalPtr) DefaultDialogFilterRef);  }/*************************************************************//* SetFindButton: Activates/Deactivates the find button of a *//* search dialog depending upon whether the search string is *//* empty.                                                    *//*************************************************************/static void SetFindButton(dptr,findButtonNumber,dontFindButtonNumber,findTextNumber)  DialogPtr dptr;  int findButtonNumber, dontFindButtonNumber, findTextNumber;  {   int newValue;   Str255 findText;   ControlHandle ctrlHandle;   Handle itemHandle;   Rect dispRect;   short int itemType;   /*=======================================================*/   /* Get the search string associated with the dialog box. */   /*=======================================================*/   GetDItem(dptr,findTextNumber,&itemType,&itemHandle,&dispRect);   GetIText(itemHandle,findText);   /*============================================================*/   /* If the search string is empty, then the find button should */   /* be inactive. Otherwise, the find button should be active.  */   /*============================================================*/   if (findText[0] == 0)     {      newValue = INACTIVE_VALUE;      OutlineButton(dptr,findButtonNumber,false);      OutlineButton(dptr,dontFindButtonNumber,TRUE);      CurrentDefaultButton = dontFindButtonNumber;     }   else     {      newValue = ACTIVE_VALUE;      if (CurrentDefaultButton != findButtonNumber)        {         OutlineButton(dptr,dontFindButtonNumber,false);         OutlineButton(dptr,findButtonNumber,TRUE);         CurrentDefaultButton = findButtonNumber;        }     }   /*======================================================*/   /* Get the control handle of the find button associated */   /* with the dialog box.                                 */   /*======================================================*/   GetDItem(dptr,findButtonNumber,&itemType,&itemHandle,&dispRect);   ctrlHandle = (ControlHandle) itemHandle;   /*====================================*/   /* Active/Deactivate the find button. */   /*====================================*/   HiliteControl(ctrlHandle,newValue);  }/***************************************************//* SETEDITTEXT: Sets the search and replace string *//* values of a search dialog box.                  *//***************************************************/static void SetEditText(dptr,searchTextNumber,replaceTextNumber)  DialogPtr dptr;  int searchTextNumber, replaceTextNumber;  {   Handle itemHandle;   Rect dispRect;   short int itemType;   /*=====================================*/   /* Set the value of the search string. */   /*=====================================*/   GetDItem(dptr,searchTextNumber,&itemType,&itemHandle,&dispRect);   SetIText(itemHandle,SearchForText);   /*============================================================*/   /* Highlight the search string so that it can be changed by   */   /* immediately entering a new value upon entering the dialog. */   /*============================================================*/   SelIText(dptr,searchTextNumber,0,SearchForText[0]);   /*======================================*/   /* Set the value of the replace string. */   /*======================================*/   GetDItem(dptr,replaceTextNumber,&itemType,&itemHandle,&dispRect);   SetIText(itemHandle,ReplaceWithText);  }/*******************************************************************//* COPYEDITTEXT: Copies the search and replace strings of a search *//* dialog box to the global search and replace string variables.   *//* In effect, this changes the default values for search and       *//* and replace when a search dialog is entered.                    *//*******************************************************************/static void CopyEditText(dptr,searchTextNumber,replaceTextNumber)  DialogPtr dptr;  int searchTextNumber, replaceTextNumber;  {   Handle itemHandle;   Rect dispRect;   short int itemType;   /*============================================================*/   /* Copy the dialog search string to the global search string. */   /*============================================================*/   GetDItem(dptr,searchTextNumber,&itemType,&itemHandle,&dispRect);   GetIText(itemHandle,SearchForText);   /*==============================================================*/   /* Copy the dialog replace string to the global replace string. */   /*==============================================================*/   GetDItem(dptr,replaceTextNumber,&itemType,&itemHandle,&dispRect);   GetIText(itemHandle,ReplaceWithText);  }/**************************************************//* FixSearchMenu: Enable/disable search commands. *//**************************************************/void FixSearchMenu()  {   /*===========================================================*/   /* If the search string is not empty, then enable selections */   /* that operate with a non-empty search string.              */   /*===========================================================*/   if (SearchForText[0] != 0)     {      EnableItem(BufferMenu,FindAgainItem);      EnableItem(BufferMenu,ReplaceAndFindItem);      EnableItem(BufferMenu,ReplaceAllItem);     }   /*========================================================*/   /* The Find command and the Replace command can always be */   /* used with an active edit record.                       */   /*========================================================*/   EnableItem(BufferMenu,FindItem);   EnableItem(BufferMenu,ReplaceItem);  }/**********************************************************************//* FindFilter: Filter which allows the find dialog box to process the *//* return key as a press on the find button and to use edit commands. *//**********************************************************************/static pascal Boolean FindFilter(theDialog,myEvent,itemNumber)  DialogPeek theDialog;  EventRecord *myEvent;  short int *itemNumber;  {   int cmdDown;   char ch;   GrafPtr tempPort;   /*============================*/   /* Check for activate events. */   /*============================*/   if ((*myEvent).what == activateEvt)     {      GetPort(&tempPort);      DoActivate(myEvent);      SetPort(tempPort);      return(false);     }   /*=======================*/   /* Handle update events. */   /*=======================*/   if ((*myEvent).what == updateEvt)     {      GetPort(&tempPort);      DoUpdate(myEvent);      SetPort(tempPort);      return(false);     }   /*==================================================*/   /* If a key wasn't pressed don't bother processing. */   /*==================================================*/   if ((*myEvent).what != keyDown) return(false);   /*========================================================*/   /* The return key acts as if the find button was pressed. */   /*========================================================*/   ch = (char) BitAnd(myEvent->message,charCodeMask);   if ((ch == '\r') || (ch == '\n') || (ch == '\03'))     {      *itemNumber = CurrentDefaultButton;      FlashButton((DialogPtr) theDialog,CurrentDefaultButton);      return(TRUE);     }   /*====================================================*/   /* Allow cut, copy, and paste to work in edit fields. */   /*====================================================*/   cmdDown = (BitAnd((*myEvent).modifiers,cmdKey) != 0);   if (! cmdDown) return(false);   *itemNumber = (*theDialog).editField + 1;   switch(ch)     {      case 'x':        DlgCut((DialogPtr) theDialog);        SetScrapDirtyStatus(TRUE);        break;      case 'c':        DlgCopy((DialogPtr) theDialog);        SetScrapDirtyStatus(TRUE);        break;      case 'v':        DlgPaste((DialogPtr) theDialog);        break;     }   return(TRUE);  }/*******************************************************************//* FindString: Searches for a string in a specified range of text. *//*******************************************************************/static long int FindString(compareString,start,end,searchString,ignoreCase,matchWords)  Str255 compareString;  long int start, end;  char *searchString;  int ignoreCase, matchWords;  {   long int i, k;   int j, done;   int searchLength;   long int newEnd;   /*==================================================*/   /* Determine the length of the string being sought. */   /* Return if the search string is empty.            */   /*==================================================*/   searchLength = compareString[0];   if (searchLength == 0) return(0);   /*==========================================================*/   /* Begin search at start of text range. End the search at a */   /* number of characters equal to the length of the search   */   /* string before the end of the text range.                 */   /*==========================================================*/   i = start;   newEnd = end - (searchLength - 1);   /*==============================================*/   /* Search until the end of the text is reached. */   /*==============================================*/   while (i < newEnd)     {      j = 1;      k = i;      done = 0;      /*==================================================*/      /* Start comparing the current position in the text */      /* to the search string.                            */      /*==================================================*/      while (! done)        {         /*======================================*/         /* If search string has matched then... */         /*======================================*/         if (j > searchLength)           {            /*===============================================*/            /* If match words option is off, then return the */            /* starting position of the found string.        */            /*===============================================*/            if (matchWords == 0) return(i);            /*================================================*/            /* The match words option is on. If the character */            /* proceeding the found string is not a blank or  */            /* carriage return, then the search process has   */            /* failed.                                        */            /*================================================*/            if ((i <= 0) ? false :                  (searchString[i-1] != ' ') &&                  (searchString[i-1] != '\r') &&                  (searchString[i-1] != '\n'))              { done = 1; }            /*=================================================*/            /* If the character proceeding the found string is */            /* not a blank or carriage return, then the search */            /* process has failed.                             */            /*=================================================*/            else if ((k >= end) ? false :                       (searchString[k] != ' ') &&                       (searchString[k] != '\r') &&                       (searchString[k] != '\n'))              { done = 1; }            /*===================================================*/            /* Else the found string falls on word boundaries.   */            /* Return the starting position of the found string. */            /*===================================================*/            else              { return(i); }           }         /*========================================================*/         /* Else if the text character and search string character */         /* are equal then continue the search.                    */         /*========================================================*/         else if (compareString[j] == searchString[k])           {            j++;            k++;           }         /*=========================================================*/         /* Else if the ignore case option is on, then determine if */         /* the text character and search string character are both */         /* alphabetic and differ only in case.                     */         /*=========================================================*/         else if (ignoreCase)           {            char c1, c2;            c1 = compareString[j];            c2 = searchString[k];            if (isalpha(c1) && isalpha(c2))              {               if (isupper(c1)) c1 = tolower(c1);               if (isupper(c2)) c2 = tolower(c2);              }            if (c1 != c2)              { done = 1; }            else              {               j++;               k++;              }           }         /*===========================================*/         /* Else the search process for this position */         /* in the text has failed.                   */         /*===========================================*/         else           { done = 1; }        }      /*======================================================*/      /* Move to the next position in the text to be checked. */      /*======================================================*/      i++;     }   /*==============================*/   /* Search string was not found. */   /*==============================*/   return(-1);  }  /********************************************************//* DoEnterFindString: Handle Enter Find String command. *//********************************************************/static void DoEnterFindString(  TEHandle theText)  {   long textLength;   Handle textHandle;   char *textPtr;   long start, end;      if (theText == NULL) return;       HLock((Handle) theText);      start = (long int) (**theText).selStart;   end = (long int) (**theText).selEnd;      textLength = end - start;      if (textLength > 254)     { textLength = 254; }        textHandle = (**theText).hText;   HLock(textHandle);   textPtr = *textHandle;      strncpy((char *) SearchForText,&textPtr[start],textLength);   SearchForText[textLength] = 0;   CTOPSTR((char *) SearchForText);      HUnlock(textHandle);   HUnlock((Handle) theText);  }