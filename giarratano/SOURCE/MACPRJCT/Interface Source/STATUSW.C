   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*               STATUS WINDOW MODULE                  */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _STATUSW_SOURCE_#include "setup.h"#include <string.h>#include <Memory.h>#include <Windows.h>#include <Controls.h>#include <Events.h>#include <TextEdit.h>#include <Menus.h>#define ARROW (qd.arrow)#include "editdlog.h"#include "menuhndl.h"#include "prefernc.h"#include "stnrdmac.h"#include "window.h"#include "statusw.h"#if MAC_SC7 || MAC_MCW || MAC_SC8#define ControlProcPtr ControlActionUPP#else#define ControlProcPtr ProcPtr#endif/***************//* DEFINITIONS *//***************/#define TOP_PRINT_MARGIN 20#define LEFT_PRINT_MARGIN 20#define BOTTOM_PRINT_MARGIN 20#define VIRTUAL_HORIZONTAL_WIDTH 2000#define HORIZONTAL_SCROLL_INCREMENT 10/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   SetStatusScroll(WindowPtr,SWDHandle);   static void                   AdjustStatusVerticalScroll(SWDHandle);   static void                   AdjustStatusHorizontalScroll(WindowPtr,SWDHandle);   static pascal void            StatusScrollProc(ControlHandle,short int);   static void                   ScrollStatus(WindowPtr,SWDHandle);   static void                   StatusCloseRoutine(WindowPtr);   static void                   StatusActivateRoutine(WindowPtr);   static void                   StatusDeactivateRoutine(WindowPtr);   static void                   StatusGrowRoutine(WindowPtr);   static short                  StatusContentRoutine(EventRecord *,WindowPtr);   static void                   StatusCursorRoutine(WindowPtr);   static void                   StatusPrintRoutine(THPrint,WindowPtr);   static void                   StatusMenuUpdateRoutine(WindowPtr);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static WindowPtr        ContentWindow;   static SWDHandle        ContentData;   static int              ScrollCode;   static int              ScrollAmt;#if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor StatusScrollProcRD       = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo,StatusScrollProc);#define StatusScrollProcRef &StatusScrollProcRD#else#define StatusScrollProcRef StatusScrollProc#endif/************************************************//* CreateStatusWindow: Creates a status window. *//************************************************/WindowPtr CreateStatusWindow(  int wtop,  int wleft,  int wwidth,  int wheight,  StringPtr title,  void *(*nextItemFunction)(void *),  void (*itemTextFunction)(char *,int,void *),  WindowPtr *whichGlobal,  int show,  short positionResourceID)  {   SWDHandle theData;   Handle dataHandle;   int height;   Rect scrollRect;   FontInfo finfo;   WindowPtr thisWindow;   ControlHandle theVScroll;   ControlHandle theHScroll;   Rect wRect = {50,50,200,200};   /*=========================================================*/   /* Create the facts window from the facts window template. */   /*=========================================================*/   SetPort((thisWindow = NewWindow((Ptr) NULL,                                   &wRect,title,false,zoomDocProc,                                   (WindowPtr) -1L,TRUE,0L)));   /*======================================================*/   /* Set the font style to monaco and the font size to 9. */   /*======================================================*/   TextFont(4);   TextSize(9);   /*==========================================*/   /* Size and Place the window on the screen. */   /*==========================================*/   SizeWindow(thisWindow,wwidth,wheight,false);   MoveWindow(thisWindow,wleft,wtop,false);   if (show) ShowWindow(thisWindow);   /*======================================================*/   /* Create the vertical scroll bar in the status window. */   /*======================================================*/   scrollRect = (*thisWindow).portRect;   scrollRect.left = scrollRect.right-15;   scrollRect.right += 1;   scrollRect.bottom -= 14;   scrollRect.top -= 1;   theVScroll = NewControl(thisWindow,&scrollRect, "\p", 1, 0, 0, 0,        scrollBarProc, 0L);   /*========================================================*/   /* Create the horizontal scroll bar in the status window. */   /*========================================================*/   scrollRect = (*thisWindow).portRect;   scrollRect.top = scrollRect.bottom-15;   scrollRect.bottom += 1;   scrollRect.right -= 14;   scrollRect.left -= 1;   theHScroll = NewControl(thisWindow,&scrollRect, "\p", 1, 0, 0, 0,        scrollBarProc, 0L);   /*=============================================*/   /* Allocate the window's data record and store */   /* it as the window's reference constant.      */   /*=============================================*/   dataHandle = NewHandle((Size) sizeof(StatusWindowData));   SetWRefCon(thisWindow,(long int) dataHandle);   /*=====================================================*/   /* Lock the data record and convert to a typed handle. */   /*=====================================================*/   HLock(dataHandle);   theData = (SWDHandle) dataHandle;   /*==============================================*/   /* Store fact window values in the data record. */   /*==============================================*/   (**theData).windowInfo.windowType = STATUS_WINDOW;   (**theData).windowInfo.growRoutine = StatusGrowRoutine;   (**theData).windowInfo.zoomRoutine = StatusGrowRoutine;   (**theData).windowInfo.contentRoutine = StatusContentRoutine;   (**theData).windowInfo.updateRoutine = StatusUpdateRoutine;   (**theData).windowInfo.activateRoutine = StatusActivateRoutine;   (**theData).windowInfo.deactivateRoutine = StatusDeactivateRoutine;   (**theData).windowInfo.closeRoutine = StatusCloseRoutine;   (**theData).windowInfo.cursorRoutine = StatusCursorRoutine;   (**theData).windowInfo.printRoutine = StatusPrintRoutine;   (**theData).windowInfo.menuUpdateRoutine = StatusMenuUpdateRoutine;   (**theData).windowInfo.keystrokeRoutine = NULL;   (**theData).windowInfo.vScrollBar = theVScroll;   (**theData).windowInfo.hScrollBar = theHScroll;   (**theData).nextItemRoutine = nextItemFunction;   (**theData).itemTextRoutine = itemTextFunction;   (**theData).goToBottomNextUpdate = false;   (**theData).globalPtr = whichGlobal;   (**theData).positionResourceID = positionResourceID;   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*====================================*/   /* Get the window's font information. */   /*====================================*/   GetFontInfo(&finfo);   /*==============================================================*/   /* Determine the location on which to begin the first line, the */   /* height of a line, the height of the facts window, the number */   /* of lines that can be placed in the window, and the index of  */   /* the fact displayed at the top of the window.                 */   /*==============================================================*/   (**theData).verticalPixelStartOffset = finfo.ascent + finfo.leading;   (**theData).lineHeight = finfo.ascent + finfo.descent + finfo.leading;   height = (*thisWindow).portRect.bottom - ((*thisWindow).portRect.top + SCROLL_BAR_WIDTH);   (**theData).linesInWindow = height / (**theData).lineHeight;   (**theData).topLineNumber = 0;   /*=============================*/   /* Draw the window's grow box. */   /*=============================*/   DrawGrowIcon(thisWindow);   /*==================================*/   /* Return the newly created window. */   /*==================================*/   return(thisWindow);  }/************************************************//* CompleteStatusRefresh: Invalidates an entire *//*   status window, forcing an update.          *//************************************************/void CompleteStatusRefresh(whichWindow)  WindowPtr whichWindow;  {   Rect viewRect;   GrafPtr savePort;   /*========================*/   /* Save the current port. */   /*========================*/   GetPort(&savePort);   /*====================================*/   /* Set the port to the status window. */   /*====================================*/   SetPort(whichWindow);   /*=====================================*/   /* Invalidate the entire viewing area. */   /*=====================================*/   viewRect = (*whichWindow).portRect;   viewRect.right -= SCROLL_BAR_WIDTH;   viewRect.bottom -= SCROLL_BAR_WIDTH;   InvalRect(&viewRect);   /*=======================*/   /* Restore the old port. */   /*=======================*/   SetPort(savePort);  }/*****************************************************************//* StatusUpdateRoutine: Handle update event for a status window. *//*****************************************************************/void StatusUpdateRoutine(whichWindow)  WindowPtr whichWindow;  {   void *itemPtr;   int y;   GrafPtr save_port;   RgnHandle rgn_hnd;   Rect viewRect;   int count;   int startX;   SWDHandle theData;   Handle dataHandle;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   void *(*nextItemFunction)(void *);   void (*itemTextFunction)(char *,int,void *);   char buffer[512];   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   nextItemFunction = (*theData)->nextItemRoutine;   itemTextFunction = (*theData)->itemTextRoutine;   /*======================================================*/   /* Save the old port. Set the port to the facts window. */   /*======================================================*/   GetPort(&save_port);   SetPort(whichWindow);   /*=======================*/   /* Reset the scroll bar. */   /*=======================*/   SetStatusScroll(whichWindow,theData);   if ((**theData).goToBottomNextUpdate)     {      SetCtlValue((**theData).windowInfo.vScrollBar,                  GetCtlMax((**theData).windowInfo.vScrollBar));      (**theData).goToBottomNextUpdate = false;     }   ScrollStatus(whichWindow,theData);   /*===================================================*/   /* Begin the update of the facts window. Temporarily */   /* restricts the visible region of the window by     */   /* intersecting it with the update region.           */   /*===================================================*/   BeginUpdate(whichWindow);   /*================================================*/   /* Erase the visible region of the window. Redraw */   /* the grow box and any window controls.          */   /*================================================*/   EraseRect(&(*whichWindow).portRect);   DrawGrowIcon(whichWindow);   DrawControls(whichWindow);   /*===============================*/   /* Save the old clipping region. */   /*===============================*/   rgn_hnd = NewRgn();   GetClip(rgn_hnd);   /*=================================================*/   /* Prevent output from spilling into scroll areas. */   /*=================================================*/   viewRect = (*whichWindow).portRect;   viewRect.right -= SCROLL_BAR_WIDTH;   viewRect.bottom = (**theData).lineHeight * (**theData).linesInWindow;   ClipRect(&viewRect);   /*===================================================*/   /* Position the pen in the upper left of the window. */   /*====================================================*/   startX = 10 - (GetCtlValue(myHScrollBar) * HORIZONTAL_SCROLL_INCREMENT);   y = (**theData).verticalPixelStartOffset;   MoveTo(startX,y);   /*==============================================================*/   /* Skip over any facts that fall out of range above the window. */   /*==============================================================*/   itemPtr = (*nextItemFunction)(NULL);   count = 0;   while (count < (**theData).topLineNumber)     {      if (itemPtr != NULL)        { itemPtr = (*nextItemFunction)(itemPtr); }      count++;     }   /*=======================================================*/   /* Display the items that fall within the status window. */   /*=======================================================*/   count = 0;   while ((itemPtr != NULL) && (count <= (**theData).linesInWindow))     {      (*itemTextFunction)(buffer,512,itemPtr);      DrawText(buffer,0,strlen(buffer));      y += (**theData).lineHeight;      MoveTo(startX,y);      itemPtr = (*nextItemFunction)(itemPtr);      count++;     }   /*==================================*/   /* Restore the old clipping region. */   /*==================================*/   SetClip(rgn_hnd);   DisposeRgn(rgn_hnd);   /*===================================================*/   /* End the update of the facts window. This restores */   /* the old visible region of the window.             */   /*===================================================*/   EndUpdate(whichWindow);   /*=======================*/   /* Restore the old port. */   /*=======================*/   SetPort(save_port);  }/*********************************************************//* StatusGrowRoutine: Recomputes the number of lines in  *//*   the status window. Normally called after the status *//*   window has been resized.                            *//*********************************************************/static void StatusGrowRoutine(whichWindow)  WindowPtr whichWindow;  {   int height;   SWDHandle theData;   Handle dataHandle;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*======================*/   /* Perform grow update. */   /*======================*/   FixScrollBar(myVScrollBar,myHScrollBar,whichWindow,0,0,0,0);   height = (*whichWindow).portRect.bottom - ((*whichWindow).portRect.top + SCROLL_BAR_WIDTH);   (**theData).linesInWindow = height / (**theData).lineHeight;  }/*******************************************************//* SetStatusScroll: Recomputes the number of settings *//*   for the vertical scroll bar in the facts window.  *//*******************************************************/static void SetStatusScroll(whichWindow,theData)  WindowPtr whichWindow;  SWDHandle theData;  {   AdjustStatusVerticalScroll(theData);   AdjustStatusHorizontalScroll(whichWindow,theData);  }/**************************************//* AdjustStatusVerticalScroll:         *//**************************************/static void AdjustStatusVerticalScroll(theData)  SWDHandle theData;  {   void *itemPtr;   int count = 0;   int n, max;   /*===============================================*/   /* Determine the total number of facts displayed */   /* in the facts window.                          */   /*===============================================*/   itemPtr = (*(*theData)->nextItemRoutine)(NULL);   while (itemPtr != NULL)     {      count++;      itemPtr = (*(*theData)->nextItemRoutine)(itemPtr);     }   /*=====================================================*/   /* Set n to the total number of facts minus the number */   /* of lines that can be displayed on the screen.       */   /*=====================================================*/   n = count - (**theData).linesInWindow;   /*====================================================*/   /* Maximum scroll position is n, or zero if all lines */   /* fit in present screen.                             */   /*====================================================*/   max = ( n > 0 ? n : 0 );   /*====================================================*/   /* Set the maximum value for the vertical scroll bar. */   /*====================================================*/   SetCtlMax((**theData).windowInfo.vScrollBar,max);  }/********************************************//* AdjustStatusHorizontalScroll:            *//********************************************/static void AdjustStatusHorizontalScroll(whichWindow,theData)  WindowPtr whichWindow;  SWDHandle theData;  {   int windowWidth;   int maxTop;   /*========================*/   /* Get the window width. */   /*========================*/   windowWidth = ((*whichWindow).portRect.right - (*whichWindow).portRect.left) /                   HORIZONTAL_SCROLL_INCREMENT;   /*==================================*/   /* Avoid white space at the bottom. */   /*==================================*/   maxTop = (VIRTUAL_HORIZONTAL_WIDTH / HORIZONTAL_SCROLL_INCREMENT)            - windowWidth;   /*=========================================*/   /* If the text is smaller than the window, */   /* then show all of the text.              */   /*=========================================*/   if (maxTop <= 0) maxTop = 0;   /*=====================================*/   /* Adjust the range of the scroll bar. */   /*=====================================*/   SetCtlMax((**theData).windowInfo.hScrollBar,maxTop);  }/**************************************************************//* StatusScrollProc: Scroll the facts within the facts window. *//**************************************************************/static pascal void StatusScrollProc(  ControlHandle theControl,  short int theCode)  {   int locVal;   if (theCode == ScrollCode)     {      locVal = GetCtlValue(theControl);      SetStatusScroll(ContentWindow,ContentData);      SetCtlValue(theControl,locVal + ScrollAmt);      StatusUpdateRoutine(ContentWindow);     }  }/*************************************************//* StatusContentRoutine: Handle mouse-down event *//*   in the content region of a status window.   *//*************************************************/static short StatusContentRoutine(myEvent,whichWindow)  EventRecord *myEvent;  WindowPtr whichWindow;  {   int cntlCode;   ControlHandle theControl;   int pageSize;   GrafPtr savePort;   Point thePoint;   SWDHandle theData;   Handle dataHandle;      /*===================================================*/   /* If the window is inactive, then just activate it. */   /*===================================================*/   if (whichWindow != FrontWindow())     {      SelectWindow(whichWindow);      return(1);     }   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   /*===========================================*/   /* Set up the content event handler globals. */   /*===========================================*/   ContentWindow = whichWindow;   ContentData = theData;   /*========================*/   /* Save the current port. */   /*========================*/   GetPort(&savePort);   /*===========================================*/   /* Set the current port to the facts window. */   /*===========================================*/   SetPort(whichWindow);   /*==============================================*/   /* Get Point in screen coordinates and convert  */   /* to window coordinates.                       */   /*==============================================*/   thePoint = myEvent->where;   GlobalToLocal(&thePoint);   /*===================================================*/   /* Determine where the click occurred and handle it. */   /*===================================================*/   switch (cntlCode = FindControl(thePoint,whichWindow,&theControl))     {      case inUpButton:      case inDownButton:      case inPageUp:      case inPageDown:        if (theControl == (**theData).windowInfo.vScrollBar)          { pageSize = (**theData).linesInWindow; }        else if (theControl == (**theData).windowInfo.hScrollBar)          {           pageSize = (*whichWindow).portRect.right - (*whichWindow).portRect.left;           pageSize -= SCROLL_BAR_WIDTH;           pageSize = pageSize / HORIZONTAL_SCROLL_INCREMENT;          }        switch (cntlCode)          {           case inUpButton:             ScrollAmt = -1;             break;           case inDownButton:             ScrollAmt = 1;             break;           case inPageUp:             ScrollAmt = -pageSize;             break;           case inPageDown:             ScrollAmt = pageSize;             break;          }        ScrollCode = cntlCode;        if (TrackControl(theControl,thePoint,(ControlProcPtr) StatusScrollProcRef))          { /* Do Nothing */ }        break;      case inThumb:        if (TrackControl(theControl,thePoint,(ControlProcPtr) 0L))          { /* Do Nothing */ }        StatusUpdateRoutine(whichWindow);        break;      default:        break;     }    /*=======================*/    /* Restore the old port. */    /*=======================*/    SetPort(savePort);    return(1);   }/**********************************************************//* ScrollStatus: Scrolls the contents of the facts window. *//**********************************************************/static void ScrollStatus(whichWindow,theData)  WindowPtr whichWindow;  SWDHandle theData;  {   RgnHandle tmpRgn;   int dv, dh;   Rect viewRect;   int old_number;   /*===================================================*/   /* Compute the vertical difference in the facts from */   /* the old location of the origin and the current    */   /* position indicated by the vertical scroll bar.    */   /*===================================================*/   old_number = (**theData).topLineNumber;   (**theData).topLineNumber = GetCtlValue((**theData).windowInfo.vScrollBar);   dv = (old_number - (**theData).topLineNumber) * (**theData).lineHeight;   /*====================================================*/   /* Compute the horizontal difference in the text from */   /* the old location of the origin and the current     */   /* position indicated by the horizontal scroll bar.   */   /*====================================================*/   old_number = (**theData).leftMarginNumber;   (**theData).leftMarginNumber = GetCtlValue((**theData).windowInfo.hScrollBar);   dh = (old_number - (**theData).leftMarginNumber) * HORIZONTAL_SCROLL_INCREMENT;   /*==================================================*/   /* Offset the destination rectangle to scroll text. */   /*==================================================*/   viewRect = (*whichWindow).portRect;   viewRect.right -= SCROLL_BAR_WIDTH;   viewRect.bottom = (**theData).lineHeight * (**theData).linesInWindow;   /*===========================================*/   /* Create a region to store the update area. */   /*===========================================*/   tmpRgn = NewRgn();   /*============================================================*/   /* If scrolling needs to be performed, then do it. Invalidate */   /* the area that is left empty by scrolling.                  */   /*============================================================*/   if ((dv != 0) || (dh != 0))     {      ScrollRect(&viewRect , dh, dv, tmpRgn );      InvalRgn(tmpRgn);     }   /*========================*/   /* Dispose of the region. */   /*========================*/   DisposeRgn( tmpRgn );  }/*********************************************************************//* StatusActivateRoutine: Handle activate event for a status window. *//*********************************************************************/static void StatusActivateRoutine(whichWindow)  WindowPtr whichWindow;  {   WDHandle         theData;   Handle           dataHandle;   ControlHandle    myVScrollBar;   ControlHandle    myHScrollBar;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   /*=====================================*/   /* Get the scroll bars for the window. */   /*=====================================*/   myVScrollBar = (**theData).vScrollBar;   myHScrollBar = (**theData).hScrollBar;   /*=======================*/   /* Perform the activate. */   /*=======================*/   DrawGrowIcon(whichWindow);   HiliteControl(myVScrollBar,ACTIVE_VALUE);   HiliteControl(myHScrollBar,ACTIVE_VALUE);  }/*************************************************************************//* StatusDeactivateRoutine: Handle deactivate event for a status window. *//*************************************************************************/static void StatusDeactivateRoutine(whichWindow)  WindowPtr whichWindow;  {   WDHandle         theData;   Handle           dataHandle;   ControlHandle    myVScrollBar;   ControlHandle    myHScrollBar;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   /*=====================================*/   /* Get the scroll bars for the window. */   /*=====================================*/   myVScrollBar = (**theData).vScrollBar;   myHScrollBar = (**theData).hScrollBar;   /*=======================*/   /* Perform the activate. */   /*=======================*/   DrawGrowIcon(whichWindow);   HiliteControl(myVScrollBar,INACTIVE_VALUE);   HiliteControl(myHScrollBar,INACTIVE_VALUE);  }/*********************************************************//* StatusCloseRoutine: Handle close for a status window. *//*********************************************************/static void StatusCloseRoutine(whichWindow)  WindowPtr whichWindow;  {   Handle dataHandle;   SWDHandle theData;   short top, left, right, bottom, height, width;   PositionRSRCHdl theResource;      /*==================*/   /* Get window data. */   /*==================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   /*=============================================*/   /* Remember the position of the dialog window. */   /*=============================================*/   if (RememberEnvironmentWindowState)     {      GetGlobalWindowPosition(whichWindow,&top,&left,&bottom,&right);      height = bottom - top;      width = right - left;      theResource = CreatePositionResource(top,left,height,width);      RememberPreferences(positionResType,(**theData).positionResourceID,(Handle) theResource);     }   /*=========================================*/   /* Reset any global pointer to the window. */   /*=========================================*/   if ((*theData)->globalPtr != NULL)     { *((*theData)->globalPtr) = NULL; }   /*================================*/   /* Dispose of window data record. */   /*================================*/   DisposHandle(dataHandle);   /*===========================================================*/   /* Destroy the window. DisposeWindow  automatically disposes */   /* of any controls associated with the window.               */   /*===========================================================*/   DisposeWindow(whichWindow);  }/******************************************************************//* StatusCursorRoutine: Handle cursor update for a status window. *//******************************************************************/static void StatusCursorRoutine(whichWindow)  WindowPtr whichWindow;  {#if MAC_MPW || MAC_MCW#pragma unused(whichWindow)#endif   SetCursor(&ARROW);  }/*******************************************************************//* StatusPrintRoutine: Prints the status window to a print record. *//*******************************************************************/static void StatusPrintRoutine(hPrint,whichWindow)  THPrint hPrint;  WindowPtr whichWindow;  {   int line = 0;   int lastLineOnPage = 0;   Rect printRect;   int linesPerPage;   int lineBase;   int lineHeight;   FontInfo info;   TPPrPort printPort;   SWDHandle theData;   Handle dataHandle;   void *(*nextItemFunction)(void *);   void (*itemTextFunction)(char *,int,void *);   void *itemPtr = NULL;   char buffer[512];   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   nextItemFunction = (*theData)->nextItemRoutine;   itemTextFunction = (*theData)->itemTextRoutine;   /*====================================*/   /* Initialize a printing grafPort for */   /* use in printing a document.        */   /*====================================*/   printPort = PrOpenDoc( hPrint, 0L, 0L );   /*==============================================================*/   /* Make the current port the printing port. Note that PrOpenDoc */   /* should have already made printPort the current port.         */   /*==============================================================*/   SetPort((GrafPtr) printPort);   /*===============================================================*/   /* Set the appropriate font type and size for the printing port. */   /*===============================================================*/   TextFont((*((GrafPtr) whichWindow)).txFont);   TextSize((*((GrafPtr) whichWindow)).txSize);   /*===============================================*/   /* Determine the line height and number of lines */   /* per page for the printing port.               */   /*===============================================*/   printRect = (**hPrint).prInfo.rPage;   GetFontInfo( &info );   lineHeight = info.leading + info.ascent + info.descent;   linesPerPage =        (printRect.bottom - printRect.top - TOP_PRINT_MARGIN - BOTTOM_PRINT_MARGIN) / lineHeight;   /*=======================================*/   /* Print the document page by page until */   /* the end of document is reached.       */   /*=======================================*/   itemPtr = (*nextItemFunction)(itemPtr);   while (itemPtr != NULL)     {      /*==================================================*/      /* Inform the Printing Manager to begin a new page. */      /*==================================================*/      PrOpenPage( printPort, 0L );      /*=================================================*/      /* Position the pen in the upper left of the page. */      /*=================================================*/      lineBase = printRect.top + lineHeight;      MoveTo(printRect.left + LEFT_PRINT_MARGIN,lineBase);      /*=========================================================*/      /* Print the current page line by line until the last line */      /* on the page or the end of the document is reached.      */      /*=========================================================*/      line = 0;      while ((line < linesPerPage) && (itemPtr != NULL))        {         /*==================================================*/         /* Print the line. Note that tab characters have no */         /* special meaning to DrawText.                     */         /*==================================================*/         (*itemTextFunction)(buffer,512,itemPtr);         DrawText(buffer,0,strlen(buffer));         /*====================================*/         /* Position the pen at the next line. */         /*====================================*/         lineBase += lineHeight;         MoveTo(printRect.left + LEFT_PRINT_MARGIN,lineBase);         /*====================*/         /* Update line count. */         /*====================*/         line++;         itemPtr = (*nextItemFunction)(itemPtr);        }      /*==================================*/      /* Inform the Printing Manager that */      /* the current page is finished.    */      /*==================================*/      PrClosePage(printPort);     }   /*==============================*/   /* Close the printing grafPort. */   /*==============================*/   PrCloseDoc(printPort);  }/*********************************************************************//* StatusMenuUpdateRoutine: Handles menu update for a status window. *//*********************************************************************/static void StatusMenuUpdateRoutine(whichWindow)  WindowPtr whichWindow;  {#if MAC_MPW || MAC_MCW#pragma unused(whichWindow)#endif   EnableStandardMenuItem(STANDARD_MENU_ITEM_CLOSE);   EnableStandardMenuItem(STANDARD_MENU_ITEM_PRINT);  }/**************************************//* GoToStatusWindowBottom:         *//**************************************/void GoToStatusWindowBottom(whichWindow)  WindowPtr whichWindow;  {   SWDHandle theData;   Handle dataHandle;   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (SWDHandle) dataHandle;   (**theData).goToBottomNextUpdate = TRUE;  }