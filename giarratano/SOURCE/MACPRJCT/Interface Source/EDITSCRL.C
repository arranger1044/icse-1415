   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  06/12/96          */   /*                                                     */   /*              EDIT WINDOW SCROLL MODULE              */   /*******************************************************//*************************************************************//* Purpose: Routines for scrolling and selecting the         *//*   contents of the edit window.                            *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _EDITSCRL_SOURCE_#include "setup.h"#include "commline.h"#include "constant.h"#include "constrct.h"#include "filecom.h"#include "clipsmem.h"#include "router.h"#include "scanner.h"#include "strngrtr.h"#include <stddef.h>#include <string.h>#include <Controls.h>#include <Dialogs.h>#include <Events.h>#include <Fonts.h>#include <LowMem.h>#include <Memory.h>#include <Menus.h>#include <QuickDraw.h>#include <TextEdit.h>#include <ToolUtils.h>#include <Windows.h>#if MAC_SC7 || MAC_MCW || MAC_SC8#define ControlProcPtr ControlActionUPP#else#define ControlProcPtr ProcPtr#endif#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_SC7 || MAC_SC8#define PTOCSTR P2CStr#define CTOPSTR C2PStr#else#define PTOCSTR p2cstr#define CTOPSTR c2pstr#endif#include "apprsrcs.h"#include "stnrdmac.h"#include "editw.h"#include "editwdrg.h"#include "interface.h"#include "macinit.h"#include "menuhndl.h"#include "search.h"#include "window.h"#include "editscrl.h"/***************//* DEFINITIONS *//***************/#define TEXT_MARGIN                         4#define VIRTUAL_HORIZONTAL_WIDTH         2000#define HORIZONTAL_SCROLL_INCREMENT        10#define TO_TOP                              0#define TO_BOTTOM                           1#define TO_MIDDLE                           2#define StopCantDoID 1009#define MAX_CONSTRUCT_LIST_SIZE 300/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void             DoVScroll(int,Point,ControlHandle,WindowPtr);   static void             DoHScroll(int,Point,ControlHandle,WindowPtr);   static void             DoSelect(Point,TEHandle,WindowPtr,EventRecord *,                                    ControlHandle,ControlHandle);   static Boolean          CreateConstructListMenu(TEHandle,long *);   static Boolean          AddConstructToMenu(char *);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static TEHandle         TempText;   static WindowPtr        TempWindow;   static ControlHandle    TempVScrollBar;   static ControlHandle    TempHScrollBar;   static char            *MenuLogicalName = "construct-menu";   #if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor       ScrollVTextRD       = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo,ScrollVText);         static RoutineDescriptor       ScrollHTextRD       = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo,ScrollHText);#define ScrollVTextRef &ScrollVTextRD#define ScrollHTextRef &ScrollHTextRD#else#define ScrollVTextRef ScrollVText#define ScrollHTextRef ScrollHText#endif/****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   #if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor       AutoScrollRD       = BUILD_ROUTINE_DESCRIPTOR(uppTEClickLoopProcInfo,AutoScroll);#endif/*************************************************//* DoEditContent: Handle mouse-down event in the *//*   content region of an editing window.        *//*************************************************/short DoEditContent(myEvent,whichWindow)  EventRecord *myEvent;  WindowPtr whichWindow;  {   Point thePoint;   Rect theRect;   ControlHandle theControl;   int thePart;   EWDHandle theData;   Handle dataHandle;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   GrafPtr savePort;   short rv = 1;   short oldFont, oldSize;   long *lineCounts;   long mresult, theLine;   /*============================================*/   /* Save the previous port and make the window */   /* to be updated the current port.            */   /*============================================*/   GetPort(&savePort);   SetPort(whichWindow);   /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   TempText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*==============================================*/   /* Process content mouse-down for edit windows. */   /* Get Point in screen coordinates and convert  */   /* to window coordinates.                       */   /*==============================================*/   thePoint = myEvent->where;   GlobalToLocal(&thePoint);   /*=====================================*/   /* Was mouse pressed inside a control? */   /*=====================================*/   thePart = FindControl(thePoint,whichWindow,&theControl);   /*=====================================================*/   /* If control was a scroll bar, then scroll the window */   /* if it's active, otherwise activate it.              */   /*=====================================================*/   if (theControl == myVScrollBar)     {       if (whichWindow == FrontWindow() && (! Suspended))        { DoVScroll(thePart,thePoint,theControl,whichWindow); }      else        { SelectWindow(whichWindow); }     }   else if (theControl == myHScrollBar)     {       if (whichWindow == FrontWindow() && (! Suspended))        { DoHScroll(thePart,thePoint,theControl,whichWindow); }      else        { SelectWindow(whichWindow); }     }   /*=======================================================*/   /* else if no control was found and the mouse-down event */   /* was in the text rectangle, then handle text selection */   /* (if the window is active), activation (if the window  */   /* is inactive), or drag and drop if the mouse-down was  */   /* in a text selection.                                  */   /*=======================================================*/   else if (theControl == NULL)     {                  if (ClickInEditDragRegion(thePoint,TempText))         {         rv = FALSE;         if (! DoEditDragAndDrop(myEvent,whichWindow,TempText))           {             if (whichWindow == FrontWindow() && (! Suspended))               {                DoSelect(thePoint,TempText,whichWindow,myEvent,myVScrollBar,myHScrollBar);                ResetShiftSelectionAnchor(whichWindow);              }            else              {                SelectWindow(whichWindow);                rv = TRUE;              }           }        }      else if (ClickInConstructsAreaRect(whichWindow,thePoint))        {         if (whichWindow == FrontWindow() && (! Suspended))           {            DrawConstructsMenuArea(whichWindow,true);                     GetConstructsAreaRect(whichWindow,&theRect,true);            oldFont = LMGetSysFontFam();            oldSize = LMGetSysFontSize();                              LMSetSysFontFam(geneva);            LMSetSysFontSize(9);            LMSetLastSPExtra(-1);                          lineCounts = genalloc(sizeof(long) * MAX_CONSTRUCT_LIST_SIZE);            CreateConstructListMenu(TempText,lineCounts);                        mresult = PopUpMenuSelect(ConstructListMenu,theRect.top+3,theRect.right,                                      CountMenuItems(ConstructListMenu));                        if ((HiWord(mresult) != 0) && (lineCounts[0] != -1))              {               mresult = LoWord(mresult);                              /*=============================================*/               /* Set the current selection to the beginning  */               /* of the first line containing the construct. */               /*=============================================*/                              theLine = lineCounts[mresult-1];                              TESetSelect((**TempText).lineStarts[theLine],                           (**TempText).lineStarts[theLine+1],TempText);               /*=====================================*/               /* Make sure the selection is visible. */               /*=====================================*/               ScrollToSelection(TRUE,whichWindow);               /*==========================================*/               /* Adjust the text to match the scroll bar. */               /*==========================================*/               EditAdjustText(whichWindow);              }                                         genfree(lineCounts,sizeof(long) * MAX_CONSTRUCT_LIST_SIZE);                        LMSetSysFontFam(oldFont);            LMSetSysFontSize(oldSize);            LMSetLastSPExtra(-1);                        DrawConstructsMenuArea(whichWindow,false);           }         else           { SelectWindow(whichWindow); }        }      else        {          if (whichWindow == FrontWindow() && (! Suspended))            {             DoSelect(thePoint,TempText,whichWindow,myEvent,myVScrollBar,myHScrollBar);            ResetShiftSelectionAnchor(whichWindow);            }         else           { SelectWindow(whichWindow); }        }     }   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);      /*============================*/   /* Restore the original port. */   /*============================*/   SetPort(savePort);      /*=========================*/   /* Return value indicates  */   /* whether a drag occured. */   /*=========================*/   return(rv);  }/**************************************************************//* DoVScroll: Handle mouse-down event in vertical scroll bar. *//**************************************************************/static void DoVScroll(thePart,thePoint,myVScrollBar,whichWindow)  int thePart;  Point thePoint;  ControlHandle myVScrollBar;  WindowPtr whichWindow;  {   /*==============================================================*/   /* If the indicator is being dragged, then track the mouse with */   /* no action procedure and then adjust text to new setting.     */   /*==============================================================*/   if (thePart == inThumb)     {      thePart = TrackControl(myVScrollBar,thePoint,(ControlProcPtr) NULL);      EditAdjustText(whichWindow);     }   /*================================================*/   /* else track the mouse with a continuous scroll. */   /*================================================*/   else     {      TempWindow = whichWindow;      thePart = TrackControl(myVScrollBar,thePoint,(ControlProcPtr) ScrollVTextRef);     }  }/******************************************************//* ScrollVText: Scroll text vertically within window. *//******************************************************/pascal void ScrollVText(  ControlHandle theControl,  short int thePart)  {   int delta;   int oldValue;   switch(thePart)     {      /*===============================*/      /* Scroll up one line at a time. */      /*===============================*/      case inUpButton:        delta = -1;        break;      /*=================================*/      /* Scroll down one line at a time. */      /*=================================*/      case inDownButton:        delta = 1;        break;      /*========================================*/      /* Scroll up by height of text rectangle. */      /*========================================*/      case inPageUp:        delta = (((**TempText).viewRect.top - (**TempText).viewRect.bottom)                 / (**TempText).lineHeight) + 1;        break;      /*==========================================*/      /* Scroll down by height of text rectangle. */      /*==========================================*/      case inPageDown:        delta = (((**TempText).viewRect.bottom - (**TempText).viewRect.top)                 / (**TempText).lineHeight) - 1;        break;      default:        break;     }   /*===========================================================*/   /* If the mouse is still in the original part, then get the  */   /* old setting, adjust by the scroll amount, and scroll text */   /* to match the new setting.                                 */   /*===========================================================*/   if (thePart != 0)     {      oldValue = GetCtlValue(theControl);      SetCtlValue(theControl,oldValue + delta);      EditAdjustText(TempWindow);     }  }/****************************************************************//* DoHScroll: Handle mouse-down event in horizontal scroll bar. *//****************************************************************/static void DoHScroll(thePart,thePoint,myHScrollBar,whichWindow)  int thePart;  Point thePoint;  ControlHandle myHScrollBar;  WindowPtr whichWindow;  {   /*==============================================================*/   /* If the indicator is being dragged, then track the mouse with */   /* no action procedure and then adjust text to new setting.     */   /*==============================================================*/   if (thePart == inThumb)     {      thePart = TrackControl(myHScrollBar,thePoint,(ControlProcPtr) NULL);      EditAdjustText(whichWindow);     }   /*================================================*/   /* else track the mouse with a continuous scroll. */   /*================================================*/   else     {      TempWindow = whichWindow;      thePart = TrackControl(myHScrollBar,thePoint,(ControlProcPtr) ScrollHTextRef);     }  }/********************************************************//* ScrollHText: Scroll text horizontally within window. *//********************************************************/pascal void ScrollHText(  ControlHandle theControl,  short int thePart)  {   int delta;   int oldValue;   switch(thePart)     {      /*===============================*/      /* Scroll up one line at a time. */      /*===============================*/      case inUpButton:        delta = -1;        break;      /*=================================*/      /* Scroll down one line at a time. */      /*=================================*/      case inDownButton:        delta = 1;        break;      /*========================================*/      /* Scroll up by height of text rectangle. */      /*========================================*/      case inPageUp:        delta = (((**TempText).viewRect.left - (**TempText).viewRect.right)                 / HORIZONTAL_SCROLL_INCREMENT) + 1;        break;      /*==========================================*/      /* Scroll down by height of text rectangle. */      /*==========================================*/      case inPageDown:        delta = (((**TempText).viewRect.right - (**TempText).viewRect.left)                 / HORIZONTAL_SCROLL_INCREMENT) - 1;        break;      default:        break;     }   /*===========================================================*/   /* If the mouse is still in the original part, then get the  */   /* old setting, adjust by the scroll amount, and scroll text */   /* to match the new setting.                                 */   /*===========================================================*/   if (thePart != 0)     {      oldValue = GetCtlValue(theControl);      SetCtlValue(theControl,oldValue + delta);      EditAdjustText(TempWindow);     }  }/********************************************************//* DoSelect: Handle mouse-down event in text rectangle. *//********************************************************/static void DoSelect(thePoint,myText,whichWindow,myEvent,myVScrollBar,myHScrollBar)  Point thePoint;  TEHandle myText;  WindowPtr whichWindow;  EventRecord *myEvent;  ControlHandle myVScrollBar;  ControlHandle myHScrollBar;  {   int extendIt;   /*==============================================*/   /* Set up parameters for select pascal routine. */   /*==============================================*/   TempWindow = whichWindow;   TempText = myText;   TempVScrollBar = myVScrollBar;   TempHScrollBar = myHScrollBar;   /*========================*/   /* Is the shift key down? */   /*========================*/   extendIt = (BitAnd(myEvent->modifiers,shiftKey) != 0);   /*====================*/   /* Do text selection. */   /*====================*/   TEClick(thePoint,extendIt,myText);  }/**********************************************************************//* EditAdjustText: Adjust text within window to match scroll bar setting. *//**********************************************************************/void EditAdjustText(whichWindow)  WindowPtr whichWindow;  {   int oldVScroll, oldHScroll;   int newVScroll, newHScroll;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*====================================*/   /* Get the current offset and use the */   /* scroll bar to get the new offset.  */   /*====================================*/   oldVScroll = (**myText).viewRect.top - (**myText).destRect.top;   newVScroll = GetCtlValue(myVScrollBar) * (**myText).lineHeight;   oldHScroll = (**myText).viewRect.left - (**myText).destRect.left                + TEXT_MARGIN;   newHScroll = GetCtlValue(myHScrollBar) * HORIZONTAL_SCROLL_INCREMENT;   /*==============================================================*/   /* Scroll by the difference. Note that if TEScroll is called    */   /* with a value of zero, there is a bug which then prevents the */   /* the insertion point from blinking properly. Hence the check  */   /* for oldScroll equal to newScroll.                            */   /*==============================================================*/   if (((oldVScroll - newVScroll) != 0) ||       ((oldHScroll - newHScroll) != 0))     { TEScroll((oldHScroll - newHScroll),(oldVScroll - newVScroll),myText); }   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock((Handle) myText);  }/***************************************************************//* ScrollToSelection: Scroll current text selection into view. *//***************************************************************/void ScrollToSelection(toMiddle,whichWindow)  int toMiddle;  WindowPtr whichWindow;  {   int topLine;   int bottomLine;   int windowHeight;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*=======================================================*/   /* Get the current top line, the window height in lines, */   /* and the line beyond the bottom of the window.         */   /*=======================================================*/   topLine = GetCtlValue(myVScrollBar);   windowHeight = ( (**myText).viewRect.bottom - (**myText).viewRect.top) /                  (**myText).lineHeight;   bottomLine = topLine + windowHeight;   if (((**myText).teLength > 0) &&       ((*((**myText).hText))[(**myText).teLength-1] == MAC_CR))     { bottomLine -= 1; }   /*=================================================*/   /* If there is not enough text to fill the window, */   /* then just the text at the top of the window.    */   /*=================================================*/   if (GetCtlMax(myVScrollBar) == 0)     { EditAdjustText(whichWindow); }   /*=================================================================*/   /* Else if the whole selection is above the window, move the start */   /* of the selection either to the top or middle of the window.     */   /*=================================================================*/   else if ( (**myText).selEnd < (**myText).lineStarts[topLine] )     {      if (toMiddle)        { ScrollCharacter((**myText).selStart,TO_MIDDLE,myText,whichWindow,myVScrollBar); }      else        { ScrollCharacter((**myText).selStart,TO_TOP,myText,whichWindow,myVScrollBar); }     }   /*================================================================*/   /* Else if the whole selection is below the window, move the end  */   /* of the selection either to the bottom or middle of the window. */   /*================================================================*/   else if ( (**myText).selStart >= (**myText).lineStarts[bottomLine] )     {      if (toMiddle)        { ScrollCharacter((**myText).selEnd,TO_MIDDLE,myText,whichWindow,myVScrollBar); }      else        { ScrollCharacter((**myText).selEnd,TO_BOTTOM,myText,whichWindow,myVScrollBar); }     }   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock( (Handle) myText);  }/*************************************************************//* AdjustScrollBar: Adjust scroll bar to length of document. *//*************************************************************/void AdjustScrollBar(whichWindow)  WindowPtr whichWindow;  {   int windowHeight, windowWidth;   int maxTop;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   if (myVScrollBar != NULL)     {      /*========================*/      /* Get the window height. */      /*========================*/      windowHeight = ((**myText).viewRect.bottom - (**myText).viewRect.top) /                      (**myText).lineHeight;      /*==================================*/      /* Avoid white space at the bottom. */      /*==================================*/      maxTop = (**myText).nLines - windowHeight;      /*=============================================================*/      /* If last character in edit record is a carriage return, then */      /* add one to the total number of lines in the document.       */      /*=============================================================*/      if (((**myText).teLength > 0) &&          ((*((**myText).hText))[(**myText).teLength-1] == MAC_CR))        { maxTop += 1; }      /*===================================================*/      /* If the text is smaller than the window, then show */      /* all of the text and disable the scroll bar, else  */      /* enable the scroll bar.                            */      /*===================================================*/      if (maxTop <= 0)        {         maxTop = 0;         HiliteControl(myVScrollBar,INACTIVE_VALUE);        }      else        {          if (whichWindow == FrontWindow())           { HiliteControl(myVScrollBar,ACTIVE_VALUE); }         else           { HiliteControl(myVScrollBar,INACTIVE_VALUE); }        }      /*=====================================*/      /* Adjust the range of the scroll bar. */      /*=====================================*/      SetCtlMax(myVScrollBar,maxTop);     }   if (myHScrollBar != NULL)     {      /*========================*/      /* Get the window width. */      /*========================*/      windowWidth = ((**myText).viewRect.right - (**myText).viewRect.left) /                      HORIZONTAL_SCROLL_INCREMENT;      /*==================================*/      /* Avoid white space at the bottom. */      /*==================================*/      maxTop = (VIRTUAL_HORIZONTAL_WIDTH / HORIZONTAL_SCROLL_INCREMENT)               - windowWidth;      /*===================================================*/      /* If the text is smaller than the window, then show */      /* all of the text and disable the scroll bar, else  */      /* enable the scroll bar.                            */      /*===================================================*/      if (maxTop <= 0)        {         maxTop = 0;         HiliteControl(myHScrollBar,INACTIVE_VALUE);        }      else        {          if (whichWindow == FrontWindow())           { HiliteControl(myHScrollBar,ACTIVE_VALUE); }         else           { HiliteControl(myHScrollBar,INACTIVE_VALUE); }        }      /*=====================================*/      /* Adjust the range of the scroll bar. */      /*=====================================*/      SetCtlMax(myHScrollBar,maxTop);     }  }/************************************************//* ScrollCharacter: Scroll character into view. *//************************************************/void ScrollCharacter(theCharacter,toWhere,myText,whichWindow,myVScrollBar)  int theCharacter;  int toWhere;  TEHandle myText;  WindowPtr whichWindow;  ControlHandle myVScrollBar;  {   int theLine;   int windowHeight;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*=========================================================*/   /* Find the line containing the character. If scrolling to */   /* top, then this line should be at the top of the window. */   /*=========================================================*/   theLine = 0;   while ((**myText).lineStarts[theLine+1] <= theCharacter)     { theLine = theLine + 1; }   /*===================================*/   /* If scrolling to bottom of window, */   /* then offset by the window height. */   /*===================================*/   if (toWhere == TO_BOTTOM)     {      windowHeight = ((**myText).viewRect.bottom - (**myText).viewRect.top) /                     (**myText).lineHeight;      theLine = theLine - (windowHeight - 1);     }   /*=============================================*/   /* Else if scrolling to middle of window, then */   /* offset by half of the window height.        */   /*=============================================*/   else if (toWhere == TO_MIDDLE)     {      windowHeight = ((**myText).viewRect.bottom - (**myText).viewRect.top) /                     (**myText).lineHeight;      theLine = theLine - ((windowHeight - 1) / 2);     }   /*===================================*/   /* Adjust setting of the scroll bar. */   /*===================================*/   SetCtlValue(myVScrollBar,theLine);   /*===================================*/   /* Scroll text to match new setting. */   /*===================================*/   EditAdjustText(whichWindow);   /*=====================*/   /* Unlock edit record. */   /*=====================*/   HUnlock( (Handle) myText);  }/*****************************************************************//* AutoScroll: Handle automatic scrolling during text selection. *//*****************************************************************/pascal Boolean AutoScroll()  {   Point mousePoint;   Rect textRect;   RgnHandle saveClip;   /*=============================================================*/   /* Create a temporary region and save the existing clip region */   /* in it. Clip to the entire port rectangle.                   */   /*=============================================================*/   saveClip = NewRgn();   GetClip(saveClip);   ClipRect(&(*TempWindow).portRect);   /*=====================================================*/   /* Find the mouse location and get the text rectangle. */   /*=====================================================*/   GetMouse(&mousePoint);   textRect = (**TempText).viewRect;   /*=================================================*/   /* If the mouse is above the top of the rectangle, */   /* then scroll up one line.                        */   /*=================================================*/   if (mousePoint.v < textRect.top)     { ScrollVText(TempVScrollBar,inUpButton); }   /*==============================================*/   /* Else if the mouse is below the bottom of the */   /* rectangle, then scroll down one line.        */   /*==============================================*/   else if (mousePoint.v > textRect.bottom)     { ScrollVText(TempVScrollBar,inDownButton); }   /*===============================================*/   /* If the mouse is to the left of the rectangle, */   /* then scroll left.                             */   /*===============================================*/   if (mousePoint.h < textRect.left)     { ScrollHText(TempHScrollBar,inUpButton); }   /*==========================================*/   /* Else if the mouse is to the right of the */   /* rectangle, then scroll right.            */   /*==========================================*/   else if (mousePoint.h > textRect.right)     { ScrollHText(TempHScrollBar,inDownButton); }   /*======================================*/   /* Restore the original clipping region */   /* and dispose of the temporary region. */   /*======================================*/   SetClip(saveClip);   DisposeRgn(saveClip);   /*=============================================*/   /* Return TRUE to continue tracking the mouse. */   /*=============================================*/   return((char) TRUE);  }/************************************************//* ShowEditEnd: Sets the edit window's vertical *//*   scroll bar to its maximum value so that    *//*   the end of the file is visible.            *//************************************************/void ShowEditEnd(  WindowPtr whichWindow,  Boolean forceUpdate)  {   EWDHandle theData;   Handle dataHandle;   ControlHandle theVScrollBar;      /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*===================================*/   /* Retrieve pointers to the window's */   /* vertical scroll bar.              */   /*===================================*/   theVScrollBar = (**theData).windowInfo.vScrollBar;      /*==========================================*/   /* Set the scroll bar to its maximum value. */   /*==========================================*/      if (forceUpdate ||       (GetCtlValue(theVScrollBar) != GetCtlMax(theVScrollBar)))     {      SetCtlValue(theVScrollBar,GetCtlMax(theVScrollBar));      InvalRect(&whichWindow->portRect);      FixText(whichWindow);      UpdateEditWindow(whichWindow);     }        /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/**************************************************//* ShowEditBegin: Sets the edit window's vertical *//*   scroll bar to its minimum value so that      *//*   the beginning of the file is visible.        *//**************************************************/void ShowEditBegin(  WindowPtr whichWindow,  Boolean forceUpdate)  {   EWDHandle theData;   Handle dataHandle;   ControlHandle theVScrollBar;      /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*===================================*/   /* Retrieve pointers to the window's */   /* vertical scroll bar.              */   /*===================================*/   theVScrollBar = (**theData).windowInfo.vScrollBar;      /*==========================================*/   /* Set the scroll bar to its maximum value. */   /*==========================================*/      if (forceUpdate ||       (GetCtlValue(theVScrollBar) != GetCtlMin(theVScrollBar)))     {      SetCtlValue(theVScrollBar,GetCtlMin(theVScrollBar));      InvalRect(&whichWindow->portRect);      FixText(whichWindow);      UpdateEditWindow(whichWindow);     }        /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }  /*************************************************************//* DisplayKeyBoardScroll: Handles scrolling of the display   *//*   window for use with the page up, page down, down arrow, *//*   up arrow, right arrow, and left arrow keys.             *//*************************************************************/void EditKeyBoardScroll(  WindowPtr whichWindow,  int cntlCode)  {   int locVal;   int howMuch;   TEHandle theText;   EWDHandle theData;   Handle dataHandle;   ControlHandle theControl;    /*=========================================*/   /* Get a pointer to the window's text edit */   /* record and vertical scroll bar.         */   /*=========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   theControl = (**theData).windowInfo.vScrollBar;   /*=========================================*/   /* Determine how much scrolling is needed. */   /*=========================================*/      switch (cntlCode)     {      case inPageUp:        howMuch = (((**theText).viewRect.top - (**theText).viewRect.bottom)                   / (**theText).lineHeight) + 1;        break;              case inPageDown:        howMuch = (((**theText).viewRect.bottom - (**theText).viewRect.top)                   / (**theText).lineHeight) - 1;        break;              default:        Bogus(TRUE);        break;     }        /*=========================*/   /* Scroll the edit buffer. */   /*=========================*/        locVal = GetCtlValue(theControl);   SetCtlValue(theControl,locVal + howMuch);   EditAdjustText(whichWindow);      /*==============================*/   /* Unlock the edit window data. */   /*==============================*/      HUnlock(dataHandle);  }  /**************************************//* CreateConstructListMenu:           *//**************************************/static Boolean CreateConstructListMenu(  TEHandle theText,  long *lineCounts)  {   Handle selectionHandle;   char *selectionPointer, *str;   long int selectionLength, i;   int depth = 0;   struct token theToken;   long theLine, currentPosition = 0;      /*==============================================*/   /* Delete the menu items in the construct list. */   /*==============================================*/      lineCounts[0] = -1;   while (CountMenuItems(ConstructListMenu))     { DeleteMenuItem(ConstructListMenu,1); }   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) theText);   /*===============================================*/   /* Get the length of the selection to be loaded. */   /*===============================================*/   selectionLength = (**theText).teLength;   /*==============================================*/   /* Selected text should not be larger than 32K. */   /*==============================================*/   if (selectionLength != (int) selectionLength)     {      SysBeep(10);      HUnlock((Handle) theText);      return(false);     }   /*========================================*/   /* If no text is selected, simply return. */   /*========================================*/   if (selectionLength <= 0)     {      AppendMenu(ConstructListMenu,"\pNone Found");      HUnlock((Handle) theText);      return(false);     }   /*=====================================================*/   /* Get the text handle of the edit record and lock it. */   /*=====================================================*/   selectionHandle = (**theText).hText;   HLock(selectionHandle);   /*=======================================================*/   /* Get a pointer to the beginning of the text selection. */   /*=======================================================*/   selectionPointer = *selectionHandle;   /*===============================================*/   /* Allocate enough memory to copy the string. If */   /* memory cannot be allocated, then return.      */   /*===============================================*/   str = (char *) gm2( (int) selectionLength + 1);   if (str == NULL)     {      HUnlock(selectionHandle);      HUnlock((Handle) theText);      return(false);     }   /*==========================*/   /* Copy the selection text. */   /*==========================*/   for (i = 0 ; i < selectionLength ; i++)     { str[i] = selectionPointer[i]; }   str[i] = '\0';   /*=========================================*/   /* Unlock text handle and the edit record. */   /*=========================================*/   HUnlock(selectionHandle);   HUnlock((Handle) theText);         /*==================*/   /* Create the menu. */   /*==================*/          ResetLineCount();    LineCountRouter = MenuLogicalName;   FastCharGetRouter = MenuLogicalName;   FastCharGetIndex = 0;   FastCharGetString = str;      while (TRUE)     {      GetToken(MenuLogicalName,&theToken);            if (theToken.type == STOP)         {         FastCharGetRouter = NULL;         FastCharGetIndex = 0;         FastCharGetString = NULL;         rm(str,(int) selectionLength + 1);         LineCountRouter = NULL;         if (currentPosition == 0)           { AppendMenu(ConstructListMenu,"\pNone Found"); }         return(true);        }         if (theToken.type == RPAREN)        {          if (depth > 0) depth--;          continue;        }              if (theToken.type != LPAREN) continue;            depth++;      if (depth != 1) continue;            GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) continue;            theLine = GetLineCount();            if (AddConstructToMenu(ValueToString(theToken.value)))        {         if (currentPosition < MAX_CONSTRUCT_LIST_SIZE)           { lineCounts[currentPosition++] = theLine; }        }     }      return(true);  }/**************************************//* AddConstructToMenu:           *//**************************************/static Boolean AddConstructToMenu(  char *theConstructType)  {   struct token theToken;   Str255 menuItemName;      strncpy((char *) menuItemName,theConstructType,250);   strcat((char *) menuItemName," ");            if (strcmp(theConstructType,"defmessage-handler") == 0)     {      GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));       strcat((char *) menuItemName," ");      GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));      }   else if (strcmp(theConstructType,"defglobal") == 0)     {      GetToken(MenuLogicalName,&theToken);      if (theToken.type != GBL_VARIABLE) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));     }   else if (strcmp(theConstructType,"defmethod") == 0)     {      GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));               GetToken(MenuLogicalName,&theToken);        if (theToken.type != LPAREN) return(false);                     GetToken(MenuLogicalName,&theToken);      while (theToken.type != RPAREN)        {         if (theToken.type != LPAREN) return(false);                  GetToken(MenuLogicalName,&theToken);         if (theToken.type != SF_VARIABLE) return(false);                  GetToken(MenuLogicalName,&theToken);         if (theToken.type != SYMBOL) return(false);         strcat((char *) menuItemName," ");                  strncat((char *) menuItemName,theToken.printForm,                  250 - (strlen((char *) menuItemName + 1)));                   GetToken(MenuLogicalName,&theToken);         if (theToken.type != RPAREN) return(false);                   GetToken(MenuLogicalName,&theToken);                }      }   else if ((strcmp(theConstructType,"defrule") == 0) ||            (strcmp(theConstructType,"deffacts") == 0) ||            (strcmp(theConstructType,"deftemplate") == 0) ||            (strcmp(theConstructType,"deffunction") == 0) ||            (strcmp(theConstructType,"defgeneric") == 0) ||            (strcmp(theConstructType,"defclass") == 0) ||            (strcmp(theConstructType,"definstances") == 0))     {      GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));     }   else if (FindConstruct(theConstructType) != NULL)     {      GetToken(MenuLogicalName,&theToken);      if (theToken.type != SYMBOL) return(false);            strncat((char *) menuItemName,theToken.printForm,               250 - strlen((char *) menuItemName));     }   else     { return(false); }              CTOPSTR((char *) menuItemName);   AppendMenu(ConstructListMenu,menuItemName);   return(true);  }                              