   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                UNDO COMMAND MODULE                  */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _UNDO_SOURCE_#include <string.h>#include <stdlib.h>#include <OSUtils.h>#include <Memory.h>#include <Menus.h>#include <TextEdit.h>#include <Windows.h>#include <Events.h>#include <Controls.h>#include "editscrl.h"#include "editw.h"#include "undo.h"#include "menuhndl.h"#include "stnrdmac.h"/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   SaveUndoTypingCharacter(char,TEHandle,                                                         struct undoEditInfo *);   static void                   UndoTyping(WindowPtr,TEHandle,struct undoEditInfo *);   static void                   RedoTyping(WindowPtr,TEHandle,struct undoEditInfo *);   static void                   InitializeUndoTypingInformation(WindowPtr,TEHandle,                                                                 struct undoEditInfo *);   static void                   ReverseString(char *);   static void                   UndoEdit(WindowPtr,TEHandle,int,int,struct undoEditInfo *);   static void                   RedoEdit(WindowPtr,TEHandle,int,int,struct undoEditInfo *);   static char                  *AddCharToString(int,char *,int *,int *,int);   static void                   MarkUndoItem(int);   static void                   UndoDragCopy(TEHandle,struct undoEditInfo *);   static void                   UndoDragMove(TEHandle,struct undoEditInfo *);/*****************************************************//* SaveUndoInfo: Saves the information necessary for *//*   undoing the Cut, Paste, and Clear edit command. *//*****************************************************/void SaveUndoInfo(  WindowPtr whichWindow,  TEHandle ThisTEH,  int theOperation,  long int dragInsertPosition,  long int dragSize,  char *theDragText)  {   Handle textHandle;   Ptr textPtr;      EWDHandle theData;   Handle dataHandle;   /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;      /*=============================================*/   /* Clear the currently saved undo information. */   /*=============================================*/   if ((*theData)->undoInfo.previousSelection != NULL)      { DisposHandle((*theData)->undoInfo.previousSelection); }        if ((*theData)->undoInfo.copyOfScrap != NULL)      { DisposHandle((*theData)->undoInfo.copyOfScrap); }      /*=============================*/   /* Copy the current selection. */   /*=============================*/   if (theOperation != UNDRAG_COPY)     {      HLock((Handle) ThisTEH);      textHandle = (**ThisTEH).hText;      HLock(textHandle);      textPtr = *textHandle;      textPtr = &textPtr[(**ThisTEH).selStart];      PtrToHand(textPtr,&(*theData)->undoInfo.previousSelection,                (**ThisTEH).selEnd - (**ThisTEH).selStart);      HUnlock(textHandle);      HUnlock((Handle) ThisTEH);     }   else     {      PtrToHand(theDragText,&(*theData)->undoInfo.previousSelection,                dragSize);     }   /*==================================*/   /* Save the start and end positions */   /* of the current selection.        */   /*==================================*/   (*theData)->undoInfo.previousStart = (**ThisTEH).selStart;   (*theData)->undoInfo.previousEnd = (**ThisTEH).selEnd;   /*===========================*/   /* Make a copy of the scrap. */   /*===========================*/   (*theData)->undoInfo.copyOfScrap = TEScrapHandle();   HandToHand(&(*theData)->undoInfo.copyOfScrap);      /*======================================*/   /* Save information for undoing a drag. */   /*======================================*/      (*theData)->undoInfo.dragSize = dragSize;      if (theOperation == UNDRAG_COPY)     {      (*theData)->undoInfo.dragNewLocation = dragInsertPosition;      (*theData)->undoInfo.dragOldLocation = dragInsertPosition;     }   else if (theOperation == UNDRAG_MOVE)     {      if (dragInsertPosition >= (**ThisTEH).selEnd)        {         (*theData)->undoInfo.dragNewLocation = dragInsertPosition - dragSize;         (*theData)->undoInfo.dragOldLocation = (**ThisTEH).selStart;        }      else if (dragInsertPosition <= (**ThisTEH).selStart)        {         (*theData)->undoInfo.dragNewLocation = dragInsertPosition;         (*theData)->undoInfo.dragOldLocation = (**ThisTEH).selStart;        }      else        { SysBeep(20); }     }        /*=========================================*/   /* Save the start and end positions of the */   /* selection after the edit operation.     */   /*=========================================*/   switch(theOperation)     {      case UNPASTE:        (*theData)->undoInfo.newStart = (**ThisTEH).selStart;        (*theData)->undoInfo.newEnd = (*theData)->undoInfo.newStart + TEGetScrapLen();        break;              case UNDRAG_COPY:      case UNDRAG_MOVE:        //(*theData)->undoInfo.newStart = (**ThisTEH).selStart;        //(*theData)->undoInfo.newEnd = (**ThisTEH).selEnd;        (*theData)->undoInfo.newStart = (*theData)->undoInfo.dragNewLocation;        (*theData)->undoInfo.newEnd = (*theData)->undoInfo.newStart + dragSize;         break;      case UNCUT:      case UNCLEAR:      case UNTYPING:      case UNDRAG_TRASH:        (*theData)->undoInfo.newStart = (**ThisTEH).selStart;        (*theData)->undoInfo.newEnd = (*theData)->undoInfo.newStart;        break;     }   /*==================================*/   /* Mark the positions for selection */   /* after undo and redo operations.  */   /*==================================*/   (*theData)->undoInfo.undoStart = (*theData)->undoInfo.previousStart;   (*theData)->undoInfo.undoEnd = (*theData)->undoInfo.previousEnd;   (*theData)->undoInfo.redoStart = (*theData)->undoInfo.newStart;   (*theData)->undoInfo.redoEnd = (*theData)->undoInfo.newEnd;         /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/*******************************************//* DoUndo: Handle Undo/Redo <...> command. */ /*******************************************/void DoUndo(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle thisText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   thisText = (**theData).editRec;   switch((*theData)->undoInfo.editOperation)     {      case NO_EDIT:        break;      case UNPASTE:        UndoEdit(whichWindow,thisText,UNPASTE,REPASTE,&(*theData)->undoInfo);        break;      case REPASTE:        RedoEdit(whichWindow,thisText,REPASTE,UNPASTE,&(*theData)->undoInfo);        break;      case UNCUT:        UndoEdit(whichWindow,thisText,UNCUT,RECUT,&(*theData)->undoInfo);        break;      case RECUT:        RedoEdit(whichWindow,thisText,RECUT,UNCUT,&(*theData)->undoInfo);        break;      case UNCLEAR:        UndoEdit(whichWindow,thisText,UNCLEAR,RECLEAR,&(*theData)->undoInfo);        break;      case RECLEAR:        RedoEdit(whichWindow,thisText,RECLEAR,UNCLEAR,&(*theData)->undoInfo);        break;      case UNTYPING:        UndoTyping(whichWindow,thisText,&(*theData)->undoInfo);        break;      case RETYPING:        RedoTyping(whichWindow,thisText,&(*theData)->undoInfo);        break;              case UNDRAG_COPY:        UndoEdit(whichWindow,thisText,UNDRAG_COPY,REDRAG_COPY,&(*theData)->undoInfo);        break;              case REDRAG_COPY:        RedoEdit(whichWindow,thisText,REDRAG_COPY,UNDRAG_COPY,&(*theData)->undoInfo);        break;           case UNDRAG_MOVE:        UndoEdit(whichWindow,thisText,UNDRAG_MOVE,REDRAG_MOVE,&(*theData)->undoInfo);        break;              case REDRAG_MOVE:        RedoEdit(whichWindow,thisText,REDRAG_MOVE,UNDRAG_MOVE,&(*theData)->undoInfo);        break;                    case UNDRAG_TRASH:        UndoEdit(whichWindow,thisText,UNDRAG_TRASH,REDRAG_TRASH,&(*theData)->undoInfo);        break;              case REDRAG_TRASH:        RedoEdit(whichWindow,thisText,REDRAG_TRASH,UNDRAG_TRASH,&(*theData)->undoInfo);        break;     }   /*==================================================*/   /* Adjust scroll bar to length of text, adjust text */   /* to match scroll bar, and keep selection visible. */   /*==================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(false,whichWindow);   ResetShiftSelectionAnchor(whichWindow);  }/******************************************************//* UndoEdit: Performs needed changes to the specified *//*   text edit record to undo an operation.           *//******************************************************/static void UndoEdit(  WindowPtr whichWindow,  TEHandle ThisTEH,  int undoOperation,   int redoOperation,  struct undoEditInfo *undoInfo)  {   undoInfo->redoStart = (**ThisTEH).selStart;   undoInfo->redoEnd = (**ThisTEH).selEnd;   /*=============================================*/   /* Undo a drag operation where the drag source */   /* and destination windows are different.      */   /*=============================================*/      if (undoOperation == UNDRAG_COPY)     {      UndoDragCopy(ThisTEH,undoInfo);         TESetSelect(undoInfo->undoStart,undoInfo->undoEnd,ThisTEH);      SetUndoItem(whichWindow,redoOperation);      return;     }    /*=============================================*/   /* Undo a drag operation where the drag source */   /* and destination windows are the same.       */   /*=============================================*/      if (undoOperation == UNDRAG_MOVE)     {      UndoDragMove(ThisTEH,undoInfo);      TESetSelect(undoInfo->undoStart,undoInfo->undoEnd,ThisTEH);      SetUndoItem(whichWindow,redoOperation);      return;     }        TESetSelect(undoInfo->newStart,undoInfo->newEnd,ThisTEH);   if (undoOperation == UNPASTE)     {      TEDelete(ThisTEH);      TESetSelect(undoInfo->previousStart,undoInfo->previousStart,ThisTEH);     }   HLock(undoInfo->previousSelection);   TEInsert(*undoInfo->previousSelection,            GetHandleSize(undoInfo->previousSelection),            ThisTEH);   HUnlock(undoInfo->previousSelection);   if (undoOperation == UNCUT)     {      TESetScrapLen(GetHandleSize(undoInfo->copyOfScrap));      BlockMove(*undoInfo->copyOfScrap,*TEScrapHandle(),TEGetScrapLen());     }   TESetSelect(undoInfo->undoStart,undoInfo->undoEnd,ThisTEH);       SetUndoItem(whichWindow,redoOperation);  }/******************************************************//* UndoDragCopy: Undo a drag operation where the drag *//*   source and destination windows are different.    *//******************************************************/static void UndoDragCopy(  TEHandle thisTEH,  struct undoEditInfo *undoInfo)  {   TESetSelect(undoInfo->dragNewLocation,undoInfo->dragNewLocation +                                          undoInfo->dragSize,thisTEH);   TEDelete(thisTEH);   TESetSelect(undoInfo->previousStart,undoInfo->previousStart,thisTEH);  }     /******************************************************//* UndoDragMove: Undo a drag operation where the drag *//*   source and destination windows are the same.     *//******************************************************/static void UndoDragMove(  TEHandle ThisTEH,  struct undoEditInfo *undoInfo)  {   TESetSelect(undoInfo->dragNewLocation,               undoInfo->dragNewLocation + undoInfo->dragSize,ThisTEH);   TEDelete(ThisTEH);   TESetSelect(undoInfo->dragOldLocation,undoInfo->dragOldLocation,ThisTEH);   HLock(undoInfo->previousSelection);   TEInsert(*undoInfo->previousSelection,            GetHandleSize(undoInfo->previousSelection),ThisTEH);   HUnlock(undoInfo->previousSelection);  }     /******************************************************//* RedoEdit: Performs needed changes to the specified *//*   text edit record to redo an operation.           *//******************************************************/static void RedoEdit(  WindowPtr whichWindow,  TEHandle ThisTEH,  int redoOperation,   int undoOperation,  struct undoEditInfo *undoInfo)  {   undoInfo->undoStart = (**ThisTEH).selStart;   undoInfo->undoEnd = (**ThisTEH).selEnd;   if (redoOperation == REDRAG_COPY)     {      TESetSelect(undoInfo->dragNewLocation,undoInfo->dragNewLocation,ThisTEH);      HLock(undoInfo->previousSelection);      TEInsert(*undoInfo->previousSelection,               GetHandleSize(undoInfo->previousSelection),ThisTEH);      HUnlock(undoInfo->previousSelection);      SetUndoItem(whichWindow,undoOperation);      TESetSelect(undoInfo->redoStart,undoInfo->redoEnd,ThisTEH);      return;     }     if (redoOperation == REDRAG_MOVE)     {      TESetSelect(undoInfo->dragOldLocation,                  undoInfo->dragOldLocation + undoInfo->dragSize,                  ThisTEH);      TEDelete(ThisTEH);            TESetSelect(undoInfo->dragNewLocation,undoInfo->dragNewLocation,ThisTEH);                        HLock(undoInfo->previousSelection);      TEInsert(*undoInfo->previousSelection,               GetHandleSize(undoInfo->previousSelection),ThisTEH);      HUnlock(undoInfo->previousSelection);                  SetUndoItem(whichWindow,undoOperation);      TESetSelect(undoInfo->redoStart,undoInfo->redoEnd,ThisTEH);      return;     }        TESetSelect(undoInfo->previousStart,undoInfo->previousEnd,ThisTEH);   switch (redoOperation)     {      case RECUT:        TECut(ThisTEH);        break;      case RECLEAR:      case REDRAG_TRASH:        TEDelete(ThisTEH);        break;              case REDRAG_COPY:        break;      case REPASTE:        TEDelete(ThisTEH);        HLock(undoInfo->copyOfScrap);        TEInsert(*undoInfo->copyOfScrap,                 GetHandleSize(undoInfo->copyOfScrap),                 ThisTEH);        HUnlock(undoInfo->copyOfScrap);        break;     }   TESetSelect(undoInfo->redoStart,undoInfo->redoEnd,ThisTEH);   SetUndoItem(whichWindow,undoOperation);  }/*************************************//* FixUndoMenuItem: Updates the undo *//*   menu item for editing buffers.  *//*************************************/void FixUndoMenuItem(  WindowPtr whichWindow)  {   EWDHandle theData;   Handle dataHandle;      /*=================================*/   /* If there's no frontmost window, */   /* leave the undo item as it is.   */   /*=================================*/               if (whichWindow == NULL)      {      MarkUndoItem(NO_EDIT);      return;     }   /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;      /*==================*/   /* Update the menu. */   /*==================*/        MarkUndoItem((*theData)->undoInfo.editOperation);      if ((*theData)->undoInfo.editOperation != NO_EDIT)     { EnableStandardMenuItem(STANDARD_MENU_ITEM_UNDO); }        /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/***********************************************//* SetUndoItem: *//***********************************************/void SetUndoItem(  WindowPtr whichWindow,  int value)  {   EWDHandle theData;   Handle dataHandle;      if (whichWindow == NULL)     { return; }        /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;        /*===========================*/   /* Update the window's data. */   /*===========================*/      (*theData)->undoInfo.editOperation = value;   MarkUndoItem(value);      /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/*************************************************//* MarkUndoItem: Sets the text of the Undo item  *//*   in the Edit menu to indicate the particular *//*   operation that will be undone/redone.       *//*************************************************/static void MarkUndoItem(  int value)  {   switch (value)     {      case NO_EDIT:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo");        break;      case UNPASTE:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo Paste");        break;      case REPASTE:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pRedo Paste");        break;      case UNCUT:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo Cut");        break;      case RECUT:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pRedo Cut");        break;      case UNCLEAR:      case UNDRAG_TRASH:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo Clear");        break;      case RECLEAR:      case REDRAG_TRASH:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pRedo Clear");        break;      case UNTYPING:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo Typing");        break;      case RETYPING:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pRedo Typing");        break;              case UNDRAG_COPY:      case UNDRAG_MOVE:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pUndo Drag");        break;              case REDRAG_COPY:      case REDRAG_MOVE:        SetStandardMenuItem(STANDARD_MENU_ITEM_UNDO,(StringPtr) "\pRedo Drag");        break;     }  }/********************************************************************//* ProcessUndoCharacter: Keeps track of characters for undo typing. *//********************************************************************/void ProcessUndoCharacter(  char ch,  TEHandle ThisTEH,  WindowPtr whichWindow)  {   int selStart, selEnd;   EWDHandle theData;   Handle dataHandle;   /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*====================*/   /* Ignore arrow keys. */   /*====================*/   if ((ch == LEFT_ARROW_KEY) || (ch == RIGHT_ARROW_KEY) ||       (ch == UP_ARROW_KEY) || (ch == DOWN_ARROW_KEY)) return;   /*======================================================*/   /* Get the current text selection start and end points. */   /*======================================================*/   selEnd = (**ThisTEH).selEnd;   selStart = (**ThisTEH).selStart;   /*==================================================*/   /* If there is a selection, or typing starts off at */   /* a new point in a window, or an undo operation    */   /* other than undo typing was in effect, then       */   /* reinitialize the undo typing information.        */   /*==================================================*/   if ((selEnd != selStart) ||       (selStart != (*theData)->undoInfo.typingContinueStart) ||       ((*theData)->undoInfo.editOperation != UNTYPING))     { InitializeUndoTypingInformation(whichWindow,ThisTEH,&(*theData)->undoInfo); }   /*=======================================================*/   /* Save the information about the character being typed. */   /* Save backspace information only if a selection is not */   /* being deleted and the cursor is not at the beginning  */   /* of the buffer.                                        */   /*=======================================================*/   if (ch == '\b')     {      if ((selStart == selEnd) &&           ((*theData)->undoInfo.typingContinueStart > 0))        { SaveUndoTypingCharacter(ch,ThisTEH,&(*theData)->undoInfo); }     }   else     { SaveUndoTypingCharacter(ch,ThisTEH,&(*theData)->undoInfo); }   /*============================================*/   /* Fix the edit menu to indicate undo typing. */   /*============================================*/   SetUndoItem(whichWindow,UNTYPING);   FixUndoMenuItem(whichWindow);       /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/***********************************************//* SaveUndoTypingCharacter: *//***********************************************/static void SaveUndoTypingCharacter(  char theChar,  TEHandle ThisTEH,  struct undoEditInfo *undoInfo)  {   char backupChar;   if (((undoInfo->undoTypingIndex > 0)  && (theChar == '\b')) ||       ((undoInfo->undoTypingIndex >= 0) && (theChar != '\b')))     {      undoInfo->forwardString = AddCharToString(theChar,undoInfo->forwardString,                                                &undoInfo->forwardLength,                                                &undoInfo->forwardMax,                                                undoInfo->forwardMax+80);     }   else if ((theChar == '\b') && (undoInfo->undoTypingIndex <= 0))     {      if (undoInfo->undoTypingIndex == undoInfo->lowestBackupIndex)        {         undoInfo->lowestBackupIndex--;         backupChar = (*(**ThisTEH).hText)[(**ThisTEH).selStart - 1];         undoInfo->oldBackupString =             AddCharToString(backupChar,undoInfo->oldBackupString,                            &undoInfo->oldBackupLength,&undoInfo->oldBackupMax,                            undoInfo->oldBackupMax+80);        }      undoInfo->newBackupString =          AddCharToString(theChar,undoInfo->newBackupString,                         &undoInfo->newBackupLength,&undoInfo->newBackupMax,                         undoInfo->newBackupMax+80);     }   else if ((theChar != '\b') && (undoInfo->undoTypingIndex < 0))     {      undoInfo->newBackupString =          AddCharToString(theChar,undoInfo->newBackupString,                         &undoInfo->newBackupLength,&undoInfo->newBackupMax,                         undoInfo->newBackupMax+80);     }   if (theChar == '\b')     {      undoInfo->undoTypingIndex--;      undoInfo->typingContinueStart--;     }   else     {      undoInfo->undoTypingIndex++;      undoInfo->typingContinueStart++;     }  }/***********************************************//* UndoTyping:  *//***********************************************/static void UndoTyping(  WindowPtr whichWindow,  TEHandle ThisTEH,  struct undoEditInfo *undoInfo)  {   int deleteStart, deleteEnd;   /*===================================================*/   /* Remember selection range for redo typing command. */   /*===================================================*/   undoInfo->redoStart = (**ThisTEH).selStart;   undoInfo->redoEnd = (**ThisTEH).selEnd;   /*==============================*/   /* Delete any newly typed text. */   /*==============================*/   if (undoInfo->undoTypingIndex > 0)     {      deleteEnd = undoInfo->typingContinueStart;      deleteStart = undoInfo->previousStart - undoInfo->oldBackupLength;     }   else     {      deleteStart = undoInfo->previousStart - undoInfo->oldBackupLength;      deleteEnd = undoInfo->previousStart - undoInfo->oldBackupLength +                   undoInfo->newBackupLength;     }   TESetSelect(deleteStart,deleteEnd,ThisTEH);   TEDelete(ThisTEH);   /*===========================*/   /* Restore backed over text. */   /*===========================*/   if (undoInfo->oldBackupLength > 0)     {      TESetSelect(undoInfo->previousStart - undoInfo->oldBackupLength,                  undoInfo->previousStart - undoInfo->oldBackupLength,                  ThisTEH);      ReverseString(undoInfo->oldBackupString);      TEInsert(undoInfo->oldBackupString,undoInfo->oldBackupLength,ThisTEH);      ReverseString(undoInfo->oldBackupString);     }   /*=================================*/   /* Restore the previous selection. */   /*=================================*/   HLock(undoInfo->previousSelection);   TEInsert(*undoInfo->previousSelection,            GetHandleSize(undoInfo->previousSelection),            ThisTEH);   HUnlock(undoInfo->previousSelection);   TESetSelect(undoInfo->undoStart,undoInfo->undoEnd,ThisTEH);   /*===============================*/   /* Set menu item to redo typing. */   /*===============================*/   SetUndoItem(whichWindow,RETYPING);  }/***********************************************//* RedoTyping:  *//***********************************************/static void RedoTyping(  WindowPtr whichWindow,  TEHandle ThisTEH,  struct undoEditInfo *undoInfo)  {   /*===================================================*/   /* Remember selection range for undo typing command. */   /*===================================================*/   undoInfo->undoStart = (**ThisTEH).selStart;   undoInfo->undoEnd = (**ThisTEH).selEnd;   /*========================================*/   /* Delete the old text that was replaced. */   /*========================================*/   TESetSelect(undoInfo->previousStart - undoInfo->oldBackupLength,               undoInfo->previousEnd,ThisTEH);   TEDelete(ThisTEH);   /*===================================*/   /* Put the replacement text back in. */   /*===================================*/   TEInsert(undoInfo->newBackupString,undoInfo->newBackupLength,ThisTEH);   TEInsert(undoInfo->forwardString,undoInfo->forwardLength,ThisTEH);   /*============================*/   /* Reset the selection range. */   /*============================*/   TESetSelect(undoInfo->redoStart,undoInfo->redoEnd,ThisTEH);   /*===============================*/   /* Set menu item to undo typing. */   /*===============================*/   SetUndoItem(whichWindow,UNTYPING);  }/*******************************************//* InitializeUndoTypingInformation:        *//*******************************************/static void InitializeUndoTypingInformation(  WindowPtr whichWindow,  TEHandle ThisTEH,  struct undoEditInfo *undoInfo)  {   if (undoInfo->forwardString != NULL) free(undoInfo->forwardString);   undoInfo->forwardLength = 0;   undoInfo->forwardMax = 0;   undoInfo->forwardString = NULL;   if (undoInfo->oldBackupString != NULL) free(undoInfo->oldBackupString);   undoInfo->oldBackupLength = 0;   undoInfo->oldBackupMax = 0;   undoInfo->oldBackupString = NULL;   if (undoInfo->newBackupString != NULL) free(undoInfo->newBackupString);   undoInfo->newBackupLength = 0;   undoInfo->newBackupMax = 0;   undoInfo->newBackupString = NULL;   undoInfo->lowestBackupIndex = 0;   undoInfo->undoTypingIndex = 0;   undoInfo->typingContinueStart = (**ThisTEH).selStart;   SaveUndoInfo(whichWindow,ThisTEH,UNTYPING,0,0,NULL);  }/*******************************************//* ReverseString:                          *//*******************************************/static void ReverseString(  char *strPtr)  {   int i, length;   char temp;   length = strlen(strPtr);   for (i = 0 ; i < length / 2 ; i ++)     {      temp = strPtr[i];      strPtr[i] = strPtr[length - 1 - i];      strPtr[length - 1 - i] = temp;     }  }/**********************************************************//* AddCharToString:                                      *//**********************************************************/char *AddCharToString(  int inchar,  char *str,  int *max,   int *pos,   int new_size)  {   if (*pos >= (*max - 1))     {      str = realloc(str,new_size);      *max = new_size;     }  if (inchar != '\b')    {     str[*pos] = (char) inchar;     (*pos)++;     str[*pos] = '\0';    }  else    {     if (*pos > 0) (*pos)--;     str[*pos] = '\0';    }   return(str);  }/*=====================================================*//* InitializeUndoEditInfo: Initializes the slot values *//*   usedby the data structure which keeps information *//*   on undoing operations on an editing buffer.       *//*=====================================================*/void InitializeUndoEditInfo(  struct undoEditInfo *theStruct)  {   theStruct->editOperation = NO_EDIT;   theStruct->previousSelection = NULL;   theStruct->copyOfScrap = NULL;   theStruct->previousStart = 0;   theStruct->previousEnd = 0;   theStruct->newStart = 0;   theStruct->newEnd = 0;   theStruct->undoStart = 0;   theStruct->undoEnd = 0;   theStruct->redoStart = 0;   theStruct->redoEnd = 0;   theStruct->dragNewLocation = 0;   theStruct->dragOldLocation = 0;   theStruct->dragSize = 0;   theStruct->typingContinueStart = -1;   theStruct->undoTypingIndex = 0;   theStruct->oldBackupString = NULL;   theStruct->oldBackupLength = 0;   theStruct->oldBackupMax = 0;   theStruct->newBackupString = NULL;   theStruct->newBackupLength = 0;   theStruct->newBackupMax = 0;   theStruct->forwardString = NULL;   theStruct->forwardLength = 0;   theStruct->forwardMax = 0;   theStruct->lowestBackupIndex = 0;  }  /*=========================================================*//* DeallocateUndoEditInfo: Deallocates handles and strings *//*   used by the editing buffer undo data structure.       *//*=========================================================*/void DeallocateUndoEditInfo(  struct undoEditInfo *theStruct)  {   if (theStruct->previousSelection != NULL)      { DisposHandle(theStruct->previousSelection); }        if (theStruct->copyOfScrap != NULL)      { DisposHandle(theStruct->copyOfScrap); }      if (theStruct->oldBackupString != NULL)     { free(theStruct->oldBackupString); }        if (theStruct->newBackupString != NULL)     { free(theStruct->newBackupString); }        if (theStruct->forwardString != NULL)     { free(theStruct->forwardString); }  }