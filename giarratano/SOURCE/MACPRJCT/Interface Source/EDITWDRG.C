   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*               EDIT WINDOW DRAG MODULE               */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _EDITWDRG_SOURCE_#include "setup.h"#include <Drag.h>#include <MixedMode.h>#include "editw.h"#include "editscrl.h"#include "interface.h"#include "stnrdmac.h"#include "undo.h"#include "editwdrg.h"#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static pascal OSErr     DragSendDataHook(FlavorType,void *,ItemReference,DragReference);   static pascal OSErr     DragTrackingHandlerHook(DragTrackingMessage,WindowPtr,                                                   void *,DragReference);   static pascal OSErr     DragReceiveHandlerHook(WindowPtr,void *,DragReference);   static void             DoDragAndDrop(DragReference,char *,Size,WindowPtr);   static void             DrawCaret(short,TEHandle);   static short            TEGetLine(short,TEHandle);   static short            TEIsFrontOfLine(short,TEHandle);   static short            HitTest(Point,TEHandle);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static int InsertPosition;   static int CaretOffset;   #if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor  DragTrackingHandlerHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragTrackingHandlerProcInfo,DragTrackingHandlerHook);   static RoutineDescriptor  DragReceiveHandlerHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragReceiveHandlerProcInfo,DragReceiveHandlerHook);   static RoutineDescriptor  DragSendDataHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragSendDataProcInfo,DragSendDataHook);#define DragSendDataRef &DragSendDataHookRD#define DragTrackingHandlerHookRef &DragTrackingHandlerHookRD#define DragReceiveHandlerHookRef &DragReceiveHandlerHookRD#else#define DragSendDataRef DragSendDataHook#define DragTrackingHandlerHookRef DragTrackingHandlerHook#define DragReceiveHandlerHookRef DragReceiveHandlerHook#endif#define	gCaretTime		((short) *((long *) 0x02F4)) // Fix this later.../*******************************************//* DoEditStartDrag: Handles the start of a *//*   drag mouse action in an edit window.  *//*******************************************/OSErr DoEditStartDrag(  EventRecord *theEvent,  WindowPtr theWindow,  TEHandle theText)  {   OSErr result;   DragReference theDrag;   RgnHandle dragRegion;   AEDesc dropLocation;   DragAttributes attributes;   short mouseDownModifiers, mouseUpModifiers, copyText;	   /*==========================*/   /* Create a drag reference. */   /*==========================*/      if ((result = NewDrag(&theDrag)) != noErr)      { return(result); }      /*=================================================*/    /* Add a text item to the drag item. The text data */   /* will be supplied upon request if needed.        */   /*=================================================*/       if ((result = AddDragItemFlavor(theDrag,0,'TEXT',NULL,0,0)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }        /*============================================*/   /* Get the outline of the text being dragged. */   /*============================================*/   dragRegion = GetEditDragRegion(theText);   if ((result = SetDragSendProc(theDrag,DragSendDataRef,theText)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }       if ((result = TrackDrag(theDrag,theEvent,dragRegion)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }      /*==========================================================*/   /* Check to see if the drop occurred in the Finder's Trash. */   /* If the drop occurred in the Finder's Trash and a copy    */   /* operation wasn't specified, delete the source selection. */   /* Note that we can continue to get the attributes, drop    */   /* location modifiers, etc. of the drag until we dispose of */   /* it using DisposeDrag.                                    */   /*==========================================================*/   GetDragAttributes(theDrag,&attributes);   if (! (attributes & dragInsideSenderApplication))     {      GetDropLocation(theDrag,&dropLocation);      GetDragModifiers(theDrag, 0L,&mouseDownModifiers,&mouseUpModifiers);      copyText = (mouseDownModifiers | mouseUpModifiers) & optionKey;      if ((! copyText) && (DropLocationIsFinderTrash(&dropLocation)))         {         SaveUndoInfo(theWindow,theText,UNDRAG_TRASH,0,0,NULL);         TEDelete(theText);         WindowDirty(theWindow,TRUE);         SetUndoItem(theWindow,UNDRAG_TRASH);        }      AEDisposeDesc(&dropLocation);     }     /*======================*/   /* Dispose of the drag. */   /*======================*/      DisposeRgn(dragRegion);   DisposeDrag(theDrag);   return(result);  }    /*******************************************//* GetEditDragRegion: Gets the outline of  *//*   the region of the text being grabbed. *//*******************************************/RgnHandle GetEditDragRegion(  TEHandle theText)  {   RgnHandle dragRegion, tempRegion;   Point globalPoint;      /*=================================*/   /* Get the region of selected text */   /* in the text edit record.        */   /*=================================*/      dragRegion = NewRgn();   TEGetHiliteRgn(dragRegion,theText);      /*=============================================*/   /* Change the region such that it has the same */   /* outline, but is only one pixel thick.       */   /*=============================================*/      tempRegion = NewRgn();   CopyRgn(dragRegion,tempRegion);   InsetRgn(tempRegion,1,1);   DiffRgn(dragRegion,tempRegion,dragRegion);   DisposeRgn(tempRegion);      /*====================================*/   /* Convert the location of the region */   /* from local to global coordinates.  */   /*====================================*/      globalPoint.v = globalPoint.h = 0;   LocalToGlobal(&globalPoint);   OffsetRgn(dragRegion,globalPoint.h,globalPoint.v);      /*=========================*/   /* Return the drag region. */   /*=========================*/      return(dragRegion);  } /*************************************************//* DragTrackingHandlerHook: Callback routine for *//*   tracking a drag through an edit window.     *//*************************************************/   static pascal OSErr DragTrackingHandlerHook(  DragTrackingMessage theMessage,  WindowPtr theWindow,  void *handlerRefCon,  DragReference theDrag)  {   #if MAC_MPW || MAC_MCW#pragma unused(handlerRefCon)#endif   static int inContent;   static int canAcceptDrag;   static long caretTime;   static short caretShow, lastOffset;   Point mouse, localMouse;   DragAttributes attributes;   RgnHandle hiliteRgn;     EWDHandle theData;   Handle dataHandle;   TEHandle theText;   Rect textArea;   long theTime = TickCount();   short offset;      GetDragAttributes(theDrag,&attributes);      /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle. Retrieve a   */   /* pointer to window's text record          */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(theWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;      switch(theMessage)     {      case dragTrackingEnterHandler:        canAcceptDrag = false;        inContent = false;        break;              case dragTrackingEnterWindow:        canAcceptDrag = IsTextDragTypeAvailable(theDrag);         inContent = false;                caretTime = theTime;        CaretOffset = lastOffset = -1;        caretShow = TRUE;			        break;              case dragTrackingInWindow:        if (! canAcceptDrag) break;        GetDragMouse(theDrag, &mouse, 0L);        localMouse = mouse;        GlobalToLocal(&localMouse);        textArea = theWindow->portRect;         textArea.right = textArea.right - (SCROLL_BAR_WIDTH - 1);        textArea.bottom = textArea.bottom - (SCROLL_BAR_WIDTH - 1);           if (PtInRect(localMouse,&textArea))          {           if (! inContent)             {              if (attributes & dragHasLeftSenderWindow)                 {                 RectRgn(hiliteRgn = NewRgn(),&textArea);                 ShowDragHilite(theDrag, hiliteRgn, TRUE);                 DisposeRgn(hiliteRgn);                }              inContent = TRUE;             }          }         else           {           if (inContent)             {              if (attributes & dragHasLeftSenderWindow)                 { HideDragHilite(theDrag); }              inContent = false;             }          }        if (inContent)          { offset = HitTest(localMouse,theText); }        else          { offset = -1; }          		/*==========================================*/		/* If this application is the sender, do    */		/* not allow tracking through the selection */		/* in the window that sourced the drag.     */		/*==========================================*/        if (attributes & dragInsideSenderWindow)          {           if ((offset >= (**theText).selStart) &&               (offset <= (**theText).selEnd))              { offset = -1; }          }                          InsertPosition = offset;        /*=================================================*/        /* Reset flashing counter if the offset has moved. */        /* This makes the caret blink only after the caret */        /* has stopped moving long enough.                 */        /*=================================================*/        if (offset != lastOffset)          {           caretTime = theTime;           caretShow = TRUE;          }        lastOffset = offset;        /*==============*/        /* Flash caret. */        /*==============*/                if (theTime - caretTime > gCaretTime)          {           caretShow = ! caretShow;           caretTime = theTime;          }                if (! caretShow)          { offset = -1; }        /*==============================*/        /* If caret offset has changed, */        /* move caret on screen.        */        /*==============================*/                if (offset != CaretOffset)          {           if (CaretOffset != -1)             { DrawCaret(CaretOffset,theText); }                        if (offset != -1)             { DrawCaret(offset,theText); }          }        CaretOffset = offset;        break;      case dragTrackingLeaveWindow:              /*===========================================*/        /* If the caret is on the screen, remove it. */        /*===========================================*/        if (CaretOffset != -1)          {           DrawCaret(CaretOffset,theText);           CaretOffset = -1;          }		/*=========================================*/        /* Remove window highlighting, if showing. */        /*=========================================*/			        if (canAcceptDrag && inContent &&             (attributes & dragHasLeftSenderWindow))          { HideDragHilite(theDrag); }                  canAcceptDrag = false;        break;           case dragTrackingLeaveHandler:        break;     }      /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);      return(noErr);  }/**********************************************************//* DragReceiveHandlerHook: Performs the necessary actions *//*   for the drop of TEXT data into an edit window.       *//**********************************************************/static pascal OSErr DragReceiveHandlerHook(  WindowPtr theWindow,  void *handlerRefCon,  DragReference theDrag)  {   #if MAC_MPW || MAC_MCW#pragma unused(handlerRefCon)#endif   unsigned short items;   short index;   ItemReference theItem;   FlavorFlags theFlags;   Size dataSize, totalSize;   char *dragData, *tempPtr;   OSErr result;   EWDHandle theData;   Handle dataHandle;   TEHandle theText;      /*======================================*/   /* Verify that the data is all text and */   /* there is a valid insertion position. */   /*======================================*/      if ((! IsTextDragTypeAvailable(theDrag)) || (InsertPosition == -1))     { return(dragNotAcceptedErr); }      /*===============================*/   /* Determine the number of items */   /* being dragged and dropped.    */    /*===============================*/         result = CountDragItems(theDrag,&items);   if (result != noErr) return(result);      /*===============================*/   /* Determine the total amount of */   /* text data being dropped.      */   /*===============================*/      for (index = 1, totalSize = 0; index <= items; index++)     {      result = GetDragItemReferenceNumber(theDrag,index,&theItem);      if (result != noErr) return(result);            result = GetFlavorFlags(theDrag,theItem,'TEXT',&theFlags);      if (result != noErr) return(result);              result = GetFlavorDataSize(theDrag,theItem,'TEXT',&dataSize);      if (result != noErr) return(result);              totalSize += dataSize;     }   /*=======================================*/   /* Get the window data and convert the   */   /* data to a typed handle. Get a pointer */   /* to the window's edit record.          */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(theWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;      /*===============================================*/   /* Add the amount of text data currently stored  */   /* in the text edit record to the amount of text */   /* being dropped. If the total text is greater   */   /* than the record's maximum size (32K), then    */   /* the drop cannot occur.                        */   /*===============================================*/         if (totalSize + (**theText).teLength >= MAX_BUFFER_SIZE)     {      InitCursor();      ParamText("\pCan't Drag and Drop ",                "\p(only files 32K or smaller can be edited)","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      return(dragNotAcceptedErr);     }   /*==============================*/   /* Allocate memory to store the */   /* text of the drag items.      */   /*==============================*/      dragData = NewPtr(totalSize);   if (dragData == NULL) return(dragNotAcceptedErr);   tempPtr = dragData;      /*==================================*/   /* Store the text of the drag items */   /* in the allocated text buffer.    */   /*==================================*/      for (index = 1; index <= items; index++)     {      result = GetDragItemReferenceNumber(theDrag,index,&theItem);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            result = GetFlavorFlags(theDrag,theItem,'TEXT',&theFlags);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            result = GetFlavorDataSize(theDrag,theItem,'TEXT',&dataSize);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            GetFlavorData(theDrag,theItem,'TEXT',tempPtr,&dataSize,0L);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }              tempPtr += dataSize;     }        /*===================================*/   /* Drop the text data in the window. */   /*===================================*/      DoDragAndDrop(theDrag,dragData,totalSize,theWindow);      /*=====================*/   /* Cleanup and return. */   /*=====================*/      DisposePtr(dragData);   return(noErr);  }    /******************************************//* DragSendDataHook: Callback routine for *//*   retrieving the text data "stored" in *//*   a drag from an edit window.          *//******************************************/   static pascal OSErr DragSendDataHook(  FlavorType theType,  void *dragSendRefCon,  ItemReference theItem,   DragReference theDrag)  {      TEHandle theTextHandle;   char *theString;   Handle theData;   Size theSize;   OSErr result;      theTextHandle = (TEHandle) dragSendRefCon;      switch(theType)      {      case 'TEXT':         theData = (*theTextHandle)->hText;        HLock(theData);        theString = &(*theData)[(*theTextHandle)->selStart];        theSize = (*theTextHandle)->selEnd - (*theTextHandle)->selStart;        result = SetDragItemFlavorData(theDrag,theItem,'TEXT',                                       theString,theSize,0L);        HUnlock(theData);        break;                  default:        result = badDragFlavorErr;        break;     }        return(result);  }  /********************************************//* SetupEditWindowDragAndDrop: Installs the *//*   tracking and receive callback routines *//*   for drag and drop in an edit window.   *//********************************************/   Boolean SetupEditWindowDragAndDrop(  WindowPtr theWindow,  TEHandle theEditRec)  {      OSErr result;   /*=======================*/   /* Set up drag and drop. */   /*=======================*/   if (DragManagerPresent)     {      result = InstallTrackingHandler(DragTrackingHandlerHookRef,                                      theWindow,theEditRec);         result = InstallReceiveHandler(DragReceiveHandlerHookRef,                                     theWindow,theEditRec);     }   /*===================================================*/   /* Use outline hiliting when the window is inactive. */   /*===================================================*/      if (TEFeatureFlagPresent)     {      TEFeatureFlag(teFOutlineHilite,TEBitSet,theEditRec);     }        return(TRUE);  }  /********************************************//* RemoveEditWindowDragAndDrop: Removes the *//*   tracking and receive callback routines *//*   for drag and drop in an edit window.   *//********************************************/   void RemoveEditWindowDragAndDrop(  WindowPtr theWindow)  {   if (DragManagerPresent)     {      RemoveTrackingHandler(DragTrackingHandlerHookRef,theWindow);      RemoveReceiveHandler(DragReceiveHandlerHookRef,theWindow);     }  } /******************************************************//* DoEditDragAndDrop: Determines if a drag and drop   *//*   operation should be performed in an edit window. *//*   If so, the operation is performed  and TRUE is   *//*   returned. Otherwise, FALSE is returned.          *//******************************************************/   Boolean DoEditDragAndDrop(  EventRecord *theEvent,  WindowPtr theWindow,  TEHandle theText)  {   Boolean rv = false;   if (WaitMouseMoved(theEvent->where))     {       DoEditStartDrag(theEvent,theWindow,theText);      rv = TRUE;     }        return(rv);  }   /******************************************//* ClickInEditDragRegion: Returns TRUE if *//*   a mouse click occurred in a dragable *//*   region in an edit window.            *//******************************************/   Boolean ClickInEditDragRegion(  Point thePoint,  TEHandle theText)  {   RgnHandle theRegion;   Boolean rv = false;      if (! DragManagerPresent) return(false);   theRegion = NewRgn();   TEGetHiliteRgn(theRegion,theText);         if (PtInRgn(thePoint,theRegion))     { rv = TRUE; }        DisposeRgn(theRegion);     return(rv);  }           /******************************************//* DoDragAndDrop: Handle Drop portion of  *//*   a "Drag and Drop" to an edit window. *//******************************************/static void DoDragAndDrop(  DragReference theDrag,  char *theDropData,  Size dropDataSize,  WindowPtr whichWindow)  {   long int size;   EWDHandle theData;   Handle dataHandle;   TEHandle theText;   DragAttributes attributes;   short mouseDownModifiers, mouseUpModifiers, moveText = false;	   /*==========================*/   /* Get the drag attributes. */   /*==========================*/      GetDragAttributes(theDrag, &attributes);   GetDragModifiers(theDrag,0L,&mouseDownModifiers,&mouseUpModifiers);      /*==================================================*/   /* Determine if the text should be moved or copied. */   /* It's always copied if the destination window is  */   /* not the sender window. Otherwise, it's moved     */   /* unless the option key is held down.              */   /*==================================================*/      moveText = (attributes & dragInsideSenderWindow) &&			  (! ((mouseDownModifiers & optionKey) | 			      (mouseUpModifiers & optionKey)));   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   /*================================================*/   /* Don't perform the paste if the new buffer size */   /* would exceed the maximum buffer size.          */   /*================================================*/   size = (**theText).teLength;   size += dropDataSize;   if (size >= MAX_BUFFER_SIZE)     {      InitCursor();      ParamText("\pCan't Drag and Drop ",                "\p(only files 32K or smaller can be edited)","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      return;     }   /*====================================*/   /* Save information for undo command. */   /*====================================*/   if (! moveText)     {      SaveUndoInfo(whichWindow,theText,UNDRAG_COPY,                  InsertPosition,dropDataSize,theDropData);     }   else     {      SaveUndoInfo(whichWindow,theText,UNDRAG_MOVE,                   InsertPosition,dropDataSize,theDropData);     }   /*===================================*/   /* Remove the caret if it's visible. */   /*===================================*/      if (CaretOffset != -1)     {      DrawCaret(CaretOffset,theText);      CaretOffset = -1;	 }   /*============================*/   /* If drag highlighting is on */   /* the screen, remove it.     */   /*============================*/   if (attributes & dragHasLeftSenderWindow)     { HideDragHilite(theDrag); }        /*==============================================*/   /* If the drag occurred completely within the   */   /* same window and the window is not frontmost, */   /* bring the window forward and update its      */   /* contents before completing the drag.         */ /* Fix doc later */   /*==============================================*/   if ((attributes & dragInsideSenderWindow) &&        (whichWindow != FrontWindow()))      {      SelectWindow(whichWindow);      // UpdateWindow(theDocument);      // TEActivate(theDocument->theTE);     }   /*==============================================*/   /* If the receiving window is not frontmost,    */   /* temporarily activate its text edit record to */   /* make the background hilite update correctly  */   /*==============================================*/   if (whichWindow != FrontWindow())     { TEActivate(theText); }        /*=====================================*/   /* If the receiving window is also the */   /* sender, delete source selection if  */   /* the option key was not held down.   */   /*=====================================*/		   if (moveText)     {      if (InsertPosition > (*theText)->selStart)        {         InsertPosition -= ((*theText)->selEnd -                            (*theText)->selStart);        }      // TEGetHiliteRgn(theDocument->hiliteRgn, theDocument->theTE);      // srcRect = (**theDocument->hiliteRgn).rgnBBox;      TEDelete(theText);     }   /*==================*/   /* Insert the data. */   /*==================*/        TESetSelect(InsertPosition,InsertPosition,theText);   TEInsert(theDropData,dropDataSize,theText);   TESetSelect(InsertPosition,InsertPosition+dropDataSize,theText);   ResetShiftSelectionAnchor(whichWindow);   /*==================================================*/   /* Adjust scroll bar to length of text, adjust text */   /* to match scroll bar, and keep selection visible. */   /*==================================================*/      EditAdjustText(whichWindow);   AdjustScrollBar(whichWindow);      if (whichWindow != FrontWindow())     { TEDeactivate(theText); }   else     { ScrollToSelection(false,whichWindow); }      /*===========================*/   /* Mark the window as dirty. */   /*===========================*/   WindowDirty(whichWindow,TRUE);   /*=============================*/   /* Fix undo item in Edit menu. */   /*=============================*/   if (moveText) SetUndoItem(whichWindow,UNDRAG_MOVE);   else SetUndoItem(whichWindow,UNDRAG_COPY);   }/**********************************************************//* DrawCaret: Draws a caret in a TextEdit field at the    *//*   given offset. DrawCaret expects the port to be set   *//*   to the port that the TextEdit field is in. DrawCaret *//*   inverts the image of the caret onto the screen.      *//**********************************************************/static void DrawCaret(  short offset,   TEHandle theTE)  {   Point theLoc;   short theLine, lineHeight;   /*==================================*/   /* Get the coordinates and the line */   /* of the offset to draw the caret. */   /*==================================*/   theLoc  = TEGetPoint(offset, theTE);   theLine = TEGetLine(offset, theTE);   /*=======================================================*/   /* For some reason, TextEdit dosen't return the proper   */   /* coordinates of the last offset in the field if the    */   /* last character in the record is a carriage return.    */   /* TEGetPoint returns a point that is one line higher    */   /* than expected. The following code fixes this problem. */   /*=======================================================*/   if ((offset == (**theTE).teLength) &&       (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0D)     { theLoc.v += TEGetHeight(theLine, theLine, theTE); }   /*=======================================*/   /* Always invert the caret when drawing. */   /*=======================================*/   PenMode(patXor);   /*=======================================================*/   /* Get the height of the line that the offset points to. */   /*=======================================================*/   lineHeight = TEGetHeight(theLine, theLine, theTE);   /*===================================*/   /* Draw the appropriate caret image. */   /*===================================*/   MoveTo(theLoc.h - 1, theLoc.v - 1);   Line(0, 1 - lineHeight);   PenNormal();  }/*************************************************************//* TEGetLine: Given an offset and a TextEdit handle, returns *//*   the line number of the line that contains the offset.   *//*************************************************************/static short TEGetLine(  short offset,  TEHandle theTE)  {	   short line = 0;   if (offset > (**theTE).teLength)	 { return((**theTE).nLines); }   while ((**theTE).lineStarts[line] < offset)     { line++; }	   return(line);  }  /***************************************************//* TEIsFrontOfLine: given an offset and a TextEdit *//*   handle, returns TRUE if the given offset is   *//*   at the beginning of a line start.             *//***************************************************/static short TEIsFrontOfLine(  short offset,  TEHandle theTE)  {	   short line = 0;   if ((**theTE).teLength == 0)     { return(TRUE); }   if (offset >= (**theTE).teLength)     { return( (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0d); }   while ((**theTE).lineStarts[line] < offset)     { line++; }   return((**theTE).lineStarts[line] == offset);  }/*****************************************************************//* HitTest: Given a point in global coordinates, HitTest returns *//*   a pointer to a document structure if the point is inside a  *//*   document window on the screen. If the point is not inside a *//*   document window, HitTest return NULL in theDoc. If the      *//*   point is in a doument window and also in the viewRect of    *//*   the document's TextEdit field, HitTest also returns the     *//*   offset into the text that corresponds to that point. If the *//*   point is not in the text, HitTest returns -1.               *//*****************************************************************/short HitTest(  Point theLoc,  TEHandle theText)  {	   short offset;   offset = -1;   offset = TEGetOffset(theLoc,theText);   if ((TEIsFrontOfLine(offset,theText)) && (offset) &&									((*((**(theText)).hText))[offset - 1] != 0x0D) &&						(TEGetPoint(offset - 1, theText).h < theLoc.h))     { offset--; } 	return(offset);  }	               