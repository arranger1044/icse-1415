   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*               GENERAL WINDOW MODULE                 */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _WINDOW_SOURCE_#include "setup.h"#include <stddef.h>#include <stdlib.h>#include <ToolUtils.h>#include <Memory.h>#include <Events.h>#include <Windows.h>#include <Controls.h>#include <Menus.h>#include <Devices.h>/* #include <Desk.h> */#include <OSUtils.h>#if MAC_SC7 || MAC_MPW || MAC_MCW || MAC_SC8#define BLACK (&qd.black)#define GRAY (&qd.gray)#define WHITE (&qd.white)#else#define BLACK (qd.black)#define GRAY (qd.gray)#define WHITE (qd.white)#endif#define SCREEN_BITS (qd.screenBits)#include "apprsrcs.h"  #include "clpscrap.h"   #include "stnrdmac.h"#include "window.h"#include "menuhndl.h"#include "interface.h"/***************//* DEFINITIONS *//***************/#define MAX_WORKING_SCREEN_WIDTH   800#define MAX_WORKING_SCREEN_HEIGHT  600#define ScreenMargin 4#define MinWidth 190#define MinHeight 80#define FILLED_DIAMOND    19#define UNFILLED_DIAMOND 215/*************************//* STRUCTURE DEFINITIONS *//*************************/struct windowMenuInfo  {   WindowPtr whichWindow;   short position;   Boolean dirty;   struct windowMenuInfo *next;  };  /****************************************//* Background Mouse Handler Definitions *//****************************************/typedef pascal OSErr (*BackgroundMouseHandlerProcPtr)                (const EventRecord *event, short *actionCode);                typedef UniversalProcPtr BackgroundMouseHandlerUPP;enum {	uppInstallBackgroundMouseHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(const EventRecord *)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short *)))};typedef BackgroundMouseHandlerUPP BackgroundMouseHandler;pascal OSErr InstallBackgroundMouseHandler(BackgroundMouseHandlerUPP handler)   THREEWORDINLINE(0x3F3C, 0x0055, 0xA88F);/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static pascal void             DeviceLoopProc(short,short,GDHandle,long);   static pascal OSErr            CheckForBackgroundMouseDrag(const EventRecord *,short *);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static struct windowMenuInfo  *WindowMenuList = NULL;   static short                   TempDepth;#if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor DeviceLoopProcRD       = BUILD_ROUTINE_DESCRIPTOR(uppDeviceLoopDrawingProcInfo,DeviceLoopProc);   static RoutineDescriptor CheckForBackgroundMouseDragRD      = BUILD_ROUTINE_DESCRIPTOR(uppInstallBackgroundMouseHandlerProcInfo,                                 CheckForBackgroundMouseDrag);#define DeviceLoopProcRef &DeviceLoopProcRD#define CheckForBackgroundMouseDragRef &CheckForBackgroundMouseDragRD#else#define DeviceLoopProcRef DeviceLoopProc#define CheckForBackgroundMouseDragRef CheckForBackgroundMouseDrag#endif/****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/#if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor              DefaultDialogFilterRD       = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterProcInfo,DefaultDialogFilter);         RoutineDescriptor              DefaultDialogLineUpdateRoutineRD       = BUILD_ROUTINE_DESCRIPTOR(uppUserItemProcInfo,DefaultDialogLineUpdateRoutine);#endif/****************************************************//* DoDrag: Handles mouse-down event in drag region. *//****************************************************/void DoDrag(whichWindow,myEvent)  WindowPtr whichWindow;  EventRecord *myEvent;  {   Rect limitRect;   /*==========================*/   /* Set the limit rectangle. */   /*==========================*/   SetRect(&limitRect,0,0,1024,1024);   /*===================================*/   /* Inset rectangle by screen margin. */   /*===================================*/   InsetRect(&limitRect,ScreenMargin,ScreenMargin);   /*===============================*/   /* Let the user drag the window. */   /*===============================*/   DragWindow(whichWindow,myEvent->where,&limitRect);      /*====================================================*/   /* If window is not frontmost then make it frontmost. */   /* If command key is down, allow the window to be     */   /* dragged if it is not frontmost.                    */   /*====================================================*/   if (((whichWindow != FrontWindow()) &&        (BitAnd(myEvent->modifiers,cmdKey) == 0)) || Suspended)     { SelectWindow(whichWindow); }  }/****************************************************//* DoGrow: Handles mouse-down event in size region. *//****************************************************/void DoGrow(whichWindow,myEvent)  WindowPtr whichWindow;  EventRecord *myEvent;  {   Rect sizeRect;   long int newSize;   int newWidth;   int newHeight;   WDHandle theData;   Handle dataHandle;   void (*myGrowRoutine)(WindowPtr);   /*================================*/   /* Get the window's grow routine. */   /*================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   myGrowRoutine = (**theData).growRoutine;   /*====================================================*/   /* If window is not frontmost then make it frontmost. */   /*====================================================*/   if (whichWindow != FrontWindow())     {      SelectWindow(whichWindow);      return;     }   /*=====================================================*/   /* Set the minimum and maximum area for window growth. */   /*=====================================================*/   SetRect(&sizeRect,MinWidth,MinHeight,GetScreenWidth(),(GetScreenHeight() - MENU_BAR_HEIGHT));   /*=======================================================*/   /* Call GrowWindow to get new size. Note that GrowWindow */   /* does not actually update the window size.             */   /*=======================================================*/   newSize = GrowWindow(whichWindow,myEvent->where,&sizeRect);   /*========================================*/   /* Return if window size was not changed. */   /*========================================*/   if (newSize == 0) return;   /*====================================*/   /* Clear the entire port rectangle to */   /* the window's background pattern.   */   /*====================================*/   EraseRect(&(*whichWindow).portRect);   /*=======================================*/   /* Call SizeWindow to resize the window. */   /*=======================================*/   newWidth = LoWord(newSize);   newHeight = HiWord(newSize);   SizeWindow(whichWindow,newWidth,newHeight,TRUE);   /*======================================================*/   /* Invalidate viewing rectangle and fix the scroll bar. */   /*======================================================*/   InvalRect(&(*whichWindow).portRect);   /*=======================================*/   /* Perform special grow update routines. */   /*=======================================*/   if (myGrowRoutine != NULL) (*myGrowRoutine)(whichWindow);  }/****************************************************//* DoZoom: Handles mouse-down event in zoom region. *//****************************************************/void DoZoom(whichWindow,direction,myEvent)  WindowPtr whichWindow;  int direction;  EventRecord *myEvent;  {   WDHandle theData;   Handle dataHandle;   void (*myZoomRoutine)(WindowPtr);   /*================================*/   /* Get the window's zoom routine. */   /*================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   myZoomRoutine = (**theData).zoomRoutine;   /*====================================================*/   /* If window is not frontmost then make it frontmost. */   /*====================================================*/   if (whichWindow != FrontWindow())     {      SelectWindow(whichWindow);      return;     }   /*==================================================*/   /* If click did not occur in zoom box, then return. */   /*==================================================*/   if (TrackBox(whichWindow,myEvent->where,direction) == 0) return;   /*====================================*/   /* Clear the entire port rectangle to */   /* the window's background pattern.   */   /*====================================*/   EraseRect(&(*whichWindow).portRect);   /*=======================================*/   /* Call ZoomWindow to resize the window. */   /*=======================================*/   ZoomWindow(whichWindow,direction,false);   /*======================================================*/   /* Invalidate viewing rectangle and fix the scroll bar. */   /*======================================================*/   InvalRect(&(*whichWindow).portRect);   /*=======================================*/   /* Perform special grow update routines. */   /*=======================================*/   if (myZoomRoutine != NULL) (*myZoomRoutine)(whichWindow);  }/*********************************************//* FixScrollBar: Resize window's scroll bar. *//*********************************************/void FixScrollBar(  ControlHandle whichVScrollBar,  ControlHandle whichHScrollBar,  WindowPtr whichWindow,  short leftMargin,  short rightMargin,  short topMargin,  short bottomMargin)  {   if (whichVScrollBar != NULL)     {      /*======================*/      /* Hide the scroll bar. */      /*======================*/      HideControl(whichVScrollBar);      /*=============================================================*/      /* Move the top-left corner of the scroll bar. All for 1 pixel */      /* overlap at right and overlap window top by 1 pixel.         */      /*=============================================================*/      MoveControl(whichVScrollBar,(*whichWindow).portRect.right -                                   (SCROLL_BAR_WIDTH - 1), topMargin - 1);      /*==============================================*/      /* Adjust the bottom-right corner of the scroll */      /* bar allowing room for the size box.          */      /*==============================================*/      SizeControl(whichVScrollBar,SCROLL_BAR_WIDTH,          ((*whichWindow).portRect.bottom + 1 - bottomMargin) -          ((*whichWindow).portRect.top - 1) - (SCROLL_BAR_WIDTH - 1) + topMargin);      /*===========================*/      /* Redisplay the scroll bar. */      /*===========================*/      ShowControl(whichVScrollBar);      /*======================================*/      /* Avoid updating the scroll bar again. */      /*======================================*/      ValidRect(&(**whichVScrollBar).contrlRect);     }   if (whichHScrollBar != NULL)     {      /*======================*/      /* Hide the scroll bar. */      /*======================*/      HideControl(whichHScrollBar);      /*=============================================================*/      /* Move the top-left corner of the scroll bar. All for 1 pixel */      /* overlap at right and overlap window top by 1 pixel.         */      /*=============================================================*/      MoveControl(whichHScrollBar,                  leftMargin - 1,(*whichWindow).portRect.bottom - (SCROLL_BAR_WIDTH - 1));      /*==============================================*/      /* Adjust the bottom-right corner of the scroll */      /* bar allowing room for the size box.          */      /*==============================================*/      SizeControl(whichHScrollBar,                  ((*whichWindow).portRect.right + 1 - rightMargin) -                   ((*whichWindow).portRect.left - 1 + leftMargin) -                    (SCROLL_BAR_WIDTH - 1),                  SCROLL_BAR_WIDTH);      /*===========================*/      /* Redisplay the scroll bar. */      /*===========================*/      ShowControl(whichHScrollBar);      /*======================================*/      /* Avoid updating the scroll bar again. */      /*======================================*/      ValidRect(&(**whichHScrollBar).contrlRect);     }  }/*********************************************//* DoContent: Handle mouse-down event in the *//* content region of the active window.      *//*********************************************/short DoContent(whichWindow,myEvent)  WindowPtr whichWindow;  EventRecord *myEvent;  {   WDHandle theData;   Handle dataHandle;   short (*myContentRoutine)(EventRecord *,WindowPtr);      /*===================================*/   /* Get the window's content routine. */   /*===================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   myContentRoutine = (**theData).contentRoutine;   /*===============================================================*/   /* Call special routines for display, facts, and agenda windows. */   /*===============================================================*/   if (myContentRoutine != NULL)      { return (*myContentRoutine)(myEvent,whichWindow); }   return(1);  }/**********************************//* DoUpdate: Handle update event. *//**********************************/void DoUpdate(myEvent)  EventRecord *myEvent;  {   WindowPtr whichWindow;   WDHandle theData;   Handle dataHandle;   void (*myUpdateRoutine)(WindowPtr);   /*=============================================*/   /* Determine which window needs to be updated. */   /*=============================================*/   whichWindow = (WindowPtr) myEvent->message;   /*==================================================================*/   /* If the window isn't a user window, then don't process the event. */   /*==================================================================*/   if (whichWindow == NULL) return;   if (((WindowPeek) whichWindow)->windowKind < userKind) return;   /*==================================*/   /* Get the window's update routine. */   /*==================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   myUpdateRoutine = (**theData).updateRoutine;   /*===========================================*/   /* Call special routines for handling update */   /* on display, fact, and agenda windows.     */   /*===========================================*/   if (myUpdateRoutine != NULL) (*myUpdateRoutine)(whichWindow);  }/******************************************************//* DoActivate: Handle activate (or deactivate) event. *//******************************************************/int DoActivate(myEvent)  EventRecord *myEvent;  {   WindowPtr whichWindow;   int cFlag, aFlag;   whichWindow = (WindowPtr) myEvent->message;   aFlag = BitAnd(myEvent->modifiers,activeFlag);   cFlag = BitAnd(myEvent->modifiers,convertClipboardFlag);   return(WindowActivate(whichWindow,cFlag,aFlag));  }/********************************************************************//* WindowActivate: Handle activation (or deactivation) of a window. *//********************************************************************/int WindowActivate(whichWindow,cFlag,aFlag)  WindowPtr whichWindow;  int cFlag, aFlag;  {   WDHandle theData;   Handle dataHandle;   void (*myActivateRoutine)(WindowPtr);   void (*myDeactivateRoutine)(WindowPtr);   /*==================================================================*/   /* If the window isn't a user window, then don't process the event. */   /*==================================================================*/   if (whichWindow == NULL) return(false);   if (((WindowPeek) whichWindow)->windowKind < userKind) return(false);   /*====================================*/   /* Get the window's activate routine. */   /*====================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (WDHandle) dataHandle;   myActivateRoutine = (**theData).activateRoutine;   myDeactivateRoutine = (**theData).deactivateRoutine;   /*===================================*/   /* Make the window the current port. */   /*===================================*/   SetPort(whichWindow);   /*================================================*/   /* Test the activate/deactivate bit. If TRUE then */   /* activation event has occurred.                 */   /*================================================*/   if (aFlag)     {      if (myActivateRoutine != NULL) (*myActivateRoutine)(whichWindow);      /*===========================================*/      /* If coming from a system window, then copy */      /* the desk scrap to the toolbox scrap.      */      /*===========================================*/      if (cFlag) ReadDeskScrap();     }   /*==================================*/   /* else handle window deactivation. */   /*==================================*/   else     {      if (myDeactivateRoutine != NULL) (*myDeactivateRoutine)(whichWindow);      /*============================================================*/      /* If exiting to a system window, then copy the toolbox scrap */      /* to the desk scrap and enable standard editing commands for */      /* desk accessories.                                          */      /*============================================================*/      if (cFlag) WriteDeskScrap();     }   return(TRUE);  }/******************************************************//* DoGoAway: Handle mouse-down event in close region. *//******************************************************/void DoGoAway(whichWindow,myEvent)  WindowPtr whichWindow;  EventRecord *myEvent;  {   /*===================================================*/   /* If the window is inactive, then just activate it. */   /* Otherwise track the mouse in the close region and */   /* close the window if the click is completed.       */   /*===================================================*/   if (whichWindow != FrontWindow())     { SelectWindow(whichWindow); }   else if (TrackGoAway(whichWindow,myEvent->where))     { DoClose(whichWindow); }  }/**********************************//* DoClose: Handle Close command. *//**********************************/void DoClose(whichWindow)  WindowPtr whichWindow;  {   WDHandle theData;   Handle dataHandle;   void (*myCloseRoutine)(WindowPtr);   /*======================================*/   /* Return if no window is to be closed. */   /*======================================*/   if (whichWindow == NULL)     {      SysBeep(10);      return;     }   /*====================================================*/   /* If the active window is one of our windows then... */   /*====================================================*/   if (((WindowPeek) whichWindow)->windowKind >= userKind)     {      dataHandle = (Handle) GetWRefCon(whichWindow);      theData = (WDHandle) dataHandle;      myCloseRoutine = (**theData).closeRoutine;      if (myCloseRoutine != NULL) (*myCloseRoutine)(whichWindow);      else SysBeep(10);     }   /*===============================================*/   /* Else close a system window. Get the reference */   /* number of the desk accessory and close it.    */   /*===============================================*/   else     { CloseDeskAcc(((WindowPeek) whichWindow)->windowKind); }  }/******************************************************//* DoSuspendResume: Handle suspend (or resume) event. *//******************************************************/void DoSuspendResume(  EventRecord *myEvent)  {   /*=========================*/   /* Check for resume event. */   /*=========================*/   if (BitAnd(myEvent->message,1) == 1)     {      Suspended = false;      WindowActivate(FrontWindow(),TRUE,TRUE);     }   /*=================================*/   /* Otherwise handle suspend event. */   /*=================================*/   else     {      Suspended = TRUE;      WindowActivate(FrontWindow(),TRUE,false);     }  }  /**************************************************************//* AddWindowToMenu: Adds the name of a window to Window menu. *//**************************************************************/void AddWindowToMenu(whichWindow)  WindowPtr whichWindow;  {   Str255 theTitle = "\p(-";   struct windowMenuInfo *newMenuItem;   int position;   /*=======================================*/   /* Determine where to put the menu item. */   /*=======================================*/   position = CountMItems(WindowMenu) + 1;   /*==========================================*/   /* If the position is where the dotted line */   /* should go),  then add a dotted line and  */   /* increment the position.                  */   /*==========================================*/   if (position == AllAboveItem + 1)     {      InsMenuItem(WindowMenu,theTitle,position);      position++;     }   /*===========================*/   /* Add a bogus window title. */   /*===========================*/   theTitle[1] = '-';   InsMenuItem(WindowMenu,theTitle,position);   /*==============================================================*/   /* Add the real window title (SetItem ignores meta characters). */   /*==============================================================*/   GetWTitle(whichWindow,theTitle);   SetItem(WindowMenu,position,theTitle);   /*====================================================*/   /* Add the window to the list of windows in the menu. */   /*====================================================*/   newMenuItem = malloc(sizeof(struct windowMenuInfo));   newMenuItem->next = WindowMenuList;   newMenuItem->whichWindow = whichWindow;   newMenuItem->dirty = FALSE;   newMenuItem->position = position;   WindowMenuList = newMenuItem;  }/***************************************************************//* RemoveWindowFromMenu: Removes the name of a window from the *//*   Window menu.  This routines assumes the window pointer    *//*   passed as an argument is in the window menu list and that *//*   the windows are stored in reverse order that they are     *//*   found in the window menu list (so that the position of    *//*   the other windows in the menu can be updated easily).     *//***************************************************************/void RemoveWindowFromMenu(whichWindow)  WindowPtr whichWindow;  {   struct windowMenuInfo *menuItemPtr, *prevPtr = NULL;   /*=========================================*/   /* Remove the window from the window list. */   /*=========================================*/   menuItemPtr = WindowMenuList;   while (menuItemPtr != NULL)     {      if (menuItemPtr->whichWindow == whichWindow)        {         DelMenuItem(WindowMenu,menuItemPtr->position);         if (prevPtr == NULL) WindowMenuList = menuItemPtr->next;         else prevPtr->next = menuItemPtr->next;         free(menuItemPtr);         menuItemPtr = NULL;        }      else        {         menuItemPtr->position--;         prevPtr = menuItemPtr;         menuItemPtr = menuItemPtr->next;        }     }   /*======================================*/   /* Remove the dotted line if necessary. */   /*======================================*/   if (CountMItems(WindowMenu) == AllAboveItem + 1)     { DelMenuItem(WindowMenu,AllAboveItem + 1); }  }/****************************************************//* UpdateWindowInMenu: Updates the name of a window *//*    in the Window menu.                           *//****************************************************/void UpdateWindowInMenu(whichWindow)  WindowPtr whichWindow;  {   Str255 theTitle;   struct windowMenuInfo *menuItemPtr;   GetWTitle(whichWindow,theTitle);   menuItemPtr = WindowMenuList;   while (menuItemPtr != NULL)     {      if (menuItemPtr->whichWindow == whichWindow)        {         SetItem(WindowMenu,menuItemPtr->position,theTitle);         return;        }      else        { menuItemPtr = menuItemPtr->next; }     }  }/*****************************************************************//* EnableWindowMenuItems: Enables all items in the Windows menu. *//*****************************************************************/void EnableWindowMenuItems()  {   struct windowMenuInfo *menuItemPtr;   menuItemPtr = WindowMenuList;   while (menuItemPtr != NULL)     {      EnableItem(WindowMenu,menuItemPtr->position);      menuItemPtr = menuItemPtr->next;     }  }/*************************************************//* UpdateWindowMenuCheck: Updates the check mark *//*   for a window in the Window menu.            *//*************************************************/void UpdateWindowMenuCheck(whichWindow,status)  WindowPtr whichWindow;  int status;  {   struct windowMenuInfo *menuItemPtr;   for (menuItemPtr = WindowMenuList;        menuItemPtr != NULL;                 menuItemPtr = menuItemPtr->next)      {      if (menuItemPtr->whichWindow == whichWindow)        {         if (menuItemPtr->dirty)           { SetItemMark(WindowMenu,menuItemPtr->position,FILLED_DIAMOND); }          else           { CheckItem(WindowMenu,menuItemPtr->position,status); }        }      else        {         if (menuItemPtr->dirty)           { SetItemMark(WindowMenu,menuItemPtr->position,UNFILLED_DIAMOND); }         }     }  }/*************************************************//* UpdateWindowMenuDirty: Updates the dirty flag *//*   for a window in the Window menu.            *//*************************************************/void UpdateWindowMenuDirty(  WindowPtr whichWindow,  Boolean dirty)  {   struct windowMenuInfo *menuItemPtr;   for (menuItemPtr = WindowMenuList;        menuItemPtr != NULL;                 menuItemPtr = menuItemPtr->next)      {      if (menuItemPtr->whichWindow == whichWindow)        {         menuItemPtr->dirty = dirty;         return;        }     }  }  /***************************************************************//* SelectWindowFromMenu: Selects a window from the Window menu *//*   based on the position of an item selected from the menu.  *//***************************************************************/void SelectWindowFromMenu(position)  int position;  {   struct windowMenuInfo *menuItemPtr;   menuItemPtr = WindowMenuList;   while (menuItemPtr != NULL)     {      if (menuItemPtr->position == position)        {         SelectWindow(menuItemPtr->whichWindow);         return;        }      else        { menuItemPtr = menuItemPtr->next; }     }  }/**************************************************************************//* CenterWindowHorizontally: Centers a window on the screen horizontally. *//**************************************************************************/void CenterWindowHorizontally(WindowPtr whichWindow,float hp,int dh)  {   Point myPoint;   int windowLeft, windowWidth;   int horizontalOffset, visible;   /*=============================================================*/   /* Convert window upper left coordinate to global coordinates. */   /*=============================================================*/   myPoint.h = (*whichWindow).portRect.left;   myPoint.v = (*whichWindow).portRect.top;   LocalToGlobal(&myPoint);   /*====================================================*/   /* Move the window off the screen and make it visible */   /* so that the window's struct region is recomputed.  */   /*====================================================*/   visible = ((WindowPeek) whichWindow)->visible;   ShowHide(whichWindow,false);   MoveWindow(whichWindow,10000,10000,false);   ShowWindow(whichWindow);   /*======================================================*/   /* Determine the offset between the top of the window's */   /* structure region and its content region.             */   /*======================================================*/   horizontalOffset = (*((WindowPeek) whichWindow)->contRgn)->rgnBBox.left -                    (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.left;   /*===============================*/   /* Determine window's left edge. */   /*===============================*/   windowWidth = (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.right -                  (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.left;   windowLeft = horizontalOffset + ((GetWorkingScreenWidth() - windowWidth) * hp);   /*==================*/   /* Move the window. */   /*==================*/   ShowHide(whichWindow,visible);   MoveWindow(whichWindow,windowLeft + dh,myPoint.v,false);  }/**********************************************************************//* CenterWindowVertically: Centers a window on the screen vertically. *//**********************************************************************/void CenterWindowVertically(WindowPtr whichWindow,float vp,int dv)  {   Point myPoint;   int windowTop, windowHeight, verticalOffset;   int visible;   /*=============================================================*/   /* Convert window upper left coordinate to global coordinates. */   /*=============================================================*/   myPoint.h = (*whichWindow).portRect.left;   myPoint.v = (*whichWindow).portRect.top;   LocalToGlobal(&myPoint);   /*====================================================*/   /* Move the window off the screen and make it visible */   /* so that the window's struct region is recomputed.  */   /*====================================================*/   visible = ((WindowPeek) whichWindow)->visible;   ShowHide(whichWindow,false);   MoveWindow(whichWindow,10000,10000,false);   ShowWindow(whichWindow);   /*======================================================*/   /* Determine the offset between the top of the window's */   /* structure region and its content region.             */   /*======================================================*/   verticalOffset = (*((WindowPeek) whichWindow)->contRgn)->rgnBBox.top -                    (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.top;   /*===============================*/   /* Determine window's left edge. */   /*===============================*/   windowHeight = (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.bottom -                  (*((WindowPeek) whichWindow)->strucRgn)->rgnBBox.top;   windowTop = MENU_BAR_HEIGHT +               ((GetWorkingScreenHeight() - windowHeight - MENU_BAR_HEIGHT) * vp) +               verticalOffset;   /*==================*/   /* Move the window. */   /*==================*/   ShowHide(whichWindow,visible);   MoveWindow(whichWindow,myPoint.h,windowTop + dv,false);  }/*****************************************************************************//* CenterWindow: Centers a window on the screen horizontally and vertically. *//*****************************************************************************/void CenterWindow(WindowPtr whichWindow,float hp,float vp)  {   CenterWindowHorizontally(whichWindow,hp,0);   CenterWindowVertically(whichWindow,vp,0);  }/***********************************************************************//* CenterWindowWithOffset: Centers a window on the screen horizontally *//*   and vertically with horizontal and vertical offsets.              *//***********************************************************************/void CenterWindowWithOffset(WindowPtr whichWindow,float hp,float vp,int dh,int dv)  {   CenterWindowHorizontally(whichWindow,hp,dh);   CenterWindowVertically(whichWindow,vp,dv);  }/**********************************************************************//* SetRadioBank: Sets the value of a radio button in a set of buttons. *//**********************************************************************/void SetRadioBank(dptr,radioButtonNumber,startButton,endButton)  DialogPtr dptr;  int radioButtonNumber, startButton, endButton;  {   ControlHandle ctrlHandle;   Handle itemHandle;   Rect dispRect;   short int itemType;   int i;   for (i = startButton; i <= endButton; i++)     {      GetDItem(dptr,i,&itemType,&itemHandle,&dispRect);      ctrlHandle = (ControlHandle) itemHandle;      if (i == radioButtonNumber) SetCtlValue(ctrlHandle,1);      else SetCtlValue(ctrlHandle,0);     }  }/*****************************************************************//* ToggleCheckBox: Toggles the value of a check box in a dialog. *//*****************************************************************/int ToggleCheckBox(dptr,checkBoxNumber)  DialogPtr dptr;  int checkBoxNumber;  {   int value;   ControlHandle ctrlHandle;   Handle itemHandle;   Rect dispRect;   short int itemType;   /*========================================================*/   /* Get the control handle of the check box to be toggled. */   /*========================================================*/   GetDItem(dptr,checkBoxNumber,&itemType,&itemHandle,&dispRect);   ctrlHandle = (ControlHandle) itemHandle;   /*=================================*/   /* Get the value of the check box. */   /*=================================*/   value = GetCtlValue(ctrlHandle);   /*====================================*/   /* Toggle the value of the check box. */   /*====================================*/   SetCtlValue(ctrlHandle,1 - value);   /*===========================*/   /* Return the toggled value. */   /*===========================*/   return(1 - value);  }/**************************************************************//* GetCheckBox: Returns the value of a check box in a dialog. *//**************************************************************/int GetCheckBox(dptr,checkBoxNumber)  DialogPtr dptr;  int checkBoxNumber;  {   Handle itemHandle;   Rect dispRect;   short int itemType;   GetDItem(dptr,checkBoxNumber,&itemType,&itemHandle,&dispRect);   return GetCtlValue((ControlHandle) itemHandle);  }/***********************************************************//* SetCheckBox: Sets the value of a check box in a dialog. *//***********************************************************/int SetCheckBox(dptr,checkBoxNumber,value)  DialogPtr dptr;  int checkBoxNumber, value;  {   ControlHandle ctrlHandle;   Handle itemHandle;   Rect dispRect;   short int itemType;   /*====================================================*/   /* Get the control handle of the check box to be set. */   /*====================================================*/   GetDItem(dptr,checkBoxNumber,&itemType,&itemHandle,&dispRect);   ctrlHandle = (ControlHandle) itemHandle;   /*========================================*/   /* Assign the new value to the check box. */   /*========================================*/   SetCtlValue(ctrlHandle,value);   /*============================*/   /* Return the assigned value. */   /*============================*/   return(value);  }/***********************************************************//* GetScreenHeight:  *//***********************************************************/int GetScreenHeight()  {   return(SCREEN_BITS.bounds.bottom - SCREEN_BITS.bounds.top);  }/***********************************************************//* GetScreenWidth:  *//***********************************************************/int GetScreenWidth()  {   return(SCREEN_BITS.bounds.right - SCREEN_BITS.bounds.left);  }/***********************************************************//* GetWorkingScreenHeight:  *//***********************************************************/int GetWorkingScreenHeight()  {   if (GetScreenHeight() > MAX_WORKING_SCREEN_HEIGHT)     { return(MAX_WORKING_SCREEN_HEIGHT); }   else     { return(GetScreenHeight()); }  }/***********************************************************//* GetWorkingScreenWidth:  *//***********************************************************/int GetWorkingScreenWidth()  {   if (GetScreenWidth() > MAX_WORKING_SCREEN_WIDTH)     { return(MAX_WORKING_SCREEN_WIDTH); }   else     { return(GetScreenWidth()); }  }/***********************************************************//* OutlineButton: Outlines a button in a dialog box which *//*   indicates that the button is the default button.      *//***********************************************************/void OutlineButton(dptr,itemNumber,useBlack)  DialogPtr dptr;  int itemNumber;  int useBlack;  {   Handle itemHandle;   Rect dispRect;   short int itemType;   PenState pnState;   /*=====================*/   /* Save the pen state. */   /*=====================*/   GetPenState(&pnState);   /*===============================================================*/   /* Get information about the dialog item that is to be outlined. */   /*===============================================================*/   GetDItem(dptr,itemNumber,&itemType,&itemHandle,&dispRect);   /*=====================*/   /* Outline the button. */   /*=====================*/   if (useBlack) PenPat(BLACK);   else PenPat(WHITE);   PenMode(patCopy);   PenSize(3,3);   InsetRect(&dispRect,-4,-4);   FrameRoundRect(&dispRect,16,16);   PenSize(1,1);   /*========================*/   /* Restore the pen state. */   /*========================*/   SetPenState(&pnState);  }/**************************************************//* FlashButton: Flashes a button for eight ticks. *//**************************************************/void FlashButton(dptr,itemNumber)  DialogPtr dptr;  int itemNumber;  {   Handle itemHandle;   Rect dispRect;   short int itemType;   unsigned long int startTime;   /*===============================================================*/   /* Get information about the dialog item that is to be outlined. */   /*===============================================================*/   GetDItem(dptr,itemNumber,&itemType,&itemHandle,&dispRect);   /*===============================*/   /* Flash the button for 8 ticks. */   /*===============================*/   InsetRect(&dispRect,1,1);   InvertRoundRect(&dispRect,10,10);   startTime = TickCount();   while (TickCount() < (startTime + 8))     { /* Do Nothing */ }   InvertRoundRect(&dispRect,10,10);  }/***************************************************//* DefaultButtonUpdateRoutine: Default routine for *//*   updating the default button in a dialog.      *//***************************************************/pascal void DefaultButtonUpdateRoutine(DialogPtr dptr,short itemNumber)  {   OutlineButton(dptr,itemNumber,TRUE);  }/***************************************************//* DefaultDialogLineUpdateRoutine: Default routine *//*   for updating a border line in a dialog.       *//***************************************************/pascal void DefaultDialogLineUpdateRoutine(DialogPtr dptr,short itemNumber)  {   short int itemType;   Handle itemHandle;   Rect dispRect;   PenState pnState;   /*=====================*/   /* Save the pen state. */   /*=====================*/   GetPenState(&pnState);   /*=====================*/   /* Highlight the line. */   /*=====================*/   PenPat(GRAY);   GetDItem(dptr,itemNumber,&itemType,&itemHandle,&dispRect);   FrameRect(&dispRect);   /*========================*/   /* Restore the pen state. */   /*========================*/   SetPenState(&pnState);  }/*******************************************************//* DefaultDialogFilter: Default filter routine for use *//*   with dialogs and alerts. Processes activate and   *//*   update events and treats a carriage return as a   *//*   mouse click on the first item in the dialog.      *//*******************************************************/pascal Boolean DefaultDialogFilter(  DialogPtr theDialog,  EventRecord *myEvent,  short int *itemNumber)  {   GrafPtr tempPort;   char ch;   /*=========================*/   /* Handle activate events. */   /*=========================*/   if ((*myEvent).what == activateEvt)     {      GetPort(&tempPort);      DoActivate(myEvent);      SetPort(tempPort);      return(false);     }   /*=======================*/   /* Handle update events. */   /*=======================*/   if ((*myEvent).what == updateEvt)     {      GetPort(&tempPort);      DoUpdate(myEvent);      SetPort(tempPort);      return(false);     }   /*==================================================*/   /* If a key wasn't pressed don't bother processing. */   /*==================================================*/   if ((*myEvent).what != keyDown) return(false);   /*===========================================================*/   /* The return key acts as if the default button was pressed. */   /*===========================================================*/   ch = (char) BitAnd(myEvent->message,charCodeMask);   if ((ch == '\r') || (ch == '\n') || (ch == '\03'))     {      *itemNumber = ((DialogPeek) theDialog)->aDefItem;      FlashButton((DialogPtr) theDialog,((DialogPeek) theDialog)->aDefItem);      return(TRUE);     }   return (false);  }/************************************************************//* HandleWindowEvents: Processes all current window events. *//************************************************************/void HandleWindowEvents()  {   EventRecord myEvent;   while (GetTheEvent(updateMask | activMask,&myEvent) != 0)     {      switch (myEvent.what)        {         case nullEvent:           return;           break;         /*======================*/         /* Handle update event. */         /*======================*/         case updateEvt:           DoUpdate(&myEvent);           break;         /*===================================*/         /* Handle activate/deactivate event. */         /*===================================*/         case activateEvt:           DoActivate(&myEvent);           break;        }     }  }/************************************************************//* PlaceDialogTextItem: *//************************************************************/void PlaceDialogTextItem(WindowPtr whichWindow,int theItem,int centerIt)  {   int dialogWidth, stringWidth;   short int itemType;   Handle itemHandle;   Rect dispRect;   Str255 theString;   GetDItem(whichWindow,theItem,&itemType,&itemHandle,&dispRect);   GetIText(itemHandle,theString);   stringWidth = StringWidth(theString);   if (centerIt)     {      dialogWidth = (*whichWindow).portRect.right - (*whichWindow).portRect.left;      dispRect.left = (dialogWidth - stringWidth) / 2;     }   dispRect.right = dispRect.left + stringWidth + 1;   SetDItem(whichWindow,theItem,itemType,itemHandle,&dispRect);  }/******************************************//* WindowDepth: Returns the minimum pixel *//*   depth for the specified window.      *//******************************************/short WindowDepth(  WindowPtr theWindow)  {   TempDepth = 256;                                DeviceLoop(theWindow->visRgn,#if (MAC_MCW && __powerc) || MAC_SC8              DeviceLoopProcRef,#else              (DeviceLoopDrawingProcPtr) DeviceLoopProcRef,#endif              (long) theWindow,0);   return(TempDepth);  }/**********************************************************//* DeviceLoopProc: Callback routine used with WindowDepth *//*   to determine the minimum pixel depth of a window.    *//*   This sets the global TempDepth to the depth of the   *//*   device associated with this call if it is lower than *//*   other devices that called this routine.              *//**********************************************************/static pascal void DeviceLoopProc(  short depth,   short deviceFlags,   GDHandle targetDevice,  long userData)  {#if MAC_MPW || MAC_MCW#pragma unused(deviceFlags,targetDevice,userData)#endif   if (depth < TempDepth)     { TempDepth = depth; }  }/*********************************************************//* CheckForBackgroundMouseDrag: Callback routine used to *//*   determine if a background click in one of this      *//*   application's windows should bring the application  *//*   to the front. This is used to allow dragging text   *//*   from this application without bringing it           *//*   frontmost.                                          *//*********************************************************/static pascal OSErr CheckForBackgroundMouseDrag(  const EventRecord *event,   short *actionCode)  {   WindowPtr whichWindow;   short partCode;     /*==========================================*/   /* Where did the user click in the window?  */   /*==========================================*/      partCode = FindWindow(event->where,&whichWindow);         /*==============================================*/   /* If the click is anywhere in the window other */   /* than the content region, then return TRUE so */   /* that the window's application is brought     */   /* frontmost. No other action is taken.         */   /*==============================================*/      if (partCode != inContent)     {      *actionCode = 1;      return(noErr);     }         /*============================================================*/   /* The click was in the content region. If the click occurred */   /* in selected text, then determine if the user is performing */   /* a drag and drop. If so, then 0 should be returned to       */   /* indicate that the application should not be brought        */    /* frontmost. Otherwise, if the user did not complete a drag  */   /* and drop or the area clicked was not selected text, then   */   /* return 1 to bring the application frontmost.               */   /*============================================================*/      *actionCode = DoContent(whichWindow,(EventRecord *) event);        return(noErr);  }  /************************************************//* SetupBackgroundMouseDrag: Setup routine for  *//*   the background mouse handler which permits *//*   background drag and drop.                  *//************************************************/   Boolean SetupBackgroundMouseDrag()  {   #if __powerc || MAC_SC8   if (DragManagerPresent)     { InstallBackgroundMouseHandler((UniversalProcPtr) CheckForBackgroundMouseDragRef); }    #endif        return(TRUE);  }            /***********************************************//* InstallBackgroundMouseHandler: Installs the *//*   background mouse handler which permits    *//*   background drag and drop.                 *//***********************************************/                   pascal OSErr InstallBackgroundMouseHandler(  BackgroundMouseHandlerUPP handler)  {   long stub[6];   OSErr result;      /*=============================================*/   /* Prepare a 68K stub to call the undocumented */   /* routine through the A-trap mechanism.       */   /*=============================================*/      stub[0] = 0x554F2F2F;   stub[1] = 0x00063F3C;   stub[2] = 0x0055A88F;   stub[3] = 0x301F3F40;   stub[4] = 0x00082E9F;   stub[5] = 0x4E754E71;   /*==========================================*/   /* Switch to 68K mode and execute the stub. */   /*==========================================*/   #if __powerc || MAC_SC8   result = CallUniversalProc((RoutineDescriptor *) stub, 0xE0, handler);#else   result = noErr;#endif   return(result);  }                                /*******************************************************//* WindowType: Returns the program defined window type *//*   stored in the windows reference constant.         *//*******************************************************/short WindowType(  WindowPtr whichWindow)  {   WindowData **windowInfo;   windowInfo = (WindowData **) GetWRefCon(whichWindow);   return((*windowInfo)->windowType);  }/***************************************************//* GetGlobalWindowPosition: Returns the top, left, */ /*   bottom, right coordinates of a window.        *//***************************************************/void GetGlobalWindowPosition(  WindowPtr whichWindow,  short *top,  short *left,  short *bottom,  short *right)  {   Point topLeft, bottomRight;   topLeft.h = (*whichWindow).portRect.left;   topLeft.v = (*whichWindow).portRect.top;      bottomRight.h = (*whichWindow).portRect.right;   bottomRight.v = (*whichWindow).portRect.bottom;      LocalToGlobal(&topLeft);   LocalToGlobal(&bottomRight);      *top = topLeft.v;   *left = topLeft.h;   *bottom = bottomRight.v;   *right = bottomRight.h;  }