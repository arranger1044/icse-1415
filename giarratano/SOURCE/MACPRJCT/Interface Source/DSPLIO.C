   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  09/03/96          */   /*                                                     */   /*                  DISPLAY IO MODULE                  */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _DSPLIO_SOURCE_#include "setup.h"#include <string.h>#include <SegLoad.h>#include <Windows.h>#include "commline.h"#include "router.h"#include "displayw.h"#include "dsplscrl.h"#include "stnrdmac.h"#include "dsplio.h"/***************//* DEFINITIONS *//***************/#define BALANCE_PARENTHESIS_PAUSE_DURATION 20/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static int              CursorY(void);   static int              CursorX(void);   static Boolean          FindBalancingParenthesis(long *,long *);/******************************************************************//* DisplayPrint: Handles printing a string to the display window. *//******************************************************************/void DisplayPrint(str)  char *str;  {   long int i = 0, j, length;   int x;   char *newLine;   Rect viewRect;   GrafPtr savePort;   RgnHandle theHandle;   char oldChar;   int newLineEnd, newCharEnd;   int cursorHidden = false;   /*========================*/   /* Save the current port. */   /*========================*/   GetPort(&savePort);   /*=====================================*/   /* Set the port to the display window. */   /*=====================================*/   SetPort(DisplayWindow);   /*===============================*/   /* Save the old clipping region. */   /*===============================*/   theHandle = NewRgn();   GetClip(theHandle);   /*=================================================*/   /* Prevent output from spilling into scroll areas. */   /*=================================================*/   viewRect = (*DisplayWindow).portRect;   viewRect.right -= (SCROLL_BAR_WIDTH - 1);   viewRect.bottom = DisplayLineHeight * LinesInDisplayWindow;   ClipRect(&viewRect);   /*===================================*/   /* Remove the cursor while printing. */   /*===================================*/   MoveTo(CursorX(),CursorY());      if (CursorVisible && (! CursorHideLock))     {      DrawCursor();      CursorVisible = false;      cursorHidden = TRUE;      CursorHideLock = TRUE;     }   else if ((SelectionLineEnd == AppendDisplayLine) &&            (DisplayText[AppendDisplayLine].insertPoint == SelectionCharEnd))     {      cursorHidden = TRUE;      }   /*====================================================*/   /* Process each character of the string individually. */   /*====================================================*/   i = 0;   while (str[i] != '\0')     {      /*==========================================*/      /* If the character is a backspace, then... */      /*==========================================*/      if (str[i] == '\b')        {         /*=============================================*/         /* Fix Highlighting if in the selection range. */         /*=============================================*/         if (((LinesInUse - 1) == SelectionLineEnd) &&             (DisplayText[AppendDisplayLine].insertPoint == SelectionCharEnd) &&             ((SelectionCharEnd != SelectionCharStart) ||              (SelectionLineEnd != SelectionLineStart)))           {            if (SelectionCharEnd == 0)              {               newLineEnd = LinesInUse - 2;               newCharEnd = DisplayText[AppendDisplayLine - 1].insertPoint;              }            else              {               newLineEnd = LinesInUse - 1;               newCharEnd = SelectionCharEnd - 1;              }            if ((newLineEnd < 0) || (newCharEnd < 0))              {               newLineEnd = 0;               newCharEnd = 0;              }            ExtendDisplaySelection(DisplayWindow,SelectionLineEnd,SelectionCharEnd,                                                 newLineEnd,newCharEnd);            SelectionCharEnd = newCharEnd;            SelectionLineEnd = newLineEnd;           }         /*==============================================*/         /* If the current append line is empty, then... */         /*==============================================*/         if (DisplayText[AppendDisplayLine].insertPoint == 0)           {            /*=======================================================*/            /* If the current append line is not the first line in   */            /* the display history then backup to the previous line. */            /*=======================================================*/            if (AppendDisplayLine != ZeroDisplayLine)              {               if (AppendDisplayLine == 0)                 { AppendDisplayLine = MAX_DISPLAY_LINES - 1; }               else                 { AppendDisplayLine--; }               LinesInUse--;                              SetClip(theHandle);               ShowDisplayEnd(TRUE);               ClipRect(&viewRect);              }           }         /*=====================================================*/         /* Else backup a character on the current append line. */         /*=====================================================*/         else           {            x = --DisplayText[AppendDisplayLine].insertPoint;            oldChar = DisplayText[AppendDisplayLine].lineInfo[x];            DisplayText[AppendDisplayLine].lineInfo[x] = ' ';            DisplayText[AppendDisplayLine].lineInfo[x+1] = '\0';            Move(-CharWidth(oldChar),0);            DrawChar(' ');            Move(-CharWidth(' '),0);           }         i++;        }      /*==================================================================*/      /* Else if the character is a hard or soft carriage return, then... */      /*==================================================================*/      else if ((str[i] == '\n') || (str[i] == '\r'))        {         /*==============================================================*/         /* A carraige return forces the append line to the next line in */         /* the display history. Note that the display history array     */         /* is circular (that is, it wraps around).                      */         /*==============================================================*/         AppendDisplayLine = (AppendDisplayLine + 1) % MAX_DISPLAY_LINES;         /*================================================================*/         /* If the display history is not full, then the new append line   */         /* added increments the number of lines in use by one. Otherwise  */         /* the new append line causes the top line in the display history */         /* to be replaced and the count of lines lost is incremented.     */         /*================================================================*/         if (LinesInUse < MAX_DISPLAY_LINES)           { LinesInUse++; }         else           {            ZeroDisplayLine = (ZeroDisplayLine + 1) % MAX_DISPLAY_LINES;            LinesLost++;           }         /*==============================================================*/         /* If the new append line is not the standard line length, then */         /* free the memory used for line storage of this line and set   */         /* the line length equal to zero. This insures that memory      */         /* allocated for large lines eventually gets freed.             */         /*==============================================================*/         if (DisplayText[AppendDisplayLine].lineSize != STANDARD_LINE_LENGTH)           {            if (DisplayText[AppendDisplayLine].lineInfo != NULL)              { DisposPtr(DisplayText[AppendDisplayLine].lineInfo); }            DisplayText[AppendDisplayLine].lineSize = 0;            DisplayText[AppendDisplayLine].lineInfo = NULL;           }         /*============================================*/         /* Place the insertion point at the beginning */         /* of the new append line.                    */         /*============================================*/         DisplayText[AppendDisplayLine].insertPoint = 0;         if (DisplayText[AppendDisplayLine].lineInfo != NULL)           { DisplayText[AppendDisplayLine].lineInfo[0] = '\0'; }         /*==================================*/         /* Restore the old clipping region. */         /*==================================*/         SetClip(theHandle);         ShowDisplayEnd(TRUE);         ClipRect(&viewRect);          i++;        }      /*===================================================*/      /* Else the character is a standard character, so... */      /*===================================================*/      else        {         j = i + 1;         while ((str[j] != '\b') && (str[j] != '\r') &&                (str[j] != '\n') && (str[j] != '\0')) j++;         length = j - i;         /*=================================================*/         /* If the current append line is not big enough to */         /* hold an additional character, then expand it.   */         /*=================================================*/         if (DisplayText[AppendDisplayLine].insertPoint >=             (DisplayText[AppendDisplayLine].lineSize - length))           {            newLine = NewPtr(DisplayText[AppendDisplayLine].lineSize + length + 20);            if (newLine == NULL)              { ExitToShell(); }            if (DisplayText[AppendDisplayLine].lineInfo != NULL)              {               strcpy(newLine,DisplayText[AppendDisplayLine].lineInfo);               DisposPtr(DisplayText[AppendDisplayLine].lineInfo);              }            DisplayText[AppendDisplayLine].lineSize += (length + 20);            DisplayText[AppendDisplayLine].lineInfo = newLine;           }         /*============================================*/         /* Add the string to the current append line. */         /*============================================*/         x = DisplayText[AppendDisplayLine].insertPoint;         strncpy(&DisplayText[AppendDisplayLine].lineInfo[x],&str[i],length);         x += length;         DisplayText[AppendDisplayLine].lineInfo[x] = '\0';         DisplayText[AppendDisplayLine].insertPoint = x;         /*===================================*/         /* Draw the character on the window. */         /*===================================*/         DrawText(&str[i],0,length);         i = j;        }     }            /*====================*/   /* Redraw the cursor. */   /*====================*/   if (cursorHidden && CursorShouldBeDrawn())     {       CursorVisible = TRUE;      CursorHideLock = false;      MoveTo(CursorX(),CursorY());      DrawCursor();     }   else if (cursorHidden)     { CursorHideLock = false; }   /*==================================*/   /* Restore the old clipping region. */   /*==================================*/   SetClip(theHandle);   DisposeRgn(theHandle);   /*=======================*/   /* Restore the old port. */   /*=======================*/   SetPort(savePort);  }/**********************************************************//* CursorY: Returns the current y position of the cursor. *//**********************************************************/static int CursorY()  {   int y_loc;   y_loc = DisplayStartLine +          ((LinesInUse - (TopDisplayNumber + 1)) * DisplayLineHeight);   return(y_loc);  }/**********************************************************//* CursorX: Returns the current x position of the cursor. *//**********************************************************/static int CursorX()  {   int x_loc;   /*===================================================*/   /* If the line is empty, then return the offset from */   /* the left margin.                                  */   /*===================================================*/   x_loc = LeftWindowMargin - (GetCtlValue(DisplayHScroll) * CharacterWidth);   if (DisplayText[AppendDisplayLine].insertPoint == 0)     { return(x_loc); }   /*=======================================================*/   /* Return the offset from the left margin plus the width */   /* of the text associated with the current append line.  */   /*=======================================================*/   x_loc += TextWidth(DisplayText[AppendDisplayLine].lineInfo,0,                      DisplayText[AppendDisplayLine].insertPoint);   return(x_loc);  }/***********************************************//* DisplayKeystrokeRoutine: Handles characters *//*    typed to the display window.             *//***********************************************/void DisplayKeystrokeRoutine(  WindowPtr whichWindow,  int ch,  EventModifiers theModifiers)  {   char inp[2];   long whichLine, whichChar;   long startTime;#if MAC_MPW || MAC_MCW#pragma unused(whichWindow)#pragma unused(theModifiers)#endif   switch (ch)     {      case END_KEY:        ShowDisplayEnd(TRUE);        return;      case HOME_KEY:        ShowDisplayBegin(TRUE);        return;           case PAGE_UP_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayVScroll,inPageUp);        return;      case PAGE_DOWN_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayVScroll,inPageDown);        return;      case DOWN_ARROW_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayVScroll,inDownButton);        return;      case UP_ARROW_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayVScroll,inUpButton);        return;      case RIGHT_ARROW_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayHScroll,inDownButton);        return;      case LEFT_ARROW_KEY:        DisplayKeyBoardScroll(DisplayWindow,DisplayHScroll,inUpButton);        return;     }        /*==================================================*/   /* Ignore control characters other than line feeds, */   /* tabs, carriage returns, and backspaces.          */   /*==================================================*/   if (((ch == DELETE_KEY) || (ch <= DOWN_ARROW_KEY)) &&        (ch != '\r') && (ch != '\n') && (ch != '\t') && (ch != '\b')) return;   /*===========================================*/   /* Don't let them backspace over old output. */   /*===========================================*/   if ((ch == '\b') && (CLIPSInputCount == 0)) return;   /*=========================================*/   /* Make the cursor invisible while typing. */   /*=========================================*/   ObscureCursor();   /*===========================*/   /* Remove the old selection. */   /*===========================*/         ExtendDisplaySelection(whichWindow,SelectionLineStart,SelectionCharStart,                                      SelectionLineEnd,SelectionCharEnd);   SelectionLineStart = SelectionCharStart = SelectionLineEnd = SelectionCharEnd = 0;   /*============================================*/   /* Print the character to the display window. */   /*============================================*/   inp[0] = ch;   inp[1] = '\0';   PrintCLIPS("stdout",inp);   /*==========================================*/   /* Add the character to the command string. */   /*==========================================*/#if ! RUN_TIME   ExpandCommandString(ch);#endif   /*=================================*/   /* Select the display window, then */   /* show the line being entered.    */   /*=================================*/   SelectDisplayWindow();   if ((ch == '\r') || (ch == '\n')) ShowDisplayEnd(TRUE);   else ShowDisplayEnd(false);      if (ch == ')')      {        if (FindBalancingParenthesis(&whichLine,&whichChar))         {         DrawCursor();         ExtendDisplaySelection(whichWindow,whichLine,whichChar,                                            whichLine,whichChar+1);                                                     startTime = TickCount();          while (TickCount() < (startTime + BALANCE_PARENTHESIS_PAUSE_DURATION))           { /* Wait */ }                                                   ExtendDisplaySelection(whichWindow,whichLine,whichChar,                                            whichLine,whichChar+1);         DrawCursor();        }      else        { SysBeep(10); }     }  }  /*********************************************************************//* DisplayPrintRoutine: Prints the display window to a print record. *//*********************************************************************/void DisplayPrintRoutine(hPrint,whichWindow)  THPrint hPrint;  WindowPtr whichWindow;  {   register int line = 0;   register int lastLineOnPage = 0;   int length;   int cur_line;   Rect printRect;   int linesPerPage;   int lineBase;   int lineHeight;   FontInfo info;   TPPrPort printPort;   /*====================================*/   /* Initialize a printing grafPort for */   /* use in printing a document.        */   /*====================================*/   printPort = PrOpenDoc( hPrint, 0L, 0L );   /*==============================================================*/   /* Make the current port the printing port. Note that PrOpenDoc */   /* should have already made printPort the current port.         */   /*==============================================================*/   SetPort((GrafPtr) printPort);   /*===============================================================*/   /* Set the appropriate font type and size for the printing port. */   /*===============================================================*/   TextFont((*((GrafPtr) whichWindow)).txFont);   TextSize((*((GrafPtr) whichWindow)).txSize);   /*===============================================*/   /* Determine the line height and number of lines */   /* per page for the printing port.               */   /*===============================================*/   printRect = (**hPrint).prInfo.rPage;   GetFontInfo( &info );   lineHeight = info.leading + info.ascent + info.descent;   linesPerPage =        (printRect.bottom - printRect.top - TOP_PRINT_MARGIN - BOTTOM_PRINT_MARGIN) / lineHeight;   /*=======================================*/   /* Print the document page by page until */   /* the end of document is reached.       */   /*=======================================*/   while (line < LinesInUse)     {      /*==================================================*/      /* Inform the Printing Manager to begin a new page. */      /*==================================================*/      PrOpenPage( printPort, 0L );      /*============================================*/      /* Compute the last line on the current page. */      /*============================================*/      lastLineOnPage += linesPerPage;      /*=================================================*/      /* Position the pen in the upper left of the page. */      /*=================================================*/      lineBase = printRect.top + lineHeight;      MoveTo(printRect.left + LEFT_PRINT_MARGIN,lineBase);      /*=========================================================*/      /* Print the current page line by line until the last line */      /* on the page or the end of the document is reached.      */      /*=========================================================*/      while (line < lastLineOnPage)        {         /*==================================================*/         /* Print the line. Note that tab characters have no */         /* special meaning to DrawText.                     */         /*==================================================*/         cur_line = ZeroDisplayLine + line % MAX_DISPLAY_LINES;         length = DisplayText[cur_line].insertPoint;         if (length > 0)           { DrawText(DisplayText[cur_line].lineInfo,0,length); }         /*====================================*/         /* Position the pen at the next line. */         /*====================================*/         lineBase += lineHeight;         MoveTo(printRect.left + LEFT_PRINT_MARGIN,lineBase);         /*====================*/         /* Update line count. */         /*====================*/         line++;        }      /*==================================*/      /* Inform the Printing Manager that */      /* the current page is finished.    */      /*==================================*/      PrClosePage( printPort );     }   /*==============================*/   /* Close the printing grafPort. */   /*==============================*/   PrCloseDoc( printPort );  }  /*****************************************************************//* FindBalancingParenthesis                                        *//*****************************************************************/static Boolean FindBalancingParenthesis(  long *whichLine,  long *whichChar)  {   int theLine, theCharIndex, theChar;   int depth = 1, backupCount;         backupCount = CLIPSInputCount - 1;   theLine = AppendDisplayLine;   theCharIndex = DisplayText[theLine].insertPoint - 2;   while (TRUE)     {      while (theCharIndex >= 0)        {         theChar = DisplayText[theLine].lineInfo[theCharIndex];         if (theChar == ')')           { depth++; }         else if (theChar == '(')           { depth--; }                    if (depth == 0)           {            *whichLine = theLine;            *whichChar = theCharIndex;            return(TRUE);           }                    theCharIndex--;         backupCount--;         if (backupCount < 0)            { return(FALSE); }        }              /*===========================================*/      /* If all the lines have been searched, then */      /* a balancing parenthesis was not found.    */      /*===========================================*/            if (theLine == ZeroDisplayLine)        { return(FALSE); }            /*============================*/      /* Move to the previous line. */      /*============================*/              theLine--;            if (theLine < 0)        { theLine += MAX_DISPLAY_LINES; }              theCharIndex = DisplayText[theLine].insertPoint - 1;     }   return(FALSE);  }