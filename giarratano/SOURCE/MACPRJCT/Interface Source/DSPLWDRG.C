   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  11/27/95          */   /*                                                     */   /*             DISPLAY WINDOW DRAG MODULE              */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _DSPLWDRG_SOURCE_#include "setup.h"#include <Drag.h>#include "commline.h"#include "constrct.h"#include "cstrcpsr.h"#include "filecom.h"#include "router.h"#include "strngrtr.h"#include "apprsrcs.h"#include "displayw.h"#include "interface.h"#include "stnrdmac.h"#include "undo.h"#include "window.h"#include "dsplwdrg.h"#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif/*======================================*//* Background Mouse Handler Definitions *//*======================================*/typedef pascal OSErr (*BackgroundMouseHandlerProcPtr)                (const EventRecord *event, short *actionCode);                typedef UniversalProcPtr BackgroundMouseHandlerUPP;enum {	uppInstallBackgroundMouseHandlerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(const EventRecord *)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short *)))};typedef BackgroundMouseHandlerUPP BackgroundMouseHandler;pascal OSErr InstallBackgroundMouseHandler(BackgroundMouseHandlerUPP handler)   THREEWORDINLINE(0x3F3C, 0x0055, 0xA88F);   /***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static RgnHandle        GetEditDragRegion(TEHandle);   static pascal OSErr     DragTrackingHandlerHook(DragTrackingMessage,WindowPtr,                                                   void *,DragReference);   static pascal OSErr     DragReceiveHandlerHook(WindowPtr,void *,DragReference);   static void             DoEditDragAndDrop(DragReference,char *,Size,WindowPtr);   static short            DrawCaret(short,TEHandle);   static short            TEGetLine(short,TEHandle);   static short            TEIsFrontOfLine(short,TEHandle);   static short            HitTest(Point,TEHandle);   static pascal OSErr     CheckForBackgroundMouseDrag(const EventRecord *,short *);   static int              DisplayTrackDrag(int,DragAttributes,DragReference);   static pascal OSErr     DragSendDataHook(FlavorType,void *,ItemReference,DragReference);   static RgnHandle        GetDisplayDragRegion(WindowPtr);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/      static int              InContent;   #if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor  DragTrackingHandlerHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragTrackingHandlerProcInfo,DragTrackingHandlerHook);   static RoutineDescriptor  DragReceiveHandlerHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragReceiveHandlerProcInfo,DragReceiveHandlerHook);   static RoutineDescriptor  DragSendDataHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDragSendDataProcInfo,DragSendDataHook);#define DragSendDataRef &DragSendDataHookRD#define DragTrackingHandlerHookRef &DragTrackingHandlerHookRD#define DragReceiveHandlerHookRef &DragReceiveHandlerHookRD#else#define DragSendDataRef DragSendDataHook#define DragTrackingHandlerHookRef DragTrackingHandlerHook#define DragReceiveHandlerHookRef DragReceiveHandlerHook#endif/*************************************************//* DragTrackingHandlerHook: Callback routine for *//*   tracking a drag through the display window. *//*************************************************/   static pascal OSErr DragTrackingHandlerHook(  DragTrackingMessage theMessage,  WindowPtr theWindow,  void *handlerRefCon,  DragReference theDrag)  { #if MAC_MPW || MAC_MCW#pragma unused(handlerRefCon)#endif     static int canAcceptDrag;   DragAttributes attributes;   Handle dataHandle;      GetDragAttributes(theDrag,&attributes);      /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle. Retrieve a   */   /* pointer to window's text record          */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(theWindow);   HLock(dataHandle);      switch(theMessage)     {      case dragTrackingEnterHandler:        canAcceptDrag = false;        InContent = false;                break;              case dragTrackingEnterWindow:        canAcceptDrag = IsTextDragTypeAvailable(theDrag);         InContent = false;        break;              case dragTrackingInWindow:        if (! canAcceptDrag) break;        InContent = DisplayTrackDrag(InContent,attributes,theDrag);        break;      case dragTrackingLeaveWindow:              HideDragHilite(theDrag);        DrawCompileBatchArea(false,false);        canAcceptDrag = false;        break;           case dragTrackingLeaveHandler:        HideDragHilite(theDrag);        DrawCompileBatchArea(false,false);        break;     }      /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);      return(noErr);  }  /*************************************************//* DisplayTrackDrag: *//*************************************************/   static int DisplayTrackDrag(  int currentLocation,  DragAttributes attributes,  DragReference theDrag)  {    RgnHandle hiliteRgn;     Point mouse, localMouse;   Rect dropArea1, dropArea2;   short theHeight, theWidth;    SetPort(DisplayWindow);      /*=======================================*/   /* Determine where the mouse is located. */   /*=======================================*/      GetDragMouse(theDrag, &mouse, 0L);   localMouse = mouse;   GlobalToLocal(&localMouse);   /*=========================================*/   /* Compute the location of the drop areas. */   /*=========================================*/      dropArea1 = (*CompileAreaBWPic)->picFrame;   theHeight = (*CompileAreaBWPic)->picFrame.bottom -                    (*CompileAreaBWPic)->picFrame.top;   theWidth = (*CompileAreaBWPic)->picFrame.right -                   (*CompileAreaBWPic)->picFrame.left;   OffsetRect(&dropArea1,-1,                   (*DisplayWindow).portRect.bottom - (theHeight - 1));           dropArea2 = (*BatchAreaBWPic)->picFrame;   OffsetRect(&dropArea2,-2 + theWidth,(*DisplayWindow).portRect.bottom - (theHeight - 1));            /*==========================================*/   /* Is the mouse over the compile drop area? */   /*==========================================*/                   if (PtInRect(localMouse,&dropArea1))     {              if (currentLocation == 1) return(1);                      HideDragHilite(theDrag);                DrawCompileBatchArea(TRUE,false);      if (WindowDepth(DisplayWindow) >= 8)          {          return(1);         }              InsetRect(&dropArea1,1,1);                       hiliteRgn = NewRgn();      RectRgn(hiliteRgn,&dropArea1);                               ShowDragHilite(theDrag, hiliteRgn, TRUE);                       DisposeRgn(hiliteRgn);                      return(1);     }            /*========================================*/   /* Is the mouse over the batch drop area? */   /*========================================*/      if (PtInRect(localMouse,&dropArea2))     {      if (currentLocation == 2) return(2);               HideDragHilite(theDrag);            DrawCompileBatchArea(false,TRUE);      if (WindowDepth(DisplayWindow) >= 8)          {          return(2);         }              InsetRect(&dropArea2,1,1);                       hiliteRgn = NewRgn();      RectRgn(hiliteRgn,&dropArea2);                                                ShowDragHilite(theDrag, hiliteRgn, TRUE);                       DisposeRgn(hiliteRgn);                      return(2);        }   if (currentLocation)     {      if (attributes & dragHasLeftSenderWindow)         { HideDragHilite(theDrag); }     }        HideDragHilite(theDrag);   DrawCompileBatchArea(false,false);         return(false);  }    /***********************************************//* SetupDisplayWindowDragAndDrop: Installs the *//*   tracking and receive callback routines    *//*   for drag and drop in the display window.  *//***********************************************/   Boolean SetupDisplayWindowDragAndDrop(  WindowPtr theWindow)  {      OSErr result;   /*=======================*/   /* Set up drag and drop. */   /*=======================*/   if (DragManagerPresent)     {      result = InstallTrackingHandler(DragTrackingHandlerHookRef,                                      theWindow,NULL);         result = InstallReceiveHandler(DragReceiveHandlerHookRef,                                     theWindow,NULL);     }        return(TRUE);  }  /***********************************************//* RemoveDisplayWindowDragAndDrop: Removes the *//*   tracking and receive callback routines    *//*   for drag and drop in the display window.  *//***********************************************/   void RemoveDisplayWindowDragAndDrop(  WindowPtr theWindow)  {   if (DragManagerPresent)     {      RemoveReceiveHandler((DragReceiveHandler) DragTrackingHandlerHookRef,theWindow);     }  }/*****************************************************//* DrawCompileBatchArea: Draws the Compile and Batch *//*   drop areas in the lower left of the window.     *//*****************************************************/void DrawCompileBatchArea(  short compileHilited,  short batchHilited)  {      Rect theRect;   short theHeight, theWidth;   PicHandle compileAreaPic, batchAreaPic;   if (WindowDepth(DisplayWindow) < 8)     {      compileAreaPic = CompileAreaBWPic;      batchAreaPic = BatchAreaBWPic;     }   else     {      if (compileHilited) compileAreaPic = CompileAreaHilitePic;      else compileAreaPic = CompileAreaColorPic;            if (batchHilited) batchAreaPic = BatchAreaHilitePic;      else batchAreaPic = BatchAreaColorPic;     }   theRect = (*compileAreaPic)->picFrame;   theHeight = (*compileAreaPic)->picFrame.bottom -               (*compileAreaPic)->picFrame.top;   theWidth = (*compileAreaPic)->picFrame.right -               (*compileAreaPic)->picFrame.left;   OffsetRect(&theRect,-1,(*DisplayWindow).portRect.bottom - (theHeight - 1));   DrawPicture(compileAreaPic,&theRect);   theRect = (*batchAreaPic)->picFrame;   OffsetRect(&theRect,-2 + theWidth,(*DisplayWindow).portRect.bottom - (theHeight - 1));   DrawPicture(batchAreaPic,&theRect);  } /**********************************************************//* DragReceiveHandlerHook: Performs the necessary actions *//*   for the drop of TEXT data into the display window.   *//**********************************************************/static pascal OSErr DragReceiveHandlerHook(  WindowPtr theWindow,  void *handlerRefCon,  DragReference theDrag)  {   #if MAC_MPW || MAC_MCW#pragma unused(theWindow)#pragma unused(handlerRefCon)#endif   unsigned short items;   short index;   ItemReference theItem;   FlavorFlags theFlags;   Size dataSize, totalSize;   char *dragData, *tempPtr;   OSErr result;    /*======================================*/   /* Verify that the data is all text and */   /* there is a valid insertion position. */   /*======================================*/      if (! IsTextDragTypeAvailable(theDrag))     { return(dragNotAcceptedErr); }    /*===============================*/   /* Determine the number of items */   /* being dragged and dropped.    */    /*===============================*/      result = CountDragItems(theDrag,&items);   if (result != noErr) return(result);     /*===============================*/   /* Determine the total amount of */   /* text data being dropped.      */   /*===============================*/     for (index = 1, totalSize = 0; index <= items; index++)     {      result = GetDragItemReferenceNumber(theDrag,index,&theItem);      if (result != noErr) return(result);            result = GetFlavorFlags(theDrag,theItem,'TEXT',&theFlags);      if (result != noErr) return(result);              result = GetFlavorDataSize(theDrag,theItem,'TEXT',&dataSize);      if (result != noErr) return(result);              totalSize += dataSize;     }   /*==============================*/   /* Allocate memory to store the */   /* text of the drag items.      */   /*==============================*/     dragData = NewPtr(totalSize+1);   if (dragData == NULL) return(dragNotAcceptedErr);   tempPtr = dragData;   dragData[totalSize] = '\0';      /*==================================*/   /* Store the text of the drag items */   /* in the allocated text buffer.    */   /*==================================*/     for (index = 1; index <= items; index++)     {      result = GetDragItemReferenceNumber(theDrag,index,&theItem);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            result = GetFlavorFlags(theDrag,theItem,'TEXT',&theFlags);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            result = GetFlavorDataSize(theDrag,theItem,'TEXT',&dataSize);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }            GetFlavorData(theDrag,theItem,'TEXT',tempPtr,&dataSize,0L);      if (result != noErr)         {         DisposePtr(dragData);         return(result);        }              tempPtr += dataSize;     }        /*=======================================*/   /* Either compile or batch the text data */   /* dropped in the display window.        */   /*=======================================*/   SelectDisplayWindow();      if (InContent == 1)     {       ShowDisplayEnd(TRUE);      PrintCLIPS("stdout","Loading Selection...\n");      FlushCommandString();      OpenStringSource("DropCompile",dragData,0);      SetPrintWhileLoading(TRUE);      LoadConstructsFromLogicalName("DropCompile");      SetPrintWhileLoading(false);      CloseStringSource("DropCompile");      PrintCLIPS("stdout",COMMAND_PROMPT);      DisposePtr(dragData);      }   else if (InContent == 2)     { OpenStringBatch("DropBatch",dragData,false); }      /*==============================*/   /* Drop successfully completed. */   /*==============================*/         return(noErr);  }    /**********************************************************//* DragSendDataHook: Callback routine for retrieving the  *//*   text data "stored" in a drag from an display window. *//**********************************************************/   static pascal OSErr DragSendDataHook(  FlavorType theType,  void *dragSendRefCon,  ItemReference theItem,   DragReference theDrag)  {      TEHandle theTextHandle;   char *theString;   Size theSize;   OSErr result;   long length;      theTextHandle = (TEHandle) dragSendRefCon;      switch(theType)      {      case 'TEXT':         theString = DisplaySelectionText(&length);        theSize = length;        result = SetDragItemFlavorData(theDrag,theItem,'TEXT',                                       theString,theSize,0L);        DisposPtr(theString);        break;                  default:        result = badDragFlavorErr;        break;     }        return(result);  } /**********************************************//* DoDisplayStartDrag: Handles the start of a *//*   drag mouse action in the display window. *//**********************************************/OSErr DoDisplayStartDrag(  EventRecord *theEvent,  WindowPtr theWindow)  {   OSErr result;   DragReference theDrag;   RgnHandle dragRegion;	   /*==========================*/   /* Create a drag reference. */   /*==========================*/      if ((result = NewDrag(&theDrag)) != noErr)      { return(result); }      /*=================================================*/    /* Add a text item to the drag item. The text data */   /* will be supplied upon request if needed.        */   /*=================================================*/       if ((result = AddDragItemFlavor(theDrag,0,'TEXT',NULL,0,0)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }        /*============================================*/   /* Get the outline of the text being dragged. */   /*============================================*/   dragRegion = GetDisplayDragRegion(theWindow);   /* NULL used to be theText in the following call. */      if ((result = SetDragSendProc(theDrag,DragSendDataRef,NULL)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }       if ((result = TrackDrag(theDrag,theEvent,dragRegion)) != noErr)     {      DisposeDrag(theDrag);      return(result);     }        /*======================*/   /* Dispose of the drag. */   /*======================*/      DisposeRgn(dragRegion);   DisposeDrag(theDrag);   return(result);  }/**********************************************************//* GetDisplayDragRegion: Gets the outline of the selected *//*   region of the display window being grabbed.          *//**********************************************************/static RgnHandle GetDisplayDragRegion(  WindowPtr theWindow)  {   RgnHandle dragRegion, tempRegion;   Point globalPoint;      /*=============================*/   /* Get the region of selected  */   /* text in the display window. */   /*=============================*/      dragRegion = DisplaySelectionRegion(theWindow);      /*=============================================*/   /* Change the region such that it has the same */   /* outline, but is only one pixel thick.       */   /*=============================================*/      tempRegion = NewRgn();   CopyRgn(dragRegion,tempRegion);   InsetRgn(tempRegion,1,1);   DiffRgn(dragRegion,tempRegion,dragRegion);   DisposeRgn(tempRegion);      /*====================================*/   /* Convert the location of the region */   /* from local to global coordinates.  */   /*====================================*/      globalPoint.v = globalPoint.h = 0;   LocalToGlobal(&globalPoint);   OffsetRgn(dragRegion,globalPoint.h,globalPoint.v);      /*=========================*/   /* Return the drag region. */   /*=========================*/      return(dragRegion);  }  /*******************************************************//* DoDisplayDragAndDrop: Determines if a drag and drop *//*   operation should be performed in the display      *//*   window. If so, the operation is performed and     *//*   TRUE is returned. Otherwise, FALSE is returned.   *//*******************************************************/   Boolean DoDisplayDragAndDrop(  EventRecord *theEvent,  WindowPtr theWindow)  {   Boolean rv = false;   if (WaitMouseMoved(theEvent->where))     {       DoDisplayStartDrag(theEvent,theWindow);      rv = TRUE;     }        return(rv);  }   /***********************************************//* ClickInDisplayDragRegion: Returns TRUE if a *//*   mouse click occurred in a dragable region *//*   in the display window.                    *//***********************************************/   Boolean ClickInDisplayDragRegion(  Point thePoint)  {   RgnHandle theRegion;   Boolean rv = false;      if (! DragManagerPresent) return(false);   theRegion = NewRgn();      theRegion = DisplaySelectionRegion(DisplayWindow);         if (PtInRgn(thePoint,theRegion))     { rv = TRUE; }        DisposeRgn(theRegion);     return(rv);  }  