   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                  FILE MENU MODULE                   */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _FILEMENU_SOURCE_#include "setup.h"#include "constant.h"#include <stddef.h>#include <stdio.h>#include <string.h>#include <Devices.h>/* #include <Desk.h> */#include <Memory.h>#include <TextEdit.h>#include <Controls.h>#include <Fonts.h>#include <Menus.h>#include <Resources.h>#include <TextUtils.h>#if MAC_MCW || MAC_SC8#define CPFHookPtr ModalFilterYDUPP#else#define CPFHookPtr DlgHookYDProcPtr#endif#if MAC_TC#include <BDC.h>#endif#include <Packages.h>#include <Events.h>#include <Files.h>#if MAC_MCW || MAC_SC7 || MAC_MPW || MAC_SC8#include <Printing.h>#else#include <PrintTraps.h>#endif#include <Errors.h>#include <Lists.h>#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#if MAC_SC7 || MAC_MCW || MAC_SC8#define TEClickPtr TEClickLoopUPP#define TEBreakPtr WordBreakUPP#endif#if MAC_TC6#define TEClickPtr ProcPtr#define TEBreakPtr WordBreakProcPtr#endif#if MAC_MPW#define TEClickPtr ClikLoopProcPtr#define TEBreakPtr WordBreakProcPtr#endif#if MAC_SC7 || MAC_SC8#define PTOCSTR(x) P2CStr((StringPtr) x)#define CTOPSTR C2PStr#else#define PTOCSTR(x) p2cstr((StringPtr) x)#define CTOPSTR c2pstr#endif#define PSTRCAST StringPtr#include "appevent.h"#include "apprsrcs.h"#include "mpsrrsrc.h"#include "interface.h"#include "menucmds.h"#include "print.h"#include "window.h"#include "displayw.h"#include "editmenu.h"#include "search.h"#include "undo.h"#include "mainloop.h"#include "filemenu.h"#include "editdlog.h"#include "editw.h"#include "editscrl.h"#include "editwdrg.h"#include "stnrdmac.h"#include "kbstatw.h"/***************//* DEFINITIONS *//***************/#define WindowPlacements 50#define TextMargin 4#define MAX_BUFFER_SIZE (32767L)#define StopCantDoID 1009#define SaveAsDialogID 400#define BatchFileCheckBoxID 13/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static int                    OffsetWindow (WindowPtr);   static void                   DoOpen(void);   static void                   CloseSysWindow(void);   static void                   DoSave(WindowPtr);   static void                   DoSaveAs(WindowPtr);   static void                   WriteFile(short,FSSpec *,long,WindowPtr,TEHandle);   static void                   DoRevert(WindowPtr,short);   static void                   IOCheck(OSErr);   static pascal short int       SaveAsDialogHook(short int,DialogPtr,Ptr);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static int              WindowCount[WindowPlacements];   static int              BatchFile = 0;   #if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor  SaveAsDialogHookRD       = BUILD_ROUTINE_DESCRIPTOR(uppDlgHookYDProcInfo,SaveAsDialogHook);#define SaveAsDialogHookRef &SaveAsDialogHookRD#else#define SaveAsDialogHookRef SaveAsDialogHook#endif/***********************************************//* DOFILECHOICE: Handle choice from file menu. *//***********************************************/void DoFileChoice (theItem,whichWindow) int theItem; WindowPtr whichWindow; {  switch (theItem)    {     /*=====================*/     /* Handle New command. */     /*=====================*/     case NewItem:       DoNew(NULL,NULL);       break;     /*=========================*/     /* Handle Open... command. */     /*=========================*/     case OpenItem:       DoOpen();       break;     /*===============================*/     /* Handle Load Rules... command. */     /*===============================*/     case LoadItem:       DoLoad(TEXT_FILE);       break;     /*===============================*/     /* Handle Load Batch... command. */     /*===============================*/     case LoadBatchItem:       DoLoad(BATCH_FILE);       break;     /*===============================*/     /* Handle Load Binary... command. */     /*===============================*/     case LoadBinaryItem:       DoLoad(BINARY_FILE);       break;     /*================================*/     /* Handle OpenDribble... command. */     /*================================*/     case OpenDribbleItem:       DoDribble();       break;     /*=======================*/     /* Handle Close command. */     /*=======================*/     case CloseItem:       DoClose(FrontWindow());       break;     /*======================*/     /* Handle Save command. */     /*======================*/     case SaveItem:       DoSave(whichWindow);       break;     /*============================*/     /* Handle Save As... command. */     /*============================*/     case SaveAsItem:       DoSaveAs(whichWindow);       break;     /*============================*/     /* Handle Save Binary... command. */     /*============================*/     case SaveBinaryItem:       DoSaveBinary();       break;     /*========================*/     /* Handle Revert command. */     /*========================*/     case RevertItem:       DoRevert(whichWindow,true);       break;     /*===============================*/     /* Handle Page Setup... command. */     /*===============================*/     case PageSetupItem:       DoPageSetup();       break;     /*==========================*/     /* Handle Print... command. */     /*==========================*/     case PrintItem:       DoPrint(FrontWindow());       break;     /*======================*/     /* Handle Quit command. */     /*======================*/     case  QuitItem:       DoQuit();       break;    } }/******************************//* DoNew: Handle New command. *//******************************/WindowPtr DoNew(  Str255 windowName,  EditRSRCHdl theMPSR)  {   EWDHandle theData;   Handle dataHandle;   Rect destRect, viewRect;   Rect scrollRect;   int posValue;   Str255 theTitle;   static int untitledID = 1;   WindowPtr whichWindow;   short fontNumber;   short titleWidth;   short constructMenuWidth;   /*================================*/   /* Make new window from template. */   /*================================*/   whichWindow = GetNewWindow(windowID,(Ptr) NULL,(WindowPtr) -1L);   if (whichWindow == NULL) return(NULL);      if (windowName == NULL)     {      sprintf((char *) theTitle,"Untitled%d",untitledID++);      CTOPSTR((char *) theTitle);      SetWTitle(whichWindow,theTitle);     }   else     { SetWTitle(whichWindow,windowName); }   /*========================================*/   /* Offset the window from the location of */   /* the previous window and then show it.  */   /*========================================*/   if (theMPSR == NULL)     {      posValue = OffsetWindow(whichWindow);     }   else     {       titleWidth = ((WindowPeek) whichWindow)->titleWidth;      HLock((Handle) theMPSR);      if ((((*theMPSR)->windrsrc.openrect.right - (*theMPSR)->windrsrc.openrect.left) > 40) &&          (((*theMPSR)->windrsrc.openrect.bottom - (*theMPSR)->windrsrc.openrect.top) > 40))        {         SizeWindow(whichWindow,                    (*theMPSR)->windrsrc.openrect.right - (*theMPSR)->windrsrc.openrect.left,                    (*theMPSR)->windrsrc.openrect.bottom - (*theMPSR)->windrsrc.openrect.top,                    false);        }            if ((((*theMPSR)->windrsrc.openrect.top - titleWidth) <= MENU_BAR_HEIGHT) ||          (((*theMPSR)->windrsrc.openrect.top - titleWidth) >= GetScreenHeight()) ||          (((*theMPSR)->windrsrc.openrect.left) >= GetScreenWidth()) ||          (((*theMPSR)->windrsrc.openrect.right) <= 0))        {         posValue = OffsetWindow(whichWindow);        }      else        {         posValue = -1;         MoveWindow(whichWindow,(*theMPSR)->windrsrc.openrect.left,                                (*theMPSR)->windrsrc.openrect.top,                                false);               }              HUnlock((Handle) theMPSR);     }      ShowWindow(whichWindow);   /*=================================================================*/   /* Set the port to the current window. Set the text font and size. */   /*=================================================================*/   SetPort(whichWindow);   if (theMPSR == NULL)     {      TextFont(monaco);      TextSize(9);     }   else     {      HLock((Handle) theMPSR);            (*theMPSR)->fontrsrc.name[31] = 0;      CTOPSTR((*theMPSR)->fontrsrc.name);      GetFNum((ConstStr255Param) (*theMPSR)->fontrsrc.name,&fontNumber);      PTOCSTR((*theMPSR)->fontrsrc.name);      if (fontNumber)        { TextFont(fontNumber); }      else        { TextFont(monaco); }         TextSize((*theMPSR)->fontrsrc.size);            HUnlock((Handle) theMPSR);     }   /*=============================================*/   /* Set up the clipping rectangle and inset the */   /* wrapping rectangle by the text margin.      */   /*=============================================*/   SetRect(&viewRect,0,0,(*whichWindow).portRect.right - (SCROLL_BAR_WIDTH - 1),                         (*whichWindow).portRect.bottom - (SCROLL_BAR_WIDTH - 1));   InsetRect(&viewRect,TextMargin,TextMargin);   destRect = viewRect;   /*=============================================*/   /* Allocate the window's data record and store */   /* it as the window's reference constant.      */   /*=============================================*/   dataHandle = NewHandle((Size) sizeof(EditWindowData));   SetWRefCon(whichWindow,(long int) dataHandle);   /*=====================================================*/   /* Lock the data record and convert to a typed handle. */   /*=====================================================*/   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   (**theData).windowInfo.windowType = EDIT_WINDOW;   (**theData).windowInfo.growRoutine = GrowEditWindow;   (**theData).windowInfo.zoomRoutine = GrowEditWindow;   (**theData).windowInfo.contentRoutine = DoEditContent;   (**theData).windowInfo.updateRoutine = UpdateEditWindow;   (**theData).windowInfo.activateRoutine = DoEditActivate;   (**theData).windowInfo.deactivateRoutine = DoEditDeactivate;   (**theData).windowInfo.closeRoutine = CloseTextWindow;   (**theData).windowInfo.cursorRoutine = FixEditCursor;   (**theData).windowInfo.printRoutine = EditPrintRoutine;   (**theData).windowInfo.menuUpdateRoutine = EditMenuUpdateRoutine;   (**theData).windowInfo.keystrokeRoutine = DoEditTyping;   (**theData).windowInfo.applicationHook = EditApplicationHook;   InitializeUndoEditInfo(&(*theData)->undoInfo);   /*========================*/   /* Create an edit record. */   /*========================*/   (**theData).editRec = TENew(&destRect,&viewRect);   (**theData).fileType = 'TEXT';   /*=================================================*/   /* Don't allow wrap around when text is displayed. */   /*=================================================*/   (**(**theData).editRec).crOnly = -1;      /*================================*/   /* Activate the text edit record. */   /*================================*/      TEActivate((**theData).editRec);    /*===============================*/   /* Create a vertical scroll bar. */   /*===============================*/   scrollRect = (*whichWindow).portRect;   scrollRect.left = scrollRect.right - (SCROLL_BAR_WIDTH - 1);   scrollRect.right += 1;   scrollRect.bottom -= 14;   scrollRect.top -= 1;   (**theData).windowInfo.vScrollBar = NewControl(whichWindow,&scrollRect, "\p",                                                  1, 0, 0, 0,scrollBarProc,0L);   /*=================================*/   /* Create a horizontal scroll bar. */   /*=================================*/   constructMenuWidth = ((*ConstructsAreaBWPic)->picFrame.right -                         (*ConstructsAreaBWPic)->picFrame.left) - 1;                               scrollRect = (*whichWindow).portRect;   scrollRect.top = scrollRect.bottom-15;   scrollRect.bottom += 1;   scrollRect.right -= 14;   scrollRect.left += (constructMenuWidth - 1);   (**theData).windowInfo.hScrollBar = NewControl(whichWindow,&scrollRect,"\p",                                                  1, 0, 0, 0,scrollBarProc, 0L);   /*========================================================*/   /* The window is initially clean, has no associated file, */   /* and has been given a placement value by OffsetWindow.  */   /*========================================================*/   (**theData).dirty = false;   (*theData)->associatedWithFile = false;    (**theData).placementPos = posValue;   (**theData).shiftSelectionAnchor = 0;      /*==============================*/   /* Install auto-scroll routine. */   /*==============================*/   SetClikLoop((TEClickPtr) AutoScrollRef,(**theData).editRec);#if ! MAC_SC7   SetWordBreak((TEBreakPtr) WordBreakRef,(**theData).editRec);#endif   /*=================================================*/   /* Make sure text margins are set properly so that */   /* text does not "jump" upon initial text entry.   */   /*=================================================*/   FixText(whichWindow);   /*=======================*/   /* Set up drag and drop. */   /*=======================*/      SetupEditWindowDragAndDrop(whichWindow,(**theData).editRec);        /*=====================*/   /* Unlock data record. */   /*=====================*/   HUnlock(dataHandle);   /*====================================*/   /* Add the window to the Window menu. */   /*====================================*/   AddWindowToMenu(whichWindow);   return(whichWindow);  }/************************************************//* OffsetWindow: Offset location of new window. *//************************************************/static int OffsetWindow (whichWindow)  WindowPtr whichWindow;  {   int windowWidth, windowHeight;   int hExtra, vExtra;   int hMax, vMax;   int windowLeft, windowTop;   int i, bestPlace;   /*=======================================*/   /* Determine location on screen that has */   /* the least number of stacked windows.  */   /*=======================================*/   bestPlace = 0;   for (i = 1 ; i < WindowPlacements ; i++)     {      if (WindowCount[i] < WindowCount[bestPlace]) bestPlace = i;     }   /*===========================================*/   /* Get window dimensions from port rectangle */   /* and adjust for title bar.                 */   /*===========================================*/   windowWidth = (*whichWindow).portRect.right - (*whichWindow).portRect.left;   windowHeight = (*whichWindow).portRect.bottom - (*whichWindow).portRect.top;   windowHeight = windowHeight + TitleBarHeight;   /*======================================*/   /* Find excess screen width and height. */   /*======================================*/   hExtra = GetScreenWidth() - windowWidth;   vExtra = GetScreenHeight() - (windowHeight + MENU_BAR_HEIGHT);   /*=============================================================*/   /* Find maximum number of windows horizontally and vertically. */   /*=============================================================*/   hMax = (hExtra / hOffset) + 1;   vMax = (vExtra / vOffset) + 1;   /*============================================*/   /* Update count of number of window's stacked */   /* in the new window's location.              */   /*============================================*/   WindowCount[bestPlace] += 1;   /*============================================*/   /* Calculate offsets for new window adjusting */   /* for the title bar and the menu bar.        */   /*============================================*/   windowLeft = ((bestPlace + 1) % hMax) * hOffset;   windowTop =  ((bestPlace + 1) % vMax) * vOffset;   windowTop += TitleBarHeight + MENU_BAR_HEIGHT;   /*======================================*/   /* Move the window to its new location. */   /*======================================*/   MoveWindow(whichWindow,windowLeft,windowTop,false);   /*=====================================*/   /* Return the window's stack location. */   /*=====================================*/   return(bestPlace);  }/***********************************//* DoOpen: Handle Open... command. *//***********************************/static void DoOpen()  {   SFTypeList theTypeList;   StandardFileReply theReply;   /*========================================*/   /* Display only text files in the dialog. */   /*========================================*/   theTypeList[0] = 'TEXT';   theTypeList[1] = 'BTCH';   /*==========================*/   /* Get file name from user. */   /*==========================*/      StandardGetFile(NULL,2,theTypeList,&theReply);   /*===============================*/   /* Do nothing if the user didn't */   /* confirm the file selection.   */   /*===============================*/      if (! theReply.sfGood) return;      /*=============================================*/   /* Reset the current volume so that UNIX fopen */   /* function will find the folder (if a load    */   /* or batch command is give later).            */   /*=============================================*/   SetDirectory(&theReply.sfFile);      /*==========================================*/   /* Send the application an open AppleEvent. */   /*==========================================*/   SendAEOpenCommand(&theReply.sfFile);   /*========================================*/   /* Open the file and read it into window. */   /*========================================*/         /* DoOpenFile(&theReply.sfFile,theReply.sfType); */     }/***********************************//* DoOpenFile: Open document file. *//***********************************/WindowPtr DoOpenFile(theFSSpec,fileType)  FSSpec *theFSSpec;  OSType fileType;  {   EWDHandle theData;   Handle dataHandle, tempHandle;   short int theFile;   OSErr resultCode;   long logEOF;   WindowPtr whichWindow;   short fileReference;   OSErr resourceError;   EditRSRCHdl theMPSR = NULL;   int scrollPosition;   TEHandle theText;   ControlHandle theVScrollBar;   /*=============================================*/   /* Reset the current volume so that UNIX fopen */   /* function will find the folder (if a load    */   /* or batch command is give later).            */   /*=============================================*/   SetDirectory(theFSSpec);      /*========================================================*/   /* Open the file. Check for error and exit if one occurs. */   /*========================================================*/      resultCode = FSpOpenDF(theFSSpec,fsCurPerm,&theFile);   IOCheck(resultCode);   if (ErrorFlag) return(NULL);      /*====================================================*/   /* Check that the file is not too large to be edited. */   /*====================================================*/   resultCode = GetEOF(theFile,&logEOF);   IOCheck(resultCode);   if (ErrorFlag)     {      resultCode = FSClose(theFile);      IOCheck(resultCode);      return(NULL);     }   if (logEOF >= MAX_BUFFER_SIZE)     {      ParamText("\pFile is too large to open ",                "\p(only files 32K or smaller can be edited)","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      resultCode = FSClose(theFile);      IOCheck(resultCode);      return(NULL);     }   /*=========================================*/   /* Look for the MPSR resource in the file. */   /*=========================================*/     if (HonorEditWindowState)     {      fileReference = FSpOpenResFile(theFSSpec,fsRdWrPerm);      resourceError = ResError();     }   else     { fileReference = -1; }      if ((fileReference != -1) && (resourceError == noErr))     {      UseResFile(fileReference);            tempHandle = Get1Resource(editResType,editResID);      resourceError = ResError();      if ((tempHandle != NULL) && (resourceError == noErr))         {         theMPSR = (EditRSRCHdl) tempHandle;         resourceError = HandToHand((Handle *) &theMPSR);         if (resourceError != noErr)           { theMPSR = NULL; }         DisposeHandle(tempHandle);        }              CloseResFile(fileReference);     }      /*=============================*/   /* Open a window for the file. */   /*=============================*/   whichWindow = DoNew(theFSSpec->name,theMPSR);      /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   /*============================*/   /* Save the file information  */   /* in the window data record. */   /*============================*/   BlockMove(theFSSpec,&(*theData)->theFile,sizeof(FSSpec));   (*theData)->fileType = fileType;   (*theData)->referenceNumber = theFile;   /*=========================================*/   /* The file name becomes the window title. */   /*=========================================*/   SetWTitle(whichWindow,theFSSpec->name);   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*================================*/   /* Read the file into the window. */   /*================================*/   DoRevert(whichWindow,false);      /*============================*/   /* Restore the selected text. */   /*============================*/      if (theMPSR != NULL)     { TESetSelect((*theMPSR)->selrsrc.start,(*theMPSR)->selrsrc.end,(*theData)->editRec); }      /*==============================*/   /* Restore the scroll position. */   /*==============================*/      if (theMPSR != NULL)     {      scrollPosition = 0;      while ((**theText).lineStarts[scrollPosition] < (*theMPSR)->selrsrc.pos)        { scrollPosition++; }            theVScrollBar = (**theData).windowInfo.vScrollBar;      SetCtlValue(theVScrollBar,scrollPosition);              DisposeHandle((Handle) theMPSR);     }            EditAdjustText(whichWindow);        /*==============================================*/   /* Return a pointer to the window just created. */   /*==============================================*/      return(whichWindow);  }/*********************************************//* CloseTextWindow: Close an editing window. *//*********************************************/void CloseTextWindow(  WindowPtr whichWindow)  {   EWDHandle theData;   Handle dataHandle;   Str255 theTitle;   int theItem;   OSErr resultCode;   int posValue;   /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*==================================================*/   /* If the window contents have been changed then... */   /*==================================================*/   if ((**theData).dirty)     {      /*======================================================*/      /* Get the window title and place it in the alert text. */      /*======================================================*/      GetWTitle(whichWindow,theTitle);      ParamText(theTitle,"\p","\p","\p");      /*===================================================*/      /* Post caution alert about closing a modified file. */      /*===================================================*/      InitCursor();      theItem = CautionAlert(SaveID,(ModalPtr) DefaultDialogFilterRef);      switch (theItem)        {         case saveItem:           DoSave(whichWindow);           if (ErrorFlag)             {              HUnlock(dataHandle);              return;             }           break;         case discardItem:           break;         case cancelItem:           Quitting = false;           HUnlock(dataHandle);           return;           break;        }     }     /*==================================*/   /* Remove the window from the menu. */   /*==================================*/   RemoveWindowFromMenu(whichWindow);   /*=================================================*/   /* If the window is associated with a file then... */   /*=================================================*/   if ((*theData)->associatedWithFile)     {      /*======================================*/      /* Remember the position of the window. */      /*======================================*/      RememberEditWindowPosition(whichWindow,&(*theData)->theFile);         /*========================================*/      /* Close the file and check for an error. */      /*========================================*/      resultCode = FSClose((*theData)->referenceNumber);      /* IOCheck(resultCode); */      /*========================================================*/      /* If an error occurs, unlock the data record and return. */      /*========================================================*/            if (resultCode != noErr)        {         if (! OKCancelAlertDialog("\pUnable to save file because of an I/O error. Close the window anyway?"))           {            Quitting = false;            ErrorFlag = TRUE;            HUnlock(dataHandle);            return;           }         (*theData)->referenceNumber = 0;        }     }   /*======================================*/   /* Dispose of the window's edit record. */   /*======================================*/   TEDispose((*theData)->editRec);   /*================================================================*/   /* Update the count of stacked window's at the window's location. */   /*================================================================*/   posValue = (*theData)->placementPos;   if (posValue >= 0)     { WindowCount[posValue] -= 1; }   /*========================*/   /* Disable Drag and Drop. */   /*========================*/   RemoveEditWindowDragAndDrop(whichWindow);    /*==================================*/   /* Deallocate any undo information. */   /*==================================*/      DeallocateUndoEditInfo(&(*theData)->undoInfo);     /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*======================================*/   /* Dispose of the window's data record. */   /*======================================*/   DisposHandle(dataHandle);   /*========================*/   /* Dispose of the window. */   /*========================*/   DisposeWindow(whichWindow);  }/********************************//* DoSave: Handle Save command. *//********************************/static void DoSave(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   /*=======================================*/   /* Get window data. Lock the data record */   /* and convert to a typed handle.        */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*===============================================================*/   /* If the window isn't associated with a file, then get the file */   /* name from the user. Otherwise write to the window's file.     */   /*===============================================================*/   if ((*theData)->associatedWithFile == 0)     { DoSaveAs(whichWindow); }   else     {      WriteFile((*theData)->referenceNumber,                &(*theData)->theFile,                (**theData).fileType,                whichWindow,                (**theData).editRec);     }   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/****************************************//* DoSaveAs: Handle Save As... command. *//****************************************/static void DoSaveAs(whichWindow)  WindowPtr whichWindow;  {   Point dlgOrigin;   StandardFileReply theReply;   short theFile;   EWDHandle theData;   Handle dataHandle;   Str255 theTitle;   OSErr resultCode;   /*===========================================*/   /* Get the window data. Lock the data record */   /* and convert to a typed handle.            */   /*===========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   if ((**theData).fileType == 'BTCH') BatchFile = 1;   else BatchFile = 0;   /*=======================*/   /* Set up dialog origin. */   /*=======================*/   SetPt(&dlgOrigin,DlgLeft,DlgTop);   /*==================================*/   /* Get the file name from the user. */   /*==================================*/   GetWTitle(whichWindow,theTitle);   CustomPutFile("\pSave Current Document As:",theTitle,&theReply,                 SaveAsDialogID,dlgOrigin,                 (DlgHookYDUPP) SaveAsDialogHookRef,                 NULL,NULL,NULL,NULL);   /*========================================================*/   /* If the user failed to confirm the file selection, then */   /* cancel the quit command (if any), force an exit to the */   /* main event loop, and return.                           */   /*========================================================*/   if (! theReply.sfGood)     {      Quitting = false;      ErrorFlag = TRUE;      HUnlock(dataHandle);      return;     }   /*===============================*/   /* Create the file if necessary. */   /*===============================*/   resultCode = FSpCreate(&theReply.sfFile,CREATOR_CODE,'TEXT',theReply.sfScript);   switch(resultCode)     {      case noErr:      case dupFNErr:        break;      default:        IOCheck(resultCode);        HUnlock(dataHandle);        return;        break;     }   /*===================================*/   /* Indicate delay with watch cursor. */   /*===================================*/   SetCursor(*WatchCursor);   /*======================================================*/   /* If the window already has a file associated with it, */   /* then close the old file. Return if an error occurs.  */   /*======================================================*/   if ((*theData)->associatedWithFile)     {      resultCode = FSClose((*theData)->referenceNumber);      IOCheck(resultCode);      if (ErrorFlag)        {         HUnlock(dataHandle);         return;        }     }        /*=============================================*/   /* Open the new file and check for any errors. */   /*=============================================*/   resultCode = FSpOpenDF(&theReply.sfFile,fsCurPerm,&theFile);   IOCheck(resultCode);   if (ErrorFlag)     { (*theData)->associatedWithFile = false; }   else     {      SetWTitle(whichWindow,theReply.sfFile.name);      UpdateWindowInMenu(whichWindow);      BlockMove(&theReply.sfFile,&(*theData)->theFile,sizeof(FSSpec));      (*theData)->referenceNumber = theFile;      if (BatchFile)        {         WriteFile((*theData)->referenceNumber,                   &(*theData)->theFile,'BTCH',                   whichWindow,(**theData).editRec);         (*theData)->fileType = 'BTCH';        }      else        {         WriteFile((*theData)->referenceNumber,                   &(*theData)->theFile,'TEXT',                   whichWindow,(**theData).editRec);         (*theData)->fileType = 'TEXT';        }     }   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   (*theData)->associatedWithFile = TRUE;      /*=============================================*/   /* Reset the current volume so that UNIX fopen */   /* function will find the folder (if a load    */   /* or batch command is give later).            */   /*=============================================*/      SetDirectory(&theReply.sfFile);  }/***********************************************//* WriteFile: Write window contents to a file. *//***********************************************/static void WriteFile(  short referenceNumber,  FSSpec *theFile,  long fileType,  WindowPtr whichWindow,  TEHandle myText)  {   Handle textHandle;   long int textLength;   OSErr resultCode;   Str255 fName;   FInfo finderInfo;     /*==================================*/   /* Change cursor to indicate delay. */   /*==================================*/   SetCursor(*WatchCursor);   /*=========================*/   /* Set the file's creator. */   /*=========================*/   GetWTitle(whichWindow,fName);   resultCode = FSpGetFInfo(theFile,&finderInfo);      IOCheck(resultCode);   if (ErrorFlag) return;   finderInfo.fdCreator = CREATOR_CODE;   finderInfo.fdType = fileType;      resultCode = FSpSetFInfo(theFile,&finderInfo);   IOCheck(resultCode);   if (ErrorFlag) return;   /*======================================================*/   /* Get text handle and current length from edit record. */   /*======================================================*/   HLock( (Handle) myText);   textHandle = (**myText).hText;   textLength = (**myText).teLength;   HUnlock( (Handle) myText);   /*=====================================================*/   /* Set current file mark to the beginning of the file. */   /*=====================================================*/   resultCode = SetFPos(referenceNumber,fsFromStart,0L);   IOCheck(resultCode);   if (ErrorFlag) return;   /*======================================*/   /* Write the window's text to the file. */   /*======================================*/   HLock(textHandle);   resultCode = FSWrite(referenceNumber,&textLength,*textHandle);   HUnlock(textHandle);   IOCheck(resultCode);   if (ErrorFlag) return;   /*=========================================*/   /* Set length of file and check for error. */   /*=========================================*/   resultCode = SetEOF(referenceNumber,textLength);   IOCheck(resultCode);   if (ErrorFlag) return;      /*===============================*/   /* Rember the window's position. */   /*===============================*/      RememberEditWindowPosition(whichWindow,theFile);   /*=============================*/   /* Mark window as being clean. */   /*=============================*/   WindowDirty(whichWindow,false);  }/*********************************************//* DoRevert: Handle Revert to Saved command. *//*********************************************/static void DoRevert(  WindowPtr whichWindow,  short clearWindow)  {   EWDHandle theData;   Handle dataHandle;   Str255 fileName;   long int textLength;   int theItem;   OSErr resultCode;   TEHandle myText;   /*=================================================================*/   /* Get the window data, lock it, and convert it to a typed handle. */   /*=================================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=================================================================*/   /* If the window contents have been changed, then determine if the */   /* user wants to discard the contents or cancel the command.       */   /*=================================================================*/   if ((**theData).dirty)     {      GetWTitle(whichWindow,fileName);      ParamText(fileName,"\p","\p","\p");      theItem = CautionAlert(RevertID,(ModalPtr) DefaultDialogFilterRef);      if (theItem == cancelItem)        {         HUnlock(dataHandle);         ErrorFlag = TRUE;         return;        }     }   /*========================================*/   /* Change the cursor to indicate a delay. */   /*========================================*/   SetCursor(*WatchCursor);   /*=================================================*/   /* Get the length of the file and check for error. */   /*=================================================*/   resultCode = GetEOF((*theData)->referenceNumber,&textLength);   IOCheck(resultCode);   if (ErrorFlag)     {      HUnlock(dataHandle);      return;     }   /*=====================================================*/   /* Set current file mark to the beginning of the file. */   /*=====================================================*/   resultCode = SetFPos((*theData)->referenceNumber,fsFromStart,0L);   IOCheck(resultCode);   if (ErrorFlag)     {      HUnlock(dataHandle);      return;     }   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*============================================================*/   /* Adjust text to the length of the file and set text length. */   /*============================================================*/   SetHandleSize((**myText).hText,textLength);   (**myText).teLength = textLength;   /*==================*/   /* Lock the handle. */   /*==================*/   HLock((**myText).hText);   /*============================================*/   /* Read the text of the file into the handle. */   /*============================================*/   resultCode = FSRead((*theData)->referenceNumber,&textLength,*(**myText).hText);   IOCheck(resultCode);   /*========================================*/   /* Unlock the handle and the edit record. */   /*========================================*/   HUnlock((**myText).hText);   HUnlock( (Handle) myText);   /*===================*/   /* Check for errors. */   /*===================*/   if (ErrorFlag)     {      HUnlock(dataHandle);      return;     }   (*theData)->associatedWithFile = TRUE;      /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*==================================================================*/   /* Wrap text to the window and adjust scroll bar to length of text. */   /*==================================================================*/   TECalText(myText);   AdjustScrollBar(whichWindow);   /*=================================================*/   /* Make sure text margins are set properly so that */   /* text does not "jump" upon initial text entry.   */   /*=================================================*/   FixText(whichWindow);   /*===========================================*/   /* Set insertion point at beginning of text. */   /*===========================================*/   TESetSelect(0,0,myText);   /*===================================================*/   /* Force an update to redraw the text in the window. */   /*===================================================*/   if (clearWindow)     { InvalRect(&(*whichWindow).portRect); }   /*===========================*/   /* Mark the window as clean. */   /*===========================*/   WindowDirty(whichWindow,false);  }/********************************//* DoQuit: Handle Quit command. *//********************************/void DoQuit()  {   SendBehind(DisplayWindow,NULL);   Quitting = TRUE;  }/*********************************//* IOCheck: Check for I/O error. *//*********************************/static void IOCheck(OSErr resultCode)  {   int alertID;   Str255 errorString;   /*==============================*/   /* Return if there is no error. */   /*==============================*/   if (resultCode == noErr) return;   /*===============*/   /* Handle error. */   /*===============*/   switch(resultCode)     {      /*=========================*/      /* Use already open alert. */      /*=========================*/      case opWrErr:        alertID = OpWrID;        break;      /*========================================================*/      /* Use general I/O error alert. Convert the error code to */      /* a string and substitute it into the text of the alert. */      /*========================================================*/      default:        alertID = IOErrID;        NumToString(resultCode,errorString);        ParamText(errorString,"\p","\p","\p");        break;     }   /*===============================================*/   /* Restore the normal cursor and post the alert. */   /*===============================================*/   InitCursor();   StopAlert(alertID,(ModalPtr) DefaultDialogFilterRef);   /*=================================================================*/   /* Cancel Quit command, if any, and force exit to main event loop. */   /*=================================================================*/   Quitting = false;   ErrorFlag = TRUE;  }/***********************************************************//* SaveAsDialogHook: Handles special processing needed for *//*    the Batch check box item in the Save As dialog box.  *//***********************************************************/static pascal short int SaveAsDialogHook(  short int MySFItem,  DialogPtr theDialog,  Ptr userData)  {#if MAC_MPW || MAC_MCW#pragma unused(userData)#endif   static DialogPtr CurrentDialog = NULL;      /*==============================================*/   /* If we've already entered the Save As dialog, */   /* don't allow reentry into this routine for    */   /* a different dialog. This prevents this       */   /* routine from being entered for the "OK to    */   /* Replace" file dialog if we're overwriting a  */   /* file.                                        */   /*==============================================*/      if ((CurrentDialog != NULL) &&       (theDialog != CurrentDialog))     { return(MySFItem); }      /*======================================*/   /* Do special processing for items that */   /* we've added to the dialog box.       */   /*======================================*/      switch (MySFItem)     {       case sfHookFirstCall:        SetCheckBox(theDialog,BatchFileCheckBoxID,BatchFile);        CurrentDialog = theDialog;        return(sfHookNullEvent);        break;      case BatchFileCheckBoxID:        BatchFile = 1 - BatchFile;        ToggleCheckBox(theDialog,BatchFileCheckBoxID);        return(sfHookNullEvent);        break;              case sfHookLastCall:        CurrentDialog = NULL;        return(sfHookNullEvent);        break;     }   /*=========================================*/   /* The item wasn't of interest to us so    */   /* allow it to be processed by the system. */   /*=========================================*/      return(MySFItem);  }  /***************************************************//* SetDirectory: Resets the current volume so that *//*    UNIX fopen function will find the folder (if *//*    a load or batch command is give later).      *//***************************************************/void SetDirectory(theSpec)  FSSpec *theSpec;  {   static short wdRefNum = 0;      if (wdRefNum) CloseWD(wdRefNum);   OpenWD(theSpec->vRefNum,theSpec->parID,CREATOR_CODE,&wdRefNum);   SetVol(NULL,wdRefNum);  }/***********************************************************//* RememberEditWindowPosition: Updates the MPSR resource   *//*   of a file so that the file window's current position, *//*   size, selection, etc. can be restored when the file   *//*   is later opened.                                      *//***********************************************************/void RememberEditWindowPosition(  WindowPtr whichWindow,  FSSpec *theFSSpec)  {   short fileReference;   OSErr resourceError;   EditRSRCHdl theMPSR = NULL;   Handle tempHandle;   unsigned long date;   short theFont, theSize;   Str255 theFontName;   Point topLeft, bottomRight;   EWDHandle theData;   Handle dataHandle;   TEHandle theText;   ControlHandle theVScrollBar;   int scrollValue, i;      /*=============================================*/   /* Does the user want edit window state saved? */   /*=============================================*/      if (! RememberEditWindowState) return;      /*===============*/   /* Get the date. */   /*===============*/      GetDateTime(&date);      /*============================================*/   /* Try opening the resource fork of the file. */   /*============================================*/     fileReference = FSpOpenResFile(theFSSpec,fsRdWrPerm);   resourceError = ResError();      /*==========================================*/   /* If the resource fork couldn't be opened, */   /* try to correct the problem.              */   /*==========================================*/      if ((fileReference == -1) || (resourceError != noErr))     {       /*====================================*/      /* If no resource fork exists, try    */      /* creating it and then reopening it. */      /*====================================*/            if ((resourceError == mapReadErr) ||           (resourceError == eofErr))        {         FSpCreateResFile(theFSSpec,CREATOR_CODE,'TEXT',smSystemScript);         resourceError = ResError();         if (resourceError != noErr) return;			         fileReference = FSpOpenResFile(theFSSpec,fsRdWrPerm);         resourceError = ResError();         if ((fileReference == -1) || (resourceError != noErr))           { return; }        }               /*==================*/      /* Otherwise, punt. */      /*==================*/            else         { return; }     }        /*======================================================*/   /* Otherwise, there was no problem opening the resource */   /* fork. This means it could already contain an MPSR    */   /* resource. Check to see if one exists, and if so,     */   /* remove it (but remember the date stored in the old   */   /* resource).                                           */   /*======================================================*/        else     {      UseResFile(fileReference);            tempHandle = Get1Resource(editResType,editResID);      theMPSR = (EditRSRCHdl) tempHandle;      resourceError = ResError();               if ((theMPSR != NULL) && (resourceError == noErr))         {         date = (*theMPSR)->selrsrc.date;         RmveResource(tempHandle);         UpdateResFile(fileReference);        }     }   /*==========================================*/   /* Make sure we are using the correct file. */   /*==========================================*/      UseResFile(fileReference);      /*==========================*/   /* Create an MPSR resource. */   /*==========================*/      theMPSR = (EditRSRCHdl) NewHandle(sizeof(EditRSRC));      /*=====================================*/   /* Save the correct modification time. */   /*=====================================*/   (*theMPSR)->selrsrc.date = date;      /*=============================*/   /* Save the current selection. */   /*=============================*/      dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   (*theMPSR)->selrsrc.start = (**theText).selStart;   (*theMPSR)->selrsrc.end = (**theText).selEnd;         /*===========================*/   /* Save the scroll position. */   /*===========================*/      theVScrollBar = (**theData).windowInfo.vScrollBar;   scrollValue = GetCtlValue(theVScrollBar);   if (scrollValue > (**theText).nLines)     { (*theMPSR)->selrsrc.pos = 0; }   else     {  (*theMPSR)->selrsrc.pos = (**theText).lineStarts[scrollValue]; }      /*===========================*/   /* Save the font attributes. */   /*===========================*/      for (i = 0; i <= 31; i++)     { (*theMPSR)->fontrsrc.name[i] = 0; }        GetFontAttributes(&theFont,&theSize,whichWindow);   (*theMPSR)->fontrsrc.size = theSize;      GetFontName(theFont,theFontName);   if (theFontName[0] > 31)     { theFontName[0] = 31; }      PTOCSTR(theFontName);      strcpy((*theMPSR)->fontrsrc.name,(char *) theFontName);      /* BlockMove(theFontName,(*theMPSR)->fontrsrc.name,theFontName[0] + 1); */      /*=============================*/   /* Save off unused attributes. */   /*=============================*/      (*theMPSR)->tabrsrc.width = CharWidth(' ');   (*theMPSR)->tabrsrc.count = 1;   (*theMPSR)->autoindent = true;   (*theMPSR)->invisibles = false;	   /*===========================*/   /* Save the window position. */   /*===========================*/         topLeft.h = (*whichWindow).portRect.left;   topLeft.v = (*whichWindow).portRect.top;      bottomRight.h = (*whichWindow).portRect.right;   bottomRight.v = (*whichWindow).portRect.bottom;      LocalToGlobal(&topLeft);   LocalToGlobal(&bottomRight);      (*theMPSR)->windrsrc.openrect.right = bottomRight.h;   (*theMPSR)->windrsrc.openrect.left = topLeft.h;   (*theMPSR)->windrsrc.openrect.bottom = bottomRight.v;   (*theMPSR)->windrsrc.openrect.top = topLeft.v;       (*theMPSR)->windrsrc.closerect.right = bottomRight.h;   (*theMPSR)->windrsrc.closerect.left = topLeft.h;   (*theMPSR)->windrsrc.closerect.bottom = bottomRight.v;   (*theMPSR)->windrsrc.closerect.top = topLeft.v;           /*====================================*/   /* Add the MPSR resource to the file. */   /*====================================*/      AddResource((Handle) theMPSR,editResType,editResID,"\pMPSR Resource");      resourceError = ResError();   if (resourceError != noErr)     {      DisposeHandle((Handle) theMPSR);      CloseResFile(fileReference);      return;     }   /*===========================*/   /* Update the resource file. */   /*===========================*/   	   UpdateResFile(fileReference);	   /*===============================*/   /* Deallocate the MPSR resource. */   /*===============================*/      DetachResource((Handle) theMPSR);   DisposeHandle((Handle) theMPSR);      /*==========================*/   /* Close the resource file. */   /*==========================*/        CloseResFile(fileReference);  }  