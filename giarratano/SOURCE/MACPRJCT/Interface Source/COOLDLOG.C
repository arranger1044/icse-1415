   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*             Macintosh Version 3.3  04/02/96         */   /*                                                     */   /*              COOL DIALOG MANAGER MODULE             */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _COOLDLOG_SOURCE_#include "setup.h"#if OBJECT_SYSTEM#include <string.h>#include <stdlib.h>#include <Dialogs.h>#if MAC_MPW || MAC_MCW#include <strings.h>#else#include <pascal.h>#endif#if MAC_SC7 || MAC_SC8#define CTOPSTR C2PStr#else#define CTOPSTR c2pstr#endif#if MAC_SC7 || MAC_MCW || MAC_SC8#define ClickPtr ListClickLoopUPP#else#define ClickPtr ProcPtr#endif#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#include "router.h"#include "commline.h"#include "classcom.h"#include "classexm.h"#include "classinf.h"#include "msgcom.h"#include "defins.h"#include "dlogmngr.h"#include "window.h"#include "statusw.h"#include "kbstatw.h"#include "stnrdmac.h"#include "cooldlog.h"/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   UpdateDefclassButtons(DialogPtr,int);   static void                   UpdateDefinstancesButtons(DialogPtr,int);   static void                   UpdateHandlerButtons(DialogPtr,int);   static void                   DoDefmessageHandlerManager(void);   static int                    GetIndexedHandler(int);   static char                  *GetMHName(VOID *);   static char                  *GetMHPPForm(void *);   static void                  *FindMH(char *);   static int                    DeleteMH(void *);   static VOID                  *GetNextMH(VOID *);   static int                    VerifyCells(int *,void *(*)(char *),int *,StringPtr);/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static void                  *ClassPtr;/**********************************************************//* DoDefclassManager: Handle Defclass Manager... command. *//**********************************************************/void DoDefclassManager()  {   short int itemNumber = 0;   int selection;   short int itemType;   Handle itemHandle;   Rect dispRect;   int numberOfDefclasses;   void *theClass;   /*====================*/   /* Create the dialog. */   /*====================*/   CreateDialogManager(DEFCLASS_DIALOG_RESOURCE_NUMBER,TRUE);   numberOfDefclasses = PrepManager(DEFCLASS_DIALOG_SELECT,                                      GetNextDefclass,                                      (char *(*)(VOID *)) GetConstructNameString,TRUE,false,(StringPtr) "\p");   /*================================================================*/   /* Define a ClikLoop function to be called repeatedly as long as  */   /* the mouse button is held down inside the class list. This loop */   /* will update the message-handler... button for the currently    */   /* selected class.                                                */   /*================================================================*/   UpdateConstructManagerButtonsFunction = UpdateDefclassButtons;   (*Choices)->lClickLoop = (ClickPtr) DefaultConstructManagerClikloopRef;   /*===========================================================*/   /* Set a global variable indicating which item in the dialog */   /* box is the list. This global value will be used by the    */   /* filter function for the dialog box.                       */   /*===========================================================*/   SelectItem = DEFCLASS_DIALOG_SELECT;   /*====================================================*/   /* Initialize the last dialog item selected variable. */   /*====================================================*/   itemNumber = DEFCLASS_DIALOG_SELECT;   selection = PutSelectionNameInBuffer();   /*====================================================================*/   /* Outline the Done button to indicate that it is the default button. */   /*====================================================================*/   OutlineButton(ManagerDialog,DEFCLASS_DIALOG_DONE,TRUE);   /*==================================================================*/   /* Update the message-handlers... button for the current selection. */   /*==================================================================*/   UpdateDefclassButtons(ManagerDialog,selection);   /*==================================================================*/   /* Remain in this loop until the user has selected the done button. */   /* The function SingleSelectFilter that is passed as an argument to */   /* ModalDialog is used to handle mouse-clicks in the list.          */   /*==================================================================*/   while (itemNumber != DEFCLASS_DIALOG_DONE)     {      ModalDialog((ModalPtr) SingleSelectFilterRef,&itemNumber);      switch(itemNumber)        {         case DEFCLASS_DIALOG_SELECT:           selection = PutSelectionNameInBuffer();           break;         case DEFCLASS_DIALOG_PRINT:           GenericPrintButton(FindDefclass,(char *(*)(VOID *)) GetConstructPPForm,"(ppdefclass ",NULL);           break;         case DEFCLASS_DIALOG_REMOVE:           Undefclass(FindDefclass(DialogBuffer));           numberOfDefclasses = VerifyCells(&numberOfDefclasses,FindDefclass,                                            &selection,(StringPtr) "\p");           selection = PutSelectionNameInBuffer();           break;         case DEFCLASS_DIALOG_BROWSE:           theClass = FindDefclass(DialogBuffer);           if (theClass != NULL)             {#if ! RUN_TIME              FlushCommandString();              PrintCLIPS("stdout","(browse-classes ");              PrintCLIPS("stdout",DialogBuffer);              PrintCLIPS("stdout",")\n");              BrowseClasses(WDISPLAY,theClass);              PrintPrompt();#endif             }           break;         case DEFCLASS_DIALOG_DESCRIBE:           theClass = FindDefclass(DialogBuffer);           if (theClass != NULL)             {#if ! RUN_TIME              FlushCommandString();              PrintCLIPS("stdout","(describe-class ");              PrintCLIPS("stdout",DialogBuffer);              PrintCLIPS("stdout",")\n");              DescribeClass(WDISPLAY,theClass);              PrintPrompt();#endif             }           break;         case DEFCLASS_DIALOG_MESSAGE_HANDLERS:           ClassPtr = FindDefclass(DialogBuffer);           DoDefmessageHandlerManager();           GetDItem(ManagerDialog,DEFCLASS_DIALOG_SELECT,&itemType,&itemHandle,&dispRect);           dispRect.right -= (SCROLL_BAR_WIDTH - 1);           FrameRect(&dispRect);           LUpdate(ManagerDialog->visRgn,Choices);           OutlineButton(ManagerDialog,DEFCLASS_DIALOG_DONE,TRUE);           selection = PutSelectionNameInBuffer();           break;                    case DEFCLASS_DIALOG_WATCH_INSTANCES:           theClass = FindDefclass(DialogBuffer);           if (theClass != NULL)             SetDefclassWatchInstances(                 GetDefclassWatchInstances(theClass) ? OFF : ON,theClass);           break;                    case DEFCLASS_DIALOG_WATCH_SLOTS:           theClass = FindDefclass(DialogBuffer);           if (theClass != NULL)             SetDefclassWatchSlots(GetDefclassWatchSlots(theClass) ? OFF : ON,                                   theClass);           break;        }      UpdateDefclassButtons(ManagerDialog,selection);     }   CleanUpAfterManagerDialog(TRUE);  }/**********************************************//* UpdateDefclassButtons: Updates the buttons *//*   in the Class Manager dialog box.         *//**********************************************/static void UpdateDefclassButtons(dptr,selection)  DialogPtr dptr;  int selection;  {#if MAC_MPW || MAC_MCW#pragma unused(selection)#endif   Handle itemHandle;   Rect dispRect;   short int itemType;   void *theDefclass;   PutSelectionNameInBuffer();   theDefclass = FindDefclass(DialogBuffer);   /*=========================================================*/   /* Get information about the remove... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_REMOVE,&itemType,&itemHandle,&dispRect);   if ((theDefclass == NULL) ? false : IsDefclassDeletable(theDefclass))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*=========================================================*/   /* Get information about the print... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_PRINT,&itemType,&itemHandle,&dispRect);   if ((theDefclass == NULL) ? false : (GetDefclassPPForm(theDefclass) != NULL))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*=========================================================*/   /* Get information about the browse... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_BROWSE,&itemType,&itemHandle,&dispRect);   if (theDefclass != NULL)     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*===========================================================*/   /* Get information about the describe... button dialog item. */   /*===========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_DESCRIBE,&itemType,&itemHandle,&dispRect);   if (theDefclass != NULL)     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*===========================================================*/   /* Get information about the handlers... button dialog item. */   /*===========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_MESSAGE_HANDLERS,&itemType,&itemHandle,&dispRect);   if ((theDefclass == NULL) ? false : (GetNextDefmessageHandler(theDefclass,0) != 0))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }        /*===========================================================*/   /* Get information about the trace... button dialog items. */   /*===========================================================*/   GetDItem(dptr,DEFCLASS_DIALOG_WATCH_INSTANCES,&itemType,&itemHandle,&dispRect);   if ((theDefclass == NULL) ? false :        (ClassAbstractP(theDefclass) == FALSE))     {      SetCheckBox(dptr,DEFCLASS_DIALOG_WATCH_INSTANCES,                  GetDefclassWatchInstances(theDefclass));      HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE);     }   else     {      SetCheckBox(dptr,DEFCLASS_DIALOG_WATCH_INSTANCES,OFF);      HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE);     }        GetDItem(dptr,DEFCLASS_DIALOG_WATCH_SLOTS,&itemType,&itemHandle,&dispRect);   if ((theDefclass == NULL) ? false :        (ClassAbstractP(theDefclass) == FALSE))     {      SetCheckBox(dptr,DEFCLASS_DIALOG_WATCH_SLOTS,                  GetDefclassWatchSlots(theDefclass));      HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE);     }   else     {      SetCheckBox(dptr,DEFCLASS_DIALOG_WATCH_SLOTS,OFF);      HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE);     }  }/*****************************************************************//* DoDefmessageHandlerManager: Handle Message Handlers... button *//*   from Defclass Manager dialog.                               *//*****************************************************************/static void DoDefmessageHandlerManager()  {   char nameBuffer[40];   short int itemNumber = 0;   int selection;   int numberOfHandlers;   ListHandle tempChoices;   int tempSelectItem;   DialogPtr tempManagerDialog;   GrafPtr tempDialogManagerSavePort;   void (*tempButtonHandler)(struct GrafPort *,int);   unsigned theHandler;      /*=================================================*/   /* Save the old dialog values since we are placing */   /* a dialog window over a dialog window.           */   /*=================================================*/   tempChoices = Choices;   tempSelectItem = SelectItem;   tempManagerDialog = ManagerDialog;   tempDialogManagerSavePort = DialogManagerSavePort;   tempButtonHandler = UpdateConstructManagerButtonsFunction;   /*================================================*/   /* Use the name of the class in the dialog title. */   /*================================================*/   if (strlen(GetDefclassName(ClassPtr)) > 35)     {      strncpy(nameBuffer,GetDefclassName(ClassPtr),35);      strcpy(&nameBuffer[35],"...");     }   else     { strcpy(nameBuffer,GetDefclassName(ClassPtr)); }   CTOPSTR(nameBuffer);   /*====================*/   /* Create the dialog. */   /*====================*/   DV = 30;   CreateDialogManager(DEFMH_DIALOG_RESOURCE_NUMBER,false);   numberOfHandlers = PrepManager(DEFMH_DIALOG_SELECT,                                      GetNextMH,                                      GetMHName,TRUE,TRUE,(StringPtr) nameBuffer);   DV = 0;   /*================================================================*/   /* Define a ClikLoop function to be called repeatedly as long as  */   /* the mouse button is held down inside the message handler list. */   /* This loop will update the remove... button for the currently   */   /* selected message-handler.                                      */   /*================================================================*/   UpdateConstructManagerButtonsFunction = UpdateHandlerButtons;   (*Choices)->lClickLoop = (ClickPtr) DefaultConstructManagerClikloopRef;   /*===========================================================*/   /* Set a global variable indicating which item in the dialog */   /* box is the list. This global value will be used by the    */   /* filter function for the dialog box.                       */   /*===========================================================*/   SelectItem = DEFMH_DIALOG_SELECT;   /*====================================================*/   /* Initialize the last dialog item selected variable. */   /*====================================================*/   itemNumber = DEFMH_DIALOG_SELECT;   selection = PutSelectionNameInBuffer();   /*====================================================================*/   /* Outline the Done button to indicate that it is the default button. */   /*====================================================================*/   OutlineButton(ManagerDialog,DEFMH_DIALOG_DONE,TRUE);   /*========================================================*/   /* Update the remove... button for the current selection. */   /*========================================================*/   UpdateHandlerButtons(ManagerDialog,selection);   /*==================================================================*/   /* Remain in this loop until the user has selected the done button. */   /* The function SingleSelectFilter that is passed as an argument to */   /* ModalDialog is used to handle mouse-clicks in the list.          */   /*==================================================================*/   while (itemNumber != DEFMH_DIALOG_DONE)     {      ModalDialog((ModalPtr) SingleSelectFilterRef,&itemNumber);      switch(itemNumber)        {         case DEFMH_DIALOG_SELECT:           selection = PutSelectionNameInBuffer();           break;         case DEFMH_DIALOG_PRINT:           GenericPrintButton(FindMH,GetMHPPForm,"(ppdefmessage-handler ",GetDefclassName(ClassPtr));           break;         case DEFMH_DIALOG_REMOVE:           GenericDeleteButton1(FindMH,DeleteMH,&selection,&numberOfHandlers,                                (StringPtr) nameBuffer);           break;                    case DEFMH_DIALOG_WATCH:           theHandler = (unsigned) FindMH(DialogBuffer);           if (theHandler != 0)             SetDefmessageHandlerWatch(                 GetDefmessageHandlerWatch(ClassPtr,theHandler) ? OFF : ON,                 ClassPtr,theHandler);           break;        }      UpdateHandlerButtons(ManagerDialog,selection);     }   CleanUpAfterManagerDialog(false);   /*================================*/   /* Restore the old dialog values. */   /*================================*/   Choices = tempChoices;   SelectItem = tempSelectItem;   ManagerDialog = tempManagerDialog;   DialogManagerSavePort = tempDialogManagerSavePort;   UpdateConstructManagerButtonsFunction = tempButtonHandler;  }/****************************************************//* UpdateHandlerButtons: Updates the buttons in the *//*    Defmessage-handler Manager dialog box.        *//****************************************************/static void UpdateHandlerButtons(dptr,selection)  DialogPtr dptr;  int selection;  {#if MAC_MPW || MAC_MCW#pragma unused(selection)#endif   Handle itemHandle;   Rect dispRect;   short int itemType;   void *theHandler;   PutSelectionNameInBuffer();   theHandler = FindMH(DialogBuffer);   /*=========================================================*/   /* Get information about the remove... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFMH_DIALOG_REMOVE,&itemType,&itemHandle,&dispRect);   if ((theHandler == NULL) ? false :        IsDefmessageHandlerDeletable(ClassPtr,(unsigned int) theHandler))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*=========================================================*/   /* Get information about the print... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFMH_DIALOG_PRINT,&itemType,&itemHandle,&dispRect);   if ((theHandler == NULL) ? false :       (GetDefmessageHandlerPPForm(ClassPtr,(unsigned int) theHandler) != NULL))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }        /*=========================================================*/   /* Get information about the trace... button dialog item.  */   /*=========================================================*/   GetDItem(dptr,DEFMH_DIALOG_WATCH,&itemType,&itemHandle,&dispRect);   if (theHandler != NULL)     {      SetCheckBox(dptr,DEFMH_DIALOG_WATCH,                  GetDefmessageHandlerWatch(ClassPtr,(unsigned) theHandler));      HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE);     }   else     {      SetCheckBox(dptr,DEFMH_DIALOG_WATCH,OFF);      HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE);     }   }/****************************************************//* FindMH:                                          *//****************************************************/static void *FindMH(name)   char *name;   {    unsigned int rv;    char *s1, *s2;    int i = 0;    s1 = malloc(strlen(name) + 1);    strcpy(s1,name);    while (s1[i] != ' ')      {       if (s1[i] == '\0') return(NULL);       i++;      }    s1[i] = '\0';    s2 = &s1[i+1];    rv = FindDefmessageHandler(ClassPtr,s1,s2);    free(s1);    return( (void *) rv);   }/****************************************************//* GetMHPPForm:                                     *//****************************************************/static char *GetMHPPForm(hack)   void *hack;   {    return(GetDefmessageHandlerPPForm(ClassPtr,(unsigned int) hack));   }/****************************************************//* DeleteMH:                                     *//****************************************************/static int DeleteMH(hack)   void *hack;   {    return(UndefmessageHandler(ClassPtr,(unsigned int) hack));   }/***************************************************//* GetMHName:                                      *//***************************************************/static char *GetMHName(mhPtr)  VOID *mhPtr;  {   int hack;   hack = (int) mhPtr;   sprintf(DialogBuffer,"%s %s",GetDefmessageHandlerName(ClassPtr,hack),                                GetDefmessageHandlerType(ClassPtr,hack));   return(DialogBuffer);  }/***************************************************//* GetNextMH:                                      *//***************************************************/static VOID *GetNextMH(mhPtr)  VOID *mhPtr;  {   int hack;   hack = (int) mhPtr;   hack = GetNextDefmessageHandler(ClassPtr,hack);   return((void *) hack);  }/*************************************************************//* VerifyCells:                          *//*************************************************************/static int VerifyCells(numberOfItems,findItemFunction,currentSelection,namePrefix)  int *numberOfItems;  void *(*findItemFunction)(char *);  int *currentSelection;  StringPtr namePrefix;  {   short int selection, maxLen;   Cell theCell;   char tempBuffer[30];   for (selection = *numberOfItems - 1; selection >= 0; selection--)     {      maxLen = DIALOG_BUFFER_SIZE - 1;      SetPt(&theCell,0,selection);      LGetCell(DialogBuffer,&maxLen,theCell,Choices);      DialogBuffer[maxLen] = '\0';      if ( (*findItemFunction)(DialogBuffer) == NULL)        {         LDelRow(1,selection,Choices);         (*numberOfItems)--;         if (selection < (*currentSelection)) (*currentSelection)--;         if ((*currentSelection) >= (*numberOfItems)) (*currentSelection)--;        }     }    SetPt(&theCell,0,*currentSelection);    LSetSelect((Boolean) TRUE,theCell,Choices);    sprintf(tempBuffer,"%d Item%s",*numberOfItems,(*numberOfItems == 1) ? "" : "s");    CTOPSTR(tempBuffer);    ParamText((StringPtr) tempBuffer,namePrefix,"\p","\p");    DrawDialog(ManagerDialog);    return (*numberOfItems);  }  #if DEFINSTANCES_CONSTRUCT/******************************************************************//* DoDefinstancesManager: Handle Definstances Manager... command. *//******************************************************************/void DoDefinstancesManager()  {   short int itemNumber = 0;   int selection;   int numberOfDefinstances;   /*============================*/   /* Create the dialog manager. */   /*============================*/   CreateDialogManager(DEFINSTANCES_DIALOG_RESOURCE_NUMBER,TRUE);   numberOfDefinstances = PrepManager(DEFINSTANCES_DIALOG_SELECT,                                      GetNextDefinstances,                                      (char *(*)(VOID *)) GetConstructNameString,TRUE,false,(StringPtr) "\p");   /*===============================================================*/   /* Define a ClikLoop function to be called repeatedly as long as */   /* the mouse button is held down inside the list of items. This  */   /* loop will update buttons applicable to the currently selected */   /* item.                                                         */   /*===============================================================*/   UpdateConstructManagerButtonsFunction = UpdateDefinstancesButtons;   (*Choices)->lClickLoop = (ClickPtr) DefaultConstructManagerClikloopRef;   /*===========================================================*/   /* Set a global variable indicating which item in the dialog */   /* box is the list. This global value will be used by the    */   /* filter function for the dialog box.                       */   /*===========================================================*/   SelectItem = DEFINSTANCES_DIALOG_SELECT;   /*====================================================*/   /* Initialize the last dialog item selected variable. */   /*====================================================*/   itemNumber = DEFINSTANCES_DIALOG_SELECT;   selection = PutSelectionNameInBuffer();   /*====================================================================*/   /* Outline the Done button to indicate that it is the default button. */   /*====================================================================*/   OutlineButton(ManagerDialog,DEFINSTANCES_DIALOG_DONE,TRUE);   /*========================================================*/   /* Update the method... button for the current selection. */   /*========================================================*/   UpdateDefinstancesButtons(ManagerDialog,selection);   /*==================================================================*/   /* Remain in this loop until the user has selected the done button. */   /* The function SingleSelectFilter that is passed as an argument to */   /* ModalDialog is used to handle mouse-clicks in the list.          */   /*==================================================================*/   while (itemNumber != DEFINSTANCES_DIALOG_DONE)     {      ModalDialog((ModalPtr) SingleSelectFilterRef,&itemNumber);      switch(itemNumber)        {         case DEFINSTANCES_DIALOG_SELECT:           selection = PutSelectionNameInBuffer();           break;         case DEFINSTANCES_DIALOG_PRINT:           GenericPrintButton(FindDefinstances,(char *(*)(VOID *)) GetConstructPPForm,"(ppdefinstances ",NULL);           break;         case DEFINSTANCES_DIALOG_REMOVE:           GenericDeleteButton1(FindDefinstances,Undefinstances,&selection,                                &numberOfDefinstances,(StringPtr) "\p");           break;        }      UpdateDefinstancesButtons(ManagerDialog,selection);     }   CleanUpAfterManagerDialog(TRUE);  }/**************************************************//* UpdateDefinstancesButtons: Updates the buttons *//* in the Definstances Manager dialog box.        *//**************************************************/static void UpdateDefinstancesButtons(dptr,selection)  DialogPtr dptr;  int selection;  {#if MAC_MPW || MAC_MCW#pragma unused(selection)#endif   Handle itemHandle;   Rect dispRect;   short int itemType;   void *theDefinstances;   PutSelectionNameInBuffer();   theDefinstances = FindDefinstances(DialogBuffer);   /*=========================================================*/   /* Get information about the remove... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFINSTANCES_DIALOG_REMOVE,&itemType,&itemHandle,&dispRect);   if ((theDefinstances == NULL) ? false : IsDefinstancesDeletable(theDefinstances))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }   /*=========================================================*/   /* Get information about the print... button dialog item. */   /*=========================================================*/   GetDItem(dptr,DEFINSTANCES_DIALOG_PRINT,&itemType,&itemHandle,&dispRect);   if ((theDefinstances == NULL) ? false : (GetDefinstancesPPForm(theDefinstances) != NULL))     { HiliteControl((ControlHandle) itemHandle,ACTIVE_VALUE); }   else     { HiliteControl((ControlHandle) itemHandle,INACTIVE_VALUE); }  }#endif#endif