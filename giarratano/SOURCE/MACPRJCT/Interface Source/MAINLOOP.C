   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                  MAIN LOOP MODULE                   */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _MAINLOOP_SOURCE_#include "setup.h"#include <Events.h>#include <Menus.h>#include <Devices.h>/* #include <Desk.h> */#include <Memory.h> #include <Dialogs.h>#include <SegLoad.h>#include <ToolUtils.h>#include <EPPC.h>#include <AppleEvents.h>/*#include <profiler.h>*/#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#define ARROW (qd.arrow)#if THINK_C /* Defined by the Think C Environment */#include <pascal.h>#else#include <strings.h>#endif#if MAC_SC7#define PTOCSTR P2CStr#define CTOPSTR C2PStr#else#define PTOCSTR p2cstr#define CTOPSTR c2pstr#endif#define PSTRCAST StringPtr#include <string.h>#include "filecom.h"#include "evaluatn.h"#include "engine.h"#include "commline.h"#include "globldef.h"#include "insfun.h"#include "factmngr.h"#include "agenda.h"#include "router.h"#include "apprsrcs.h"#include "kbstatw.h"#include "window.h"#include "stnrdmac.h"#include "statusw.h"#include "clpscrap.h"#include "menuhndl.h"#include "interface.h"#include "editmenu.h"#include "filemenu.h"#include "macinit.h"#include "search.h"#include "menucmds.h"#include "print.h"#include "mainloop.h"/***************//* Definitions *//***************/#define StopCantDoID 1009#define CONTROL_C      '\3'/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   FixCursor(void);   static void                   DoEvent(void);   static void                   DoMouseDown(EventRecord *);   static void                   DoMenuClick(EventRecord *);   static void                   DoMenuChoice(long int);   static void                   DoAppleChoice(int);   static void                   DoKeystroke(EventRecord *);   static void                   DoTyping(int,EventModifiers);   static void                   DoHighLevelEvent(EventRecord *);   static void                   DoAbout(void);/****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   int                     MemoryOK = TRUE;   int                     HandlingEvent = false;   int                     Quitting = false;   int                     Finished = false;   int                     ErrorFlag;   /**********************************************************//* MAINEVENT: Executes one pass of the main program loop. *//**********************************************************/int MainEvent()  {   Str255 p1;      /*=================================================*/   /* Adjust the cursor for the region of the screen. */   /*=================================================*/   FixCursor();   /*============================*/   /* Do system idle processing. */   /*============================*/   SystemTask();   /*============================*/   /* Update the status windows. */   /*============================*/   UpdateStatusWindows();   /*========================*/   /* Handle the next Event. */   /*========================*/   DoEvent();   /*========================================*/   /* Check to see if memory is running low. */   /*========================================*/   if ((FreeMem() + (GetApplLimit() - GetZone()->bkLim)) < (30L * 1024L))     {      if (MemoryOK == TRUE)        {         sprintf((char *) p1,"%s is running out of memory.\r",APPLICATION_NAME);         CTOPSTR((char *) p1);            ParamText(p1,"\pQuit as soon as possible.","\p","\p");         StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);         MemoryOK = false;        }     }   else    { MemoryOK = TRUE; }   return(1);  }/**************************************************//* FixCursor: Adjust cursor for region of screen. *//**************************************************/static void FixCursor()  {   WindowPtr whichWindow;   WDHandle theData;   Handle dataHandle;   void (*myCursorRoutine)(WindowPtr);   /*==============================================*/   /* Skip cursor adjustment during quit sequence. */   /*==============================================*/   if (Quitting) return;   /*====================================================*/   /* If the screen is empty, then use the arrow cursor. */   /*====================================================*/   whichWindow = FrontWindow();   if (whichWindow == NULL)     { SetCursor(&ARROW); }   /*==============================================*/   /* Else if one of our windows is active then... */   /*==============================================*/   else if (((WindowPeek) whichWindow)->windowKind >= userKind)     {      dataHandle = (Handle) GetWRefCon(whichWindow);      theData = (WDHandle) dataHandle;      myCursorRoutine = (**theData).cursorRoutine;      if (myCursorRoutine != NULL) (*myCursorRoutine)(whichWindow);      else SetCursor(&ARROW);     }  }/***************************************//* DoEvent: Get and process one event. *//***************************************/static void DoEvent()  {   int handleEvent;   EventRecord myEvent;   /*===========================*/   /* Clear the I/O error flag. */   /*===========================*/   ErrorFlag = false;   /*=====================*/   /* Get the next event. */   /*=====================*/   handleEvent = GetTheEvent(everyEvent,&myEvent);   /*===================================================*/   /* If Event is to be handled by this program then... */   /*===================================================*/   if (handleEvent)     {      switch (myEvent.what)        {         /*==========================*/         /* Handle mouse-down event. */         /*==========================*/         case mouseDown:           if (! Quitting) DoMouseDown(&myEvent);           break;         /*===================*/         /* Handle keystroke. */         /*===================*/         case keyDown:         case autoKey:           if (! Quitting) DoKeystroke(&myEvent);           break;         /*======================*/         /* Handle update event. */         /*======================*/         case updateEvt:           DoUpdate(&myEvent);           break;         /*===================================*/         /* Handle activate/deactivate event. */         /*===================================*/         case activateEvt:           DoActivate(&myEvent);           break;         /*==============================*/         /* Handle suspend/resume event. */         /*==============================*/         case osEvt:           DoSuspendResume(&myEvent);           break;                    /*==========================*/          /* Handle high level event. */         /*==========================*/         case kHighLevelEvent:           DoHighLevelEvent(&myEvent);           break;          /*===============*/         /* Default case. */         /*===============*/                  default:           break;        }     }   /*===========================================================*/   /* Else if quitting and no other events are occuring then... */   /*===========================================================*/   else if (Quitting && (myEvent.what == nullEvent))     {      /*============================================*/      /* If any window are left on the screen, then */      /* close the frontmost window.                */      /*============================================*/      if (FrontWindow() != NULL) DoClose(FrontWindow());      /*=============================*/      /* Else exit from the program. */      /*=============================*/      else        {         RemoveVBLTask();         WriteDeskScrap();/*                  ProfilerTerm();*/         ExitToShell();        }     }  }/*****************************************//* DoMouseDown: Handle mouse-down event. *//*****************************************/static void DoMouseDown(myEvent)  EventRecord *myEvent;  {   WindowPtr whichWindow;   /*============================================*/   /* Where on the screen was the mouse pressed? */   /*============================================*/   switch (FindWindow(myEvent->where,&whichWindow))     {      /*====================================*/      /* Handle click in desk - do nothing. */      /*====================================*/      case inDesk:        break;      /*===========================*/      /* Handle click in menu bar. */      /*===========================*/      case inMenuBar:        DoMenuClick(myEvent);        break;      /*================================*/      /* Handle click in system window. */      /*================================*/      case inSysWindow:        SystemClick(myEvent,whichWindow);        break;      /*=================================*/      /* Handle click in content region. */      /*=================================*/      case inContent:        DoContent(whichWindow,myEvent);        break;      /*==============================*/      /* Handle click in drag region. */      /*==============================*/      case inDrag:        DoDrag(whichWindow,myEvent);        break;      /*==============================*/      /* Handle click in size region. */      /*==============================*/      case inGrow:        DoGrow(whichWindow,myEvent);        break;      /*===============================*/      /* Handle click in close region. */      /*===============================*/      case inGoAway:        DoGoAway(whichWindow,myEvent);        break;      /*=================================*/      /* Handle click in zoom in region. */      /*=================================*/      case inZoomIn:        DoZoom(whichWindow,inZoomIn,myEvent);        break;      /*==================================*/      /* Handle click in zoom out region. */      /*==================================*/      case inZoomOut:        DoZoom(whichWindow,inZoomOut,myEvent);        break;     }  }/*****************************************************//* DoMenuClick: Handle mouse-down event in menu bar. *//*****************************************************/static void DoMenuClick(myEvent)  EventRecord *myEvent;  {   long int menuChoice;   /*============================*/   /* Update the Menu Bar first. */   /*============================*/   UpdateMenuBar(myEvent);   /*==================*/   /* Track the mouse. */   /*==================*/   menuChoice = MenuSelect(myEvent->where);   /*============================*/   /* Handle user's menu choice. */   /*============================*/   DoMenuChoice(menuChoice);  }/********************************************//* DoMenuChoice: Handle user's menu choice. *//********************************************/static void DoMenuChoice(  long int menuChoice)  {   int theMenu;   int theItem;   /*=====================================*/   /* If no choice was made, then return. */   /*=====================================*/   if (menuChoice == 0) return;   /*==================================*/   /* Get the menu id and item number. */   /*==================================*/   theMenu = HiWord(menuChoice);   theItem = LoWord(menuChoice);   /*==========================*/   /* Which menu was selected? */   /*==========================*/   switch (theMenu)     {      /*================================*/      /* Handle choice from Apple menu. */      /*================================*/      case AppleID:        DoAppleChoice(theItem);        break;      /*===============================*/      /* Handle choice from File menu. */      /*===============================*/      case FileID:        DoFileChoice(theItem,FrontWindow());        break;      /*===============================*/      /* Handle choice from Edit menu. */      /*===============================*/      case EditID:        DoEditChoice(theItem,FrontWindow());        break;      /*=================================*/      /* Handle choice from Buffer menu. */      /*=================================*/      case BufferID:        DoBufferChoice(theItem,FrontWindow());        break;      /*====================================*/      /* Handle choice from Execution menu. */      /*====================================*/      case CommandsID:        DoExecutionChoice(theItem);        break;      /*=================================*/      /* Handle choice from Browse menu. */      /*=================================*/      case BrowseID:        DoBrowseChoice(theItem);        break;              /*=================================*/      /* Handle choice from Module menu. */      /*=================================*/      case ModuleID:        DoModuleChoice(theItem);        break;              /*=================================*/      /* Handle choice from Window menu. */      /*=================================*/      case WindowID:        DoWindowChoice(theItem);        break;     }   /*=========================*/   /* Unhighlight menu title. */   /*=========================*/   HiliteMenu(0);  }/*****************************************************//* DoAppleChoice: Handle choice from the Apple menu. *//*****************************************************/static void DoAppleChoice(theItem)  int theItem;  {   Str255 accName;   /*===============================*/   /* Which menu item was selected? */   /*===============================*/   switch (theItem)     {      /*======================================*/      /* Handle About Application... command. */      /*======================================*/      case AboutApplicationItem:        DoAbout();        break;      /*==========================*/      /* Handle a desk accessory. */      /*==========================*/      default:        GetItem(AppleMenu,theItem,accName);        OpenDeskAcc(accName);        break;     }  }/*********************************************//* DoKeystroke: Processes a keystroke event. *//*********************************************/static void DoKeystroke(theEvent)  EventRecord *theEvent;  {   int chCode;   char ch;   long int menuChoice;   /*===========================================================*/   /* Extract the character code and convert it to a character. */   /*===========================================================*/   chCode = BitAnd(theEvent->message,charCodeMask);   ch = (char) chCode;   /*=====================================*/   /* If the command key is down, then... */   /*=====================================*/   if (BitAnd(theEvent->modifiers,cmdKey) != 0)     {      /*===========================*/      /* Check for command period. */      /*===========================*/      if (ch == '.')        {         if (BitAnd(theEvent->modifiers,shiftKey) != 0)           {            SetHaltExecution(1);            CloseAllBatchSources();           }         else           {#if DEFRULE_CONSTRUCT            if (ExecutingRule != NULL) HaltRules = TRUE;            else#endif              {               SetHaltExecution(1);               CloseAllBatchSources();              }           }        }      /*================================================*/      /* If the key is not being repeated, then get the */      /* menu equivalent and handle as a menu choice.   */      /*================================================*/      else if (theEvent->what != autoKey)        {         UpdateMenuBar(theEvent);         menuChoice = MenuKey(ch);         DoMenuChoice(menuChoice);        }     }   else if ((BitAnd(theEvent->modifiers,controlKey) != 0) && (ch == CONTROL_C))     { SetHaltExecution(1); }   /*==============================================*/   /* Else handle keystroke as a normal character. */   /*==============================================*/   else     { DoTyping((int) ch,theEvent->modifiers); }  }/*******************************************************//* DoTyping: Handle character typed from the keyboard. *//*******************************************************/static void DoTyping(  int ch,  EventModifiers theModifiers)  {   WindowPtr whichWindow;   WDHandle theData;   Handle dataHandle;   void (*myKeystrokeRoutine)(WindowPtr,int,EventModifiers);   /*==================================================*/   /* If the screen is empty, keystrokes are consumed. */   /*==================================================*/   whichWindow = FrontWindow();   if (whichWindow == NULL) return;   /*===================================================*/   /* Call the keystroke routine for the active window. */   /*===================================================*/   if (((WindowPeek) whichWindow)->windowKind >= userKind)     {      dataHandle = (Handle) GetWRefCon(whichWindow);      theData = (WDHandle) dataHandle;      myKeystrokeRoutine = (**theData).keystrokeRoutine;      if (myKeystrokeRoutine != NULL) (*myKeystrokeRoutine)(whichWindow,ch,theModifiers);     }  }/***********************************************//* DoHighLevelEvent: Handle high level events. *//***********************************************/static void DoHighLevelEvent(theEvent)  EventRecord *theEvent;  {    AEProcessAppleEvent(theEvent);  }/*************************************************//* DoAbout: Handle About Application... command. *//*************************************************/static void DoAbout()  {   Str255 p1, p2, p3;      sprintf((char *) p1,"%s",APPLICATION_NAME);   CTOPSTR((char *) p1);   sprintf((char *) p2,"%s",VERSION_STRING);   CTOPSTR((char *) p2);   sprintf((char *) p3,"%s",CREATION_DATE_STRING);   CTOPSTR((char *) p3);      ParamText(p1,p2,p3,"\p");   Alert(ApplicationAlert,(ModalPtr) DefaultDialogFilterRef);  }/**************************************//* MacPeriodicFunction:               *//**************************************/void MacPeriodicFunction()  {   static unsigned long int lastCall;#if ! RUN_TIME   if ((! EvaluatingTopLevelCommand) && (! BatchActive())) return;#else   if (! BatchActive()) return;#endif   if (TickCount() < (lastCall + 30)) return;   UpdateStatusWindows();   HandlePeriodicEvents();   lastCall = TickCount();   return;  }/**************************************//* MacYieldTimeFunction:              *//**************************************/void MacYieldTimeFunction()  {   static unsigned long int lastCall;   EventRecord theEvent;   if (TickCount() < (lastCall + 10)) return;      GetTheEvent(~everyEvent,&theEvent);      lastCall = TickCount();   return;  }  /**************************************//* UpdateStatusWindows:               *//**************************************/void UpdateStatusWindows()  {   int updateAll = false;   static long lastModuleIndex = -1;   if (lastModuleIndex != ModuleChangeIndex)      {      updateAll = TRUE;      lastModuleIndex = ModuleChangeIndex;     }      /*===================================================*/   /* Update the status windows if any changes occured. */   /*===================================================*/#if DEFRULE_CONSTRUCT   if ((AgendaWindow != NULL) &&        (updateAll || (GetAgendaChanged() == TRUE)))     {      UpdateStatusWindowTitle(AgendaWindow,"Agenda");      CompleteStatusRefresh(AgendaWindow);      SetAgendaChanged(false);     }        if ((FocusWindow != NULL) &&        (updateAll || (GetFocusChanged() == TRUE)))     {      CompleteStatusRefresh(FocusWindow);      SetFocusChanged(false);     }#endif#if DEFTEMPLATE_CONSTRUCT   if ((FactsWindow != NULL) &&        (updateAll || (GetFactListChanged() == TRUE)))     {      UpdateStatusWindowTitle(FactsWindow,"Facts");      CompleteStatusRefresh(FactsWindow);      GoToStatusWindowBottom(FactsWindow);      SetFactListChanged(false);     }#endif#if DEFGLOBAL_CONSTRUCT   if ((GlobalsWindow != NULL) &&       (updateAll || (GetGlobalsChanged() == TRUE)))     {      UpdateStatusWindowTitle(GlobalsWindow,"Globals");      CompleteStatusRefresh(GlobalsWindow);      SetGlobalsChanged(false);     }#endif#if OBJECT_SYSTEM   if ((InstancesWindow != NULL) &&       (updateAll || (GetInstancesChanged() == TRUE)))     {      UpdateStatusWindowTitle(InstancesWindow,"Instances");      CompleteStatusRefresh(InstancesWindow);      GoToStatusWindowBottom(InstancesWindow);      SetInstancesChanged(false);     }#endif  }  /**************************************//* HandlePeriodicEvents:              *//**************************************/void HandlePeriodicEvents()  {   EventRecord theEvent;   /*===============================================================*/   /* Search through events for ctrl-c or command-period interrupt. */   /* Also handle update events for some of the interface windows.  */   /* Only keypress events and update events are processed.         */   /*===============================================================*/   while (GetTheEvent(everyEvent & (~highLevelEventMask),&theEvent) != 0)     {      switch (theEvent.what)        {         case nullEvent:           return;           break;         /*=====================*/         /* Handle mouse event. */         /*=====================*/         case mouseDown:           if (! Quitting)             {              HandlingEvent = TRUE;              InitCursor();              DoMouseDown(&theEvent);              HandlingEvent = false;             }           break;         /*======================*/         /* Handle update event. */         /*======================*/         case updateEvt:           DoUpdate(&theEvent);           break;         /*===================================*/         /* Handle activate/deactivate event. */         /*===================================*/         case activateEvt:           DoActivate(&theEvent);           break;         /*==============================*/         /* Handle suspend/resume event. */         /*==============================*/         case osEvt:           DoSuspendResume(&theEvent);           break;         /*=======================================*/         /* Look for command-period or control-c. */         /*=======================================*/         case keyDown:         case autoKey:           {            char theChar;            theChar = theEvent.message & charCodeMask;            if ((BitAnd(theEvent.modifiers,cmdKey) != 0) &&                (theChar == '.'))              {               if (BitAnd(theEvent.modifiers,shiftKey) != 0)                {                 SetHaltExecution(1);                 CloseAllBatchSources();                }               else                {#if DEFRULE_CONSTRUCT                 if (ExecutingRule != NULL) HaltRules = TRUE;                 else#endif                   {                    SetHaltExecution(1);                    CloseAllBatchSources();                   }                }               return;              }            else if ((BitAnd(theEvent.modifiers,controlKey) != 0) &&                      (theChar == CONTROL_C))              {               if (BitAnd(theEvent.modifiers,shiftKey) != 0)                { SetHaltExecution(1); }               else                {#if DEFRULE_CONSTRUCT                 if (ExecutingRule != NULL) HaltRules = TRUE;                 else #endif                   { SetHaltExecution(1); }                }               return;              }            break;           }        }     }  }