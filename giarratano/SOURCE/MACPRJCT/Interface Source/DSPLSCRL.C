   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  01/05/95          */   /*                                                     */   /*            DISPLAY WINDOW SCROLL MODULE             */   /*******************************************************//*************************************************************//* Purpose: Routines for scrolling and selecting the         *//*   contents of the display window.                         *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _DSPLSCRL_SOURCE_#include "setup.h"#include <stdio.h>#define _STDIO_INCLUDED_#include <string.h>#include <OSUtils.h>#include <ToolUtils.h>#include <Devices.h>/* #include <Desk.h> */#include <Scrap.h>#include <Memory.h>#include <Windows.h>#include <Controls.h>#include <Events.h>#include <Menus.h>#if MAC_MCW || MAC_SC7 || MAC_MPW || MAC_SC8#include <Printing.h>#else#include <PrintTraps.h>#endif#include <SegLoad.h>#include <Fonts.h>#define ARROW (qd.arrow)#include "router.h"#include "commline.h"#include "dsplwdrg.h"#include "stnrdmac.h"#include "window.h"#include "displayw.h"#include "menuhndl.h"#include "macinit.h"#include "undo.h"#include "clpscrap.h"#include "dsplscrl.h"#if MAC_SC7 || MAC_MCW || MAC_SC8#define ControlProcPtr ControlActionUPP#else#define ControlProcPtr ProcPtr#endif/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static pascal void      DisplayScrollProc(ControlHandle,short int);   static void             DoDisplaySelect(Point *,WindowPtr,int);   static void             FindInsertionPoint(Point *,int *,int *);#if (MAC_MCW && __powerc) || MAC_SC8   static RoutineDescriptor DisplayScrollProcRD       = BUILD_ROUTINE_DESCRIPTOR(uppControlActionProcInfo,DisplayScrollProc);#define DisplayScrollProcRef &DisplayScrollProcRD#else#define DisplayScrollProcRef DisplayScrollProc#endif/***************************************//* LOCAL INTERNAL VARIABLE DEFINITIONS *//***************************************/   static int              ScrollCode;   static int              ScrollAmt;   /********************************************************//* SetDisplayScroll: Recomputes the number of settings  *//*   for the vertical scroll bar in the display window. *//********************************************************/void SetDisplayScroll()  {   AdjustDisplayVerticalScroll();   AdjustDisplayHorizontalScroll();  }/******************************************************************//* AdjustDisplayVerticalScroll: Recomputes the number of settings *//*   for the vertical scroll bar in the display window.           *//******************************************************************/void AdjustDisplayVerticalScroll()  {   int count = 0;   int n, max;   /*===========================================================*/   /* Set n to the number of lines in the display history minus */   /* the number of lines that can be displayed on the screen.  */   /*===========================================================*/   n = LinesInUse - LinesInDisplayWindow;   /*====================================================*/   /* Maximum scroll position is n, or zero if all lines */   /* fit in present screen.                             */   /*====================================================*/   max = ( n > 0 ? n : 0 );   /*====================================================*/   /* Set the maximum value for the vertical scroll bar. */   /*====================================================*/   SetCtlMax(DisplayVScroll,max);  }/********************************************************************//* AdjustDisplayHorizontalScroll: Recomputes the number of settings *//*   for the horizontal scroll bar in the display window.           *//********************************************************************/void AdjustDisplayHorizontalScroll()  {   int windowWidth;   int maxTop;   /*========================*/   /* Get the window width. */   /*========================*/   windowWidth = ((*DisplayWindow).portRect.right - (*DisplayWindow).portRect.left) /                   CharacterWidth;   /*==================================*/   /* Avoid white space at the bottom. */   /*==================================*/   maxTop = (VIRTUAL_HORIZONTAL_WIDTH / CharacterWidth) - windowWidth;   /*=========================================*/   /* If the text is smaller than the window, */   /* then show all of the text.              */   /*=========================================*/   if (maxTop <= 0) maxTop = 0;   /*=====================================*/   /* Adjust the range of the scroll bar. */   /*=====================================*/   SetCtlMax(DisplayHScroll,maxTop);  }/****************************************************************************//* DisplayScrollProc: Scroll the display history within the display window. *//****************************************************************************/static pascal void DisplayScrollProc(  ControlHandle theControl,  short int theCode)  {   int locVal;   if (theCode == ScrollCode)     {      locVal = GetCtlValue(theControl);      SetDisplayScroll();       SetCtlValue(theControl,locVal + ScrollAmt);      UpdateDisplayWindow(DisplayWindow);     }  }/****************************************************//* DoDisplayContent: Handle mouse-down event in the *//*   content region of the display window.          *//****************************************************/short DoDisplayContent(myEvent,whichWindow)  EventRecord *myEvent;  WindowPtr whichWindow;  {   int cntlCode;   ControlHandle theControl;   int pageSize;   GrafPtr savePort;   Point thePoint;   short rv = 1;      /*=======================================================*/   /* Save the old port. Set the port to the agenda window. */   /*=======================================================*/   GetPort(&savePort);   SetPort(whichWindow);   /*==============================================*/   /* Get the mouse location in screen coordinates */   /* and convert it to window coordinates.        */   /*==============================================*/   thePoint = myEvent->where;   GlobalToLocal(&thePoint);   /*===================================================*/   /* Determine where the click occurred and handle it. */   /*===================================================*/   switch (cntlCode = FindControl(thePoint,whichWindow,&theControl))     {      case inUpButton:      case inDownButton:      case inPageUp:      case inPageDown:        if (theControl == DisplayVScroll)          { pageSize = LinesInDisplayWindow; }        else if (theControl == DisplayHScroll)          {           pageSize = (*whichWindow).portRect.right - (*whichWindow).portRect.left;           pageSize -= (SCROLL_BAR_WIDTH - 1);           pageSize = pageSize / CharacterWidth;          }        switch (cntlCode)          {           case inUpButton:             ScrollAmt = -1;             break;           case inDownButton:             ScrollAmt = 1;             break;           case inPageUp:             ScrollAmt = -pageSize;             break;           case inPageDown:             ScrollAmt = pageSize;             break;          }        ScrollCode = cntlCode;        if (TrackControl(theControl,thePoint,(ControlProcPtr) DisplayScrollProcRef))          { /* Do Nothing */ }        break;      case inThumb:        if (TrackControl(theControl,thePoint,(ControlProcPtr) NULL))          { /* Do Nothing */ }        UpdateDisplayWindow(DisplayWindow);        break;      default:        break;     }   /*=======================================================*/   /* If a control was not find, and the user did not click */   /* in an inactive control, then the user clicked in the  */   /* text region so text selection must be processed.      */   /*=======================================================*/   if ((theControl == NULL) &&       (PtInRect(thePoint,&(*DisplayVScroll)->contrlRect) == 0))     {      if (ClickInDisplayDragRegion(thePoint))         {         rv = 0;          if (! DoDisplayDragAndDrop(myEvent,whichWindow))           {             if (whichWindow == FrontWindow() && (! Suspended))               {                DoDisplaySelect(&thePoint,whichWindow,                             (int) (BitAnd(myEvent->modifiers,shiftKey) != 0));              }            else              {                SelectWindow(whichWindow);               rv = 1;               }           }        }      else         {          if (whichWindow == FrontWindow() && (! Suspended))            {            DoDisplaySelect(&thePoint,whichWindow,                            (int) (BitAnd(myEvent->modifiers,shiftKey) != 0));           }         else           { SelectWindow(whichWindow); }        }     }   /*=======================*/   /* Restore the old port. */   /*=======================*/   SetPort(savePort);   return(rv);  }/*****************************************************//* DoDisplaySelect: Handles a mouse click within the *//*    text content area of the display window.       *//*****************************************************/static void DoDisplaySelect(thePoint,whichWindow,extendIt)  Point *thePoint;  WindowPtr whichWindow;  int extendIt;  {   Rect textRect;   Point mousePoint;   int lastLine, lastChar;   /*===============================*/   /* Remove the cursor if visible. */   /*===============================*/      if (CursorVisible)     {      DrawCursor();       CursorVisible = false;     }   CursorHideLock = TRUE;      /*======================================================*/   /* Determine where the text regions lies in the window. */   /*======================================================*/   textRect.left = whichWindow->portRect.left;   textRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1);   textRect.top = whichWindow->portRect.top;   textRect.bottom = whichWindow->portRect.bottom - (SCROLL_BAR_WIDTH - 1);   /*======================================================*/   /* If the shift key is down, then extend the selection. */   /*======================================================*/   if (extendIt)     {      FindInsertionPoint(thePoint,&lastLine,&lastChar);      if ((lastLine < SelectionLineStart) ||          ((lastLine == SelectionLineStart) && (lastChar < SelectionCharStart)))        {         ExtendDisplaySelection(whichWindow,SelectionLineStart,SelectionCharStart,                                            lastLine,lastChar);         SelectionLineStart = SelectionLineEnd;         SelectionCharStart = SelectionCharEnd;         SelectionLineEnd = lastLine;         SelectionCharEnd = lastChar;        }      else        {         ExtendDisplaySelection(whichWindow,SelectionLineEnd,SelectionCharEnd,                                            lastLine,lastChar);         SelectionLineEnd = lastLine;         SelectionCharEnd = lastChar;        }     }   else     {      /*===========================*/      /* Remove the old selection. */      /*===========================*/            ExtendDisplaySelection(whichWindow,SelectionLineStart,SelectionCharStart,                                         SelectionLineEnd,SelectionCharEnd);      /*=============================================================*/      /* Determine the starting line and character of the selection. */      /*=============================================================*/      FindInsertionPoint(thePoint,&SelectionLineStart,&SelectionCharStart);      lastLine = SelectionLineStart;      lastChar = SelectionCharStart;     }   /*=================================================================*/   /* Track the selection while the user holds the mouse button down. */   /*=================================================================*/      while (Button())     {      /*===============================================*/      /* Get the current location of the mouse. Scroll */      /* if the mouse falls outside the text region.   */      /*===============================================*/      GetMouse(&mousePoint);      ScrollCode = 0;      if (mousePoint.v < textRect.top)        {         ScrollAmt = -1;         DisplayScrollProc(DisplayVScroll,0);        }      else if (mousePoint.v > textRect.bottom)        {         ScrollAmt = 1;         DisplayScrollProc(DisplayVScroll,0);        }      if (mousePoint.h < textRect.left)        {         ScrollAmt = -1;         DisplayScrollProc(DisplayHScroll,0);        }      else if (mousePoint.h > textRect.right)        {         ScrollAmt = 1;         DisplayScrollProc(DisplayHScroll,0);        }      else        {         ScrollAmt = 0;         DisplayScrollProc(DisplayVScroll,0);        }      /*==================================================*/      /* Determine the new amount of text to be selected. */      /*==================================================*/      FindInsertionPoint(&mousePoint,&SelectionLineEnd,&SelectionCharEnd);      ExtendDisplaySelection(whichWindow,lastLine,lastChar,SelectionLineEnd,SelectionCharEnd);      lastLine = SelectionLineEnd;      lastChar = SelectionCharEnd;     }            /*=============================================*/   /* Switch start and end positions if the start */   /* position comes after the end position.      */   /*=============================================*/   if ((SelectionLineStart > SelectionLineEnd) ||       ((SelectionLineStart == SelectionLineEnd) &&        (SelectionCharStart > SelectionCharEnd)))     {      int temp;      temp = SelectionLineEnd;      SelectionLineEnd = SelectionLineStart;      SelectionLineStart = temp;      temp = SelectionCharEnd;      SelectionCharEnd = SelectionCharStart;      SelectionCharStart = temp;     }        /*===============================*/   /* Draw the cursor if necessary. */   /*===============================*/      if (CursorShouldBeDrawn())     {       DrawCursor();       CursorVisible = TRUE;     }   CursorHideLock = false;  }/*****************************************************************//* FindInsertionPoint: Given a point (indicating the location of *//*   the cursor), this routine finds the closest insertion point *//*   to the point (given as a line and character position).      *//*   The point passed to this routine should be in local         *//*   coordinates.                                                *//*****************************************************************/static void FindInsertionPoint(thePoint,theLine,theCharacter)  Point *thePoint;  int *theLine, *theCharacter;  {   /*=================================================================*/   /* The line the cursor is on can be found by dividing the vertical */   /* distance from the top of the buffer by the height of each line. */   /* Then the number of lines above the top line in the window is    */   /* added to this total.                                            */   /*=================================================================*/   if (thePoint->v < 0)     { *theLine = TopDisplayNumber; }   else     {       *theLine = (thePoint->v / DisplayLineHeight) + TopDisplayNumber;       if (*theLine >= (LinesInDisplayWindow + TopDisplayNumber))        { *theLine = (LinesInDisplayWindow + TopDisplayNumber) - 1; }     }   /*===============================================================*/   /* The character insertion point can be found by subtracting the */   /* left window margin and the number of pixels that have been    */   /* scrolled off to the left from the horizontal distance to      */   /* the left side of the buffer. This result is then divided by   */   /* the width of a character to determine which character the     */   /* insertion point falls before. Note this calculation assumes   */   /* that all characters have the same width so it will only work  */   /* for a font such as monaco or courier.                         */   /*===============================================================*/   *theCharacter = (thePoint->h -                    LeftWindowMargin +                    (LeftMarginNumber * CharacterWidth)) /                   CharacterWidth;   /*================================================================*/   /* If the cursor falls more than halfway across a character, then */   /* the insertion point is after the character, not before it.     */   /*================================================================*/   if (thePoint->h >= ((*theCharacter * CharacterWidth) +                       LeftWindowMargin -                       (LeftMarginNumber * CharacterWidth) +                       (CharacterWidth / 2)))     { (*theCharacter)++; }   if (*theCharacter < 0) *theCharacter = 0;   if (*theLine > (LinesInUse - 1))     {      *theLine = LinesInUse - 1;      *theCharacter = DisplayText[AppendDisplayLine].insertPoint;     }   else     {      int lineOfInterest;      lineOfInterest = (ZeroDisplayLine + (*theLine)) % MAX_DISPLAY_LINES;      if (*theCharacter > DisplayText[lineOfInterest].insertPoint)        { *theCharacter = DisplayText[lineOfInterest].insertPoint; }     }  }/*****************************************************************//* ExtendDisplaySelection                                        *//*****************************************************************/void ExtendDisplaySelection(whichWindow,lastLine,lastChar,nextLine,nextChar)  WindowPtr whichWindow;  int lastLine, lastChar, nextLine, nextChar;  {   Rect theRect;   int i;   /*=========================================*/   /* If the selection is not being extended, */   /* then nothing needs to be done.          */   /*=========================================*/   if ((lastLine == nextLine) && (nextChar == lastChar))     { return; }      /*================================*/   /* Handle extending the last line */   /* of the current selection.      */   /*================================*/   if ((lastLine == nextLine) && (nextChar > lastChar))     {      theRect.left = whichWindow->portRect.left + LeftWindowMargin +                    (lastChar * CharacterWidth) -                    (LeftMarginNumber * CharacterWidth);      if (lastChar == 0) theRect.left -= LeftWindowMargin;      theRect.right = whichWindow->portRect.left + LeftWindowMargin +                     (nextChar * CharacterWidth) -                     (LeftMarginNumber * CharacterWidth);      theRect.top = (lastLine - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + DisplayLineHeight;      CropScrollBarSpillage(&theRect,whichWindow);      InvertRect(&theRect);      return;     }      /*========================================*/   /* Handle shortening the selection on the */   /* last line of the current selection.    */   /*========================================*/   if ((lastLine == nextLine) && (nextChar < lastChar))     {      theRect.left = whichWindow->portRect.left + LeftWindowMargin +                    (nextChar * CharacterWidth) -                    (LeftMarginNumber * CharacterWidth);      if (nextChar == 0) theRect.left -= LeftWindowMargin;      theRect.right = whichWindow->portRect.left + LeftWindowMargin +                     (lastChar * CharacterWidth) -                     (LeftMarginNumber * CharacterWidth);      theRect.top = (lastLine - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + DisplayLineHeight;      CropScrollBarSpillage(&theRect,whichWindow);      InvertRect(&theRect);      return;     }        /*====================================================*/   /* Handle extending the current selection by adding   */   /* several lines to the end of the current selection. */   /*====================================================*/      if (lastLine < nextLine)     {      theRect.left = whichWindow->portRect.left + LeftWindowMargin +                    (lastChar * CharacterWidth) -                    (LeftMarginNumber * CharacterWidth);      if (lastChar == 0) theRect.left -= LeftWindowMargin;      theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH -1);      theRect.top = (lastLine - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + DisplayLineHeight;      CropScrollBarSpillage(&theRect,whichWindow);      InvertRect(&theRect);      for (i = lastLine + 1; i < nextLine; i++)        {         theRect.left = whichWindow->portRect.left;         theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH -1);         theRect.top = (i - TopDisplayNumber) * DisplayLineHeight;         theRect.bottom = theRect.top + DisplayLineHeight;         CropScrollBarSpillage(&theRect,whichWindow);         InvertRect(&theRect);        }      if (nextChar != 0)        {         theRect.left = whichWindow->portRect.left;         theRect.right = whichWindow->portRect.left + LeftWindowMargin +                       (nextChar * CharacterWidth) -                       (LeftMarginNumber * CharacterWidth);         theRect.top = (nextLine - TopDisplayNumber) * DisplayLineHeight;         theRect.bottom = theRect.top + DisplayLineHeight;         CropScrollBarSpillage(&theRect,whichWindow);         InvertRect(&theRect);        }      return;     }      /*=======================================================*/   /* Handle shortening the current selection by removing   */   /* several lines from the end of the current selection.  */   /* This may also  extend the current selection by adding */   /* selected lines before the beginning of the current    */   /* selection.                                            */   /*=======================================================*/      if (lastLine > nextLine)     {      if (lastChar != 0)        {         theRect.left = whichWindow->portRect.left;         theRect.right = whichWindow->portRect.left + LeftWindowMargin +                       (lastChar * CharacterWidth) -                       (LeftMarginNumber * CharacterWidth);         theRect.top = (lastLine - TopDisplayNumber) * DisplayLineHeight;         theRect.bottom = theRect.top + DisplayLineHeight;         CropScrollBarSpillage(&theRect,whichWindow);         InvertRect(&theRect);        }      for (i = lastLine - 1; i > nextLine; i--)        {         theRect.left = whichWindow->portRect.left;         theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1);         theRect.top = (i - TopDisplayNumber) * DisplayLineHeight;         theRect.bottom = theRect.top + DisplayLineHeight;         CropScrollBarSpillage(&theRect,whichWindow);         InvertRect(&theRect);        }      theRect.left = whichWindow->portRect.left + LeftWindowMargin +                    (nextChar * CharacterWidth) -                    (LeftMarginNumber * CharacterWidth);      if (nextChar == 0) theRect.left -= LeftWindowMargin;      theRect.right = whichWindow->portRect.right - (SCROLL_BAR_WIDTH -1);      theRect.top = (nextLine - TopDisplayNumber) * DisplayLineHeight;      theRect.bottom = theRect.top + DisplayLineHeight;      CropScrollBarSpillage(&theRect,whichWindow);      InvertRect(&theRect);     }  }/*******************************************************//* CropScrollBarSpillage:  *//*******************************************************/void CropScrollBarSpillage(theRect,whichWindow)  Rect *theRect;  WindowPtr whichWindow;  {   if (theRect->right > (whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1)))     { theRect->right = (whichWindow->portRect.right - (SCROLL_BAR_WIDTH - 1)); }   if (theRect->bottom > DisplayLineHeight * LinesInDisplayWindow)     { theRect->bottom = DisplayLineHeight * LinesInDisplayWindow; }  }/*******************************************************//* ScrollDisplay: Scrolls the contents of the window. *//*******************************************************/void ScrollDisplay()  {   RgnHandle tmpRgn;   int dv, dh;   Rect viewRect;   int old_number;   /*==================================================*/   /* Compute the vertical difference in the text from */   /* the old location of the origin and the current   */   /* position indicated by the vertical scroll bar.   */   /*==================================================*/   old_number = TopDisplayNumber;   TopDisplayNumber = GetCtlValue(DisplayVScroll);   dv = (old_number - (TopDisplayNumber + LinesLost)) * DisplayLineHeight;   LinesLost = 0;   /*====================================================*/   /* Compute the horizontal difference in the text from */   /* the old location of the origin and the current     */   /* position indicated by the horizontal scroll bar.   */   /*====================================================*/   old_number = LeftMarginNumber;   LeftMarginNumber = GetCtlValue(DisplayHScroll);   dh = (old_number - LeftMarginNumber) * CharacterWidth;   /*==================================================*/   /* Offset the destination rectangle to scroll text. */   /*==================================================*/   viewRect = (*DisplayWindow).portRect;   viewRect.right -= (SCROLL_BAR_WIDTH - 1);   viewRect.bottom = DisplayLineHeight * LinesInDisplayWindow;   /*===========================================*/   /* Create a region to store the update area. */   /*===========================================*/   tmpRgn = NewRgn();   /*============================================================*/   /* If scrolling needs to be performed, then do it. Invalidate */   /* the area that is left empty by scrolling.                  */   /*============================================================*/   if ((dv != 0) || (dh != 0))     {      ScrollRect(&viewRect,dh,dv,tmpRgn);      InvalRgn(tmpRgn);     }   /*========================*/   /* Dispose of the region. */   /*========================*/   DisposeRgn(tmpRgn);  }  /*************************************************************//* DisplayKeyBoardScroll: Handles scrolling of the display   *//*   window for use with the page up, page down, down arrow, *//*   up arrow, right arrow, and left arrow keys.             *//*************************************************************/void DisplayKeyBoardScroll(  WindowPtr whichWindow,  ControlHandle theControl,  int cntlCode)  {   int pageSize;   int locVal;   int howMuch;      if (theControl == DisplayVScroll)     { pageSize = LinesInDisplayWindow; }   else if (theControl == DisplayHScroll)     {      pageSize = (*whichWindow).portRect.right - (*whichWindow).portRect.left;      pageSize -= (SCROLL_BAR_WIDTH - 1);      pageSize = pageSize / CharacterWidth;     }             switch (cntlCode)     {      case inUpButton:        howMuch = -1;        break;                   case inDownButton:        howMuch = 1;        break;                   case inPageUp:        howMuch = -pageSize;        break;              case inPageDown:        howMuch = pageSize;        break;              default:        Bogus(TRUE);        break;     }   locVal = GetCtlValue(theControl);   SetDisplayScroll();    SetCtlValue(theControl,locVal + howMuch);   UpdateDisplayWindow(DisplayWindow);  }  /*************************************//* DisplaySelectAll: Selects all of  *//*   the text in the display window. *//*************************************/void DisplaySelectAll(  WindowPtr whichWindow)  {#if MAC_MPW || MAC_MCW#pragma unused(whichWindow)#endif   SelectionLineStart = 0;   SelectionLineEnd = LinesInUse - 1;   SelectionCharStart = 0;   SelectionCharEnd = DisplayText[AppendDisplayLine].insertPoint;   InvalRect(&DisplayWindow->portRect);  }