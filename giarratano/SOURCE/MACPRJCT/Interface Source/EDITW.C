   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                 EDIT WINDOW MODULE                  */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _EDITW_SOURCE_#include "setup.h"#include "commline.h"#include "filecom.h"#include <stddef.h>#include <ToolUtils.h>#include <Memory.h>#include <QuickDraw.h>#include <Windows.h>#include <Events.h>#include <Controls.h>#include <Dialogs.h>#include <TextEdit.h>#include <Menus.h>#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#define ARROW qd.arrow#include "apprsrcs.h"#include "stnrdmac.h"#include "editscrl.h"#include "editwdrg.h"#include "interface.h"#include "menuhndl.h"#include "search.h"#include "window.h"#include "editw.h"/***************//* DEFINITIONS *//***************/#define TAB_SPACES                          3#define TOP_MARGIN                         20#define LEFT_MARGIN                        20#define BOTTOM_MARGIN                      20#define TEXT_MARGIN                         4#define HORIZONTAL_SCROLL_INCREMENT        10#define MAX_BUFFER_SIZE              (32767L)#define StopCantDoID 1009  #define BALANCE_PARENTHESIS_PAUSE_DURATION 20 /****************************************//* GLOBAL INTERNAL VARIABLE DEFINITIONS *//****************************************/   #if (MAC_MCW && __powerc) || MAC_SC8   RoutineDescriptor       WordBreakRD       = BUILD_ROUTINE_DESCRIPTOR(uppWordBreakProcInfo,WordBreak);#endif/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void             DoArrowKey(int,int,WindowPtr);   static Boolean          FindBalancingParenthesis(char *,long,long *);   static void             HandleNonShiftedArrowKey(int,TEHandle,EWDHandle,WindowPtr,int);/**********************************//* DoEditTyping: Handles a single *//*   keystroke in an edit window. *//**********************************/void DoEditTyping(  WindowPtr whichWindow,  int ch,  EventModifiers theModifiers)  {   long int size;   EWDHandle theData;   Handle dataHandle;   TEHandle theText;   int arrowKey = false, shiftDown = false;   short position, spaceCount;   char *textPtr;    long startTime, whichChar, oldPosition;      /*================================*/   /* Handle home, end, page up, and */   /* page down key special cases.   */   /*================================*/      switch (ch)     {      case END_KEY:        ShowEditEnd(whichWindow,FALSE);        return;              case HOME_KEY:        ShowEditBegin(whichWindow,FALSE);        return;           case PAGE_UP_KEY:        EditKeyBoardScroll(whichWindow,inPageUp);        return;      case PAGE_DOWN_KEY:        EditKeyBoardScroll(whichWindow,inPageDown);        return;     }        /*=======================================================*/   /* Ignore control characters other than line feeds, tabs */   /* carriage returns, backspaces, and the arrow keys.     */   /*=======================================================*/   if (((ch == DELETE_KEY) || (ch < LEFT_ARROW_KEY)) &&        (ch != '\r') && (ch != '\n') && (ch != '\t') && (ch != '\b')) return;   /*=====================================*/   /* Arrow keys are handled differently. */   /*=====================================*/   if ((ch == LEFT_ARROW_KEY) || (ch == RIGHT_ARROW_KEY) ||       (ch == UP_ARROW_KEY) || (ch == DOWN_ARROW_KEY))     {       arrowKey = TRUE;             if (BitAnd(theModifiers,shiftKey) != 0)        { shiftDown = TRUE; }     }        /*=======================================*/   /* Get a handle to the text edit record. */   /*=======================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   /*====================================================*/   /* Check to make sure that adding the character won't */   /* force the buffer to be larger than 32K.            */   /*====================================================*/   if (ch == '\t') size = ((long int) (**theText).teLength) + (long) TAB_SPACES;   else if (ch == '\b') size = ((long int) (**theText).teLength) - 1L;   else if (arrowKey) size = ((long int) (**theText).teLength);   else size = ((long int) (**theText).teLength) + 1L;   if (size >= MAX_BUFFER_SIZE)     {      InitCursor();      ParamText("\pCan't insert character ",                "\p(only files 32K or smaller can be edited)","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      return;     }   /*===========================================*/   /* Make sure the insertion point is visible. */   /*===========================================*/   ScrollToSelection(false,whichWindow);   /*========================*/   /* Process the character. */   /*========================*/      if (((ch == '\r') || (ch == '\n')) &&       (**theText).selStart == (**theText).selEnd)     {      /*===================================================*/      /* If the user types a carriage return, then pad the */      /* left margin of the next line with the number of   */      /* spaces in the left margin of the previous line.   */      /*===================================================*/      /* Determine the current line. */            position = 0;      while ((**theText).selStart >= (**theText).lineStarts[position])        {          position++;         if (position == (**theText).nLines) break;        }              /* Go back to the previous line. */            position--;            position = (**theText).lineStarts[position];      HLock((**theText).hText);      textPtr = *(**theText).hText;      spaceCount = 0;      while ((textPtr[position] == ' ') &&             (position < (**theText).selStart)) // Added this        {         position++;         spaceCount++;        }      textPtr = NewPtr(spaceCount+1);      textPtr[0] = ch;      for (position = 1; position <= spaceCount; position++)        { textPtr[position] = ' '; }            if ((**theData).windowInfo.applicationHook != NULL)        {                (*(**theData).windowInfo.applicationHook)(whichWindow,NULL,NULL,ch,KEYSTROKE_MESSAGE);         for (position = 0; position < spaceCount; position++)            { (*(**theData).windowInfo.applicationHook)(whichWindow,NULL,NULL,' ',KEYSTROKE_MESSAGE); }         }               TEInsert(textPtr,spaceCount+1,theText);      DisposPtr (textPtr);                      HUnlock((**theText).hText);            ResetShiftSelectionAnchor(whichWindow);     }   else if (ch != '\t')     {      if ((**theData).windowInfo.applicationHook != NULL)        { (*(**theData).windowInfo.applicationHook)(whichWindow,NULL,NULL,ch,KEYSTROKE_MESSAGE); }              if (arrowKey)        { DoArrowKey(ch,shiftDown,whichWindow); }      else        {          TEKey(ch,theText);         ResetShiftSelectionAnchor(whichWindow);                   if (ch == ')')           {            HLock((**theText).hText);            textPtr = *(**theText).hText;              if (FindBalancingParenthesis(textPtr,(**theText).selStart - 2,&whichChar))               {               oldPosition = (**theText).selStart;                              TESetSelect(whichChar,whichChar+1,theText);                                                         startTime = TickCount();                while (TickCount() < (startTime + BALANCE_PARENTHESIS_PAUSE_DURATION))                 { /* Wait */ }                                                         TESetSelect(oldPosition,oldPosition,theText);              }            else              { SysBeep(10); }                          HUnlock((**theText).hText);           }        }     }   else     {      int i = 0;      ch = ' ';      for (i = 0; i < TAB_SPACES; i++)        {         if ((**theData).windowInfo.applicationHook != NULL)           { (*(**theData).windowInfo.applicationHook)(whichWindow,NULL,NULL,ch,KEYSTROKE_MESSAGE); }         TEKey(ch,theText);        }      ResetShiftSelectionAnchor(whichWindow);     }        /*==================================================================*/   /* Adjust the scroll bar to the length of the text, adjust the text */   /* to match the scroll bar, and keep the insertion point visible.   */   /*==================================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(false,whichWindow);   /*===========================*/   /* Mark the window as dirty. */   /*===========================*/   if (! arrowKey) WindowDirty(whichWindow,TRUE);  }/********************************************//* FixText: Resize window's text rectangle. *//********************************************/void FixText(whichWindow)  WindowPtr whichWindow;  {   int topLine;   int firstChar;   int theLine;   int oldVScroll, newVScroll, oldHScroll, newHScroll;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*===================================*/   /* Indicate delay with watch cursor. */   /*===================================*/   SetCursor(*WatchCursor);   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock( (Handle) myText);   /*==========================================*/   /* Get the previous first line and find the */   /* first character previously visible.      */   /*==========================================*/   topLine = GetCtlValue(myVScrollBar);   firstChar = (**myText).lineStarts[topLine];   /*=================================================================*/   /* Display the text in the window's port rectangle. Adjust the     */   /* rectangle by excluding the top and bottom scroll bars (allowing */   /* for a 1 pixel overlap), and truncate the bottom to display only */   /* a whole number of lines.                                        */   /*=================================================================*/   (**myText).viewRect = (*whichWindow).portRect;   (**myText).viewRect.top += TEXT_MARGIN;   (**myText).viewRect.right = (**myText).viewRect.right - (SCROLL_BAR_WIDTH - 1);   (**myText).viewRect.bottom = (**myText).viewRect.bottom - (SCROLL_BAR_WIDTH - 1);   (**myText).viewRect.bottom =      (((**myText).viewRect.bottom - (**myText).viewRect.top) /        (**myText).lineHeight) * (**myText).lineHeight + TEXT_MARGIN;   /*=======================================================*/   /* Wrap text to same rectangle and inset by text margin. */   /*=======================================================*/   (**myText).destRect = (**myText).viewRect;   (**myText).destRect.left += TEXT_MARGIN;   /*==========================*/   /* Recalibrate line starts. */   /*==========================*/   TECalText(myText);   /*==================================*/   /* Adjust scroll bar to new length. */   /*==================================*/   AdjustScrollBar(whichWindow);   /*====================================================*/   /* Determine which line contains the first character. */   /*====================================================*/   theLine = 0;   while ((**myText).lineStarts[theLine+1] <= firstChar)     { theLine = theLine + 1; }   /*=======================================*/   /* Set scroll bar value to the top line. */   /*=======================================*/   SetCtlValue(myVScrollBar,theLine);   /*===================================*/   /* Compute the old and new top line. */   /*===================================*/   oldVScroll = (**myText).viewRect.top - (**myText).destRect.top;   newVScroll = GetCtlValue(myVScrollBar) * (**myText).lineHeight;   oldHScroll = (**myText).viewRect.left - (**myText).destRect.left                + TEXT_MARGIN;   newHScroll = GetCtlValue(myHScrollBar) * HORIZONTAL_SCROLL_INCREMENT;   /*=====================================================*/   /* Offset the text destination rectangle by the amount */   /* necessary to bring the new top line to the top of   */   /* the window. In effect, scroll destination rectangle */   /* of the text in relation to the view rectangle.      */   /*=====================================================*/   OffsetRect(&(**myText).destRect, (oldHScroll - newHScroll),              (oldVScroll - newVScroll));   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock( (Handle) myText);  }/*****************************************************//* WindowDirty: Mark window as being dirty or clean. *//*****************************************************/void WindowDirty(  WindowPtr theWindow,  int isDirty)  {   EWDHandle theData;   Handle dataHandle;      /*======================================*/   /* Update the marks in the window menu. */   /*======================================*/      UpdateWindowMenuDirty(theWindow,isDirty);   /*===================================*/   /* Get the window data, lock it, and */   /* convert it to a typed handle.     */   /*===================================*/   dataHandle = (Handle) GetWRefCon(theWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*=========================================================*/   /* Set the dirty flag in the data record to the new value. */   /*=========================================================*/   (**theData).dirty = isDirty;   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);  }/********************************************************//* FixEditCursor: Changes the cursor to its appropriate *//*   icon when the cursor is in the edit window.        *//********************************************************/void FixEditCursor(myWindow)  WindowPtr myWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   Point mousePoint;   Rect textRect;   RgnHandle theRegion;   GrafPtr savePort;   /*============================================*/   /* Save the previous port and make the window */   /* to be updated the current port.            */   /*============================================*/   GetPort(&savePort);   SetPort(myWindow);      /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(myWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   /*=========================================================*/   /* Get the mouse position and the window's text rectangle. */   /*=========================================================*/   GetMouse(&mousePoint);   textRect = (**myText).viewRect;   /*=======================================================*/   /* If the mouse is within the text rectangle, then use   */   /* the I-beam cursor (unless the cursor is over selected */   /* text). Otherwise use the arrow cursor.                */   /*=======================================================*/          if (PtInRect(mousePoint,&textRect))     {       theRegion = NewRgn();            TEGetHiliteRgn(theRegion,myText);             if (PtInRgn(mousePoint,theRegion))        { SetCursor(&ARROW); }      else        { SetCursor(*IBeamCursor); }      DisposeRgn(theRegion);     }   else      { SetCursor(&ARROW); }   /*===============================================*/   /* Blink the cursor if an edit record is active. */   /* Move from main loop. There may be a better    */   /* place to put this call.                       */   /*===============================================*/   TEIdle(myText);      /*============================*/   /* Restore the original port. */   /*============================*/   SetPort(savePort);  }/**************************************************//* WordBreak: Replacement word break routine that *//*   makes the selection that occurs when double  *//*   clicking text to be more compatible with the *//*   definition of the symbol data type.          *//**************************************************/pascal Boolean WordBreak(  Ptr text,  short int charPos)  {   char theChar;   theChar = text[charPos];   if ((theChar <= ' ') || (theChar == ')') || (theChar == '(') ||       (theChar == '&') || (theChar == '|') || (theChar == '~') ||       (theChar == '"') || (theChar == ';'))     { return((char) TRUE); }   return((char) false);  }/*************************************************************//* GrowEditWindow: Handle update after click in grow region. *//*************************************************************/void GrowEditWindow(myWindow)  WindowPtr myWindow;  {   EWDHandle theData;   Handle dataHandle;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   short constructAreaWidth;   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(myWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*======================*/   /* Perform grow update. */   /*======================*/   constructAreaWidth = ((*ConstructsAreaBWPic)->picFrame.right -                         (*ConstructsAreaBWPic)->picFrame.left) - 1;   FixScrollBar(myVScrollBar,myHScrollBar,myWindow,constructAreaWidth,0,0,0);   FixText(myWindow);  }/****************************************************//* DoEditActivate: Handle activate for edit window. *//****************************************************/void DoEditActivate(myWindow)  WindowPtr myWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*====================================*/   /* Highlight or unhighlight size box. */   /*====================================*/   DrawGrowIcon(myWindow);   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(myWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*===========================*/   /* Activate the scroll bars. */   /*===========================*/   if (myVScrollBar != NULL) HiliteControl(myVScrollBar,ACTIVE_VALUE);   if (myHScrollBar != NULL) HiliteControl(myHScrollBar,ACTIVE_VALUE);   /*========================================*/   /* Highlight the edit record's selection. */   /*========================================*/   TEActivate(myText);  }/**************************************************************//* DoEditDeactivate: Handle deactivate event for edit window. *//**************************************************************/void DoEditDeactivate(myWindow)  WindowPtr myWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   ControlHandle myVScrollBar;   ControlHandle myHScrollBar;   /*====================================*/   /* Highlight or unhighlight size box. */   /*====================================*/   DrawGrowIcon(myWindow);   /*=================================*/   /* Get the window data and convert */   /* the data to a typed handle.     */   /*=================================*/   dataHandle = (Handle) GetWRefCon(myWindow);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   myVScrollBar = (**theData).windowInfo.vScrollBar;   myHScrollBar = (**theData).windowInfo.hScrollBar;   /*===========================================*/   /* Unhighlight the edit record's selection.  */   /*===========================================*/   TEDeactivate(myText);   /*=============================*/   /* Deactivate the scroll bars. */   /*=============================*/   if (myVScrollBar != NULL) HiliteControl(myVScrollBar,INACTIVE_VALUE);   if (myHScrollBar != NULL) HiliteControl(myHScrollBar,INACTIVE_VALUE);  }/*******************************************************//* UpdateEditWindow: Handles updates for edit windows. *//*******************************************************/void UpdateEditWindow(whichWindow)  WindowPtr whichWindow;  {   GrafPtr savePort;   Handle dataHandle;   EWDHandle theData;   /*============================================*/   /* Save the previous port and make the window */   /* to be updated the current port.            */   /*============================================*/   GetPort(&savePort);   SetPort(whichWindow);   /*===========================================*/   /* Restrict visible region to update region. */   /*===========================================*/   BeginUpdate(whichWindow);   /*==========================*/   /* Clear the update region. */   /*==========================*/   EraseRect(&(*whichWindow).portRect);   /*========================================*/   /* Redraw the size box and the grow bars. */   /*========================================*/   DrawGrowIcon(whichWindow);   DrawControls(whichWindow);      /*===============================*/   /* Draw the construct menu area. */   /*===============================*/   DrawConstructsMenuArea(whichWindow,false);   /*=================================================*/   /* Get the window data, lock the data record, then */   /* convert the data record to a type handle.       */   /*=================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*==================*/   /* Redraw the text. */   /*==================*/   TEUpdate( &(**(**theData).editRec).viewRect,(**theData).editRec);   /*=========================*/   /* Unlock the data record. */   /*=========================*/   HUnlock(dataHandle);   /*==================================*/   /* Restore original visible region. */   /*==================================*/   EndUpdate(whichWindow);   /*============================*/   /* Restore the original port. */   /*============================*/   SetPort(savePort);  }/**************************************************************//* EditPrintRoutine: Handle print command for an edit window. *//**************************************************************/void EditPrintRoutine(hPrint,whichWindow)  THPrint hPrint;  WindowPtr whichWindow;  {   register int line = 0;   register int lastLineOnPage = 0;   int length;   Rect printRect;   int linesPerPage;   int lineBase;   int lineHeight;   register char *ptr, *p1;   FontInfo info;   TPPrPort printPort;   EWDHandle theData;   Handle dataHandle;   char **hText;   long count;   /*=================================================*/   /* Get TextEdit information related to the window. */   /*=================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   hText = (**((**theData).editRec)).hText;   count = (long) (**((**theData).editRec)).teLength;   /*====================================*/   /* Initialize a printing grafPort for */   /* use in printing a document.        */   /*====================================*/   printPort = PrOpenDoc( hPrint, 0L, 0L );   /*==============================================================*/   /* Make the current port the printing port. Note that PrOpenDoc */   /* should have already made printPort the current port.         */   /*==============================================================*/   SetPort((GrafPtr) printPort);   /*===============================================================*/   /* Set the appropriate font type and size for the printing port. */   /*===============================================================*/   TextFont((*((GrafPtr) whichWindow)).txFont);   TextSize((*((GrafPtr) whichWindow)).txSize);   /*===============================================*/   /* Determine the line height and number of lines */   /* per page for the printing port.               */   /*===============================================*/   printRect = (**hPrint).prInfo.rPage;   GetFontInfo( &info );   lineHeight = info.leading + info.ascent + info.descent;   linesPerPage =        (printRect.bottom - printRect.top - TOP_MARGIN - BOTTOM_MARGIN) / lineHeight;   /*=======================================*/   /* Lock the document text handle and get */   /* a pointer to the document text.       */   /*=======================================*/   HLock(hText);   ptr = p1 = (*hText);   /*=======================================*/   /* Print the document page by page until */   /* the end of document is reached.       */   /*=======================================*/   while (ptr < (*hText) + count)     {      /*==================================================*/      /* Inform the Printing Manager to begin a new page. */      /*==================================================*/      PrOpenPage( printPort, 0L );      /*============================================*/      /* Compute the last line on the current page. */      /*============================================*/      lastLineOnPage += linesPerPage;      /*=================================================*/      /* Position the pen in the upper left of the page. */      /*=================================================*/      lineBase = printRect.top + lineHeight;      MoveTo(printRect.left + LEFT_MARGIN,lineBase);      /*=========================================================*/      /* Print the current page line by line until the last line */      /* on the page or the end of the document is reached.      */      /*=========================================================*/      while ((line < lastLineOnPage) && (ptr < (*hText) + count))        {         /*===========================================*/         /* Find the next line break in the document. */         /*===========================================*/         while ((ptr <= (*hText)+count) && (*ptr++ != (char) MAC_CR))           { /* Do Nothing */ }         /*==================================================*/         /* Print the line. Note that tab characters have no */         /* special meaning to DrawText.                     */         /*==================================================*/         length = (int) (ptr - p1) - 1;         if (length > 0) DrawText(p1,0,length);         /*====================================*/         /* Position the pen at the next line. */         /*====================================*/         lineBase += lineHeight;         MoveTo(printRect.left + LEFT_MARGIN,lineBase);         /*======================================*/         /* Update text pointers and line count. */         /*======================================*/         p1 = ptr;         line++;        }      /*==================================*/      /* Inform the Printing Manager that */      /* the current page is finished.    */      /*==================================*/      PrClosePage( printPort );     }   /*================================*/   /* Lock the document text handle. */   /*================================*/   HUnlock(hText);   /*==============================*/   /* Close the printing grafPort. */   /*==============================*/   PrCloseDoc( printPort );  }/******************************************************************//* EditMenuUpdateRoutine: Handles menu update for an edit window. *//******************************************************************/void EditMenuUpdateRoutine(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) myText);   /*================================*/   /* Enable menu items that operate */   /* on a nonempty selection.       */   /*================================*/   if ( (**myText).selStart != (**myText).selEnd )     {      EnableStandardMenuItem(STANDARD_MENU_ITEM_CUT);      EnableStandardMenuItem(STANDARD_MENU_ITEM_COPY);      EnableStandardMenuItem(STANDARD_MENU_ITEM_CLEAR);     }   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock((Handle) myText);   /*===============================================*/   /* If the scrap is empty, then disable the Paste */   /* command, otherwise enable the Paste command.  */   /*===============================================*/   if (TEGetScrapLen() != 0)     { EnableStandardMenuItem(STANDARD_MENU_ITEM_PASTE); }   /*========================================================*/   /* Enable File Menu Save and Revert items if appropriate. */   /*========================================================*/   if ((**theData).dirty)     {      EnableStandardMenuItem(STANDARD_MENU_ITEM_SAVE);      if ((*theData)->associatedWithFile)        { EnableStandardMenuItem(STANDARD_MENU_ITEM_REVERT); }     }   /*=======================================*/   /* Enable/disable various menu commands. */   /*=======================================*/   EnableStandardMenuItem(STANDARD_MENU_ITEM_CLOSE);   EnableStandardMenuItem(STANDARD_MENU_ITEM_SAVE_AS);   EnableStandardMenuItem(STANDARD_MENU_ITEM_PRINT);   /*============================*/   /* Call the application hook. */   /*============================*/   if ((**theData).windowInfo.applicationHook != NULL)     { (*(**theData).windowInfo.applicationHook)(whichWindow,NULL,NULL,' ',MENU_UPDATE_MESSAGE); }  }/****************************************//* DoSelectAllEditWindow: Handle Select *//*   All command an edit window.        *//****************************************/void DoSelectAllEditWindow(  WindowPtr whichWindow)  {     EWDHandle theData;   Handle dataHandle;   TEHandle myText;      dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;      TESetSelect(0,(**myText).teLength,myText);   ResetShiftSelectionAnchor(whichWindow);  }/*****************************************************************//* EditApplicationHook:                                     *//*****************************************************************/int EditApplicationHook(WindowPtr whichWindow,EventRecord *thisEvent,                             THPrint printRecord,char thisChar,int whichMessage)  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;#if MAC_MPW || MAC_MCW#pragma unused(thisEvent,printRecord)#endif   /*==========================================*/   /* Get the window data and lock it. Convert */   /* the data to a typed handle.              */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   HLock(dataHandle);   theData = (EWDHandle) dataHandle;   /*====================================*/   /* Retrieve pointers to window's text */   /* record and scroll bars.            */   /*====================================*/   myText = (**theData).editRec;   /*=====================*/   /* Handle the message. */   /*=====================*/   switch(whichMessage)     {      case KEYSTROKE_MESSAGE:        ProcessUndoCharacter(thisChar,myText,whichWindow);        break;      case MENU_UPDATE_MESSAGE:#if ! RUN_TIME        if (EvaluatingTopLevelCommand || BatchActive())#else        if (BatchActive())#endif          {           DisableStandardMenuItem(STANDARD_MENU_ITEM_CUT);           DisableStandardMenuItem(STANDARD_MENU_ITEM_COPY);           DisableStandardMenuItem(STANDARD_MENU_ITEM_PASTE);           DisableStandardMenuItem(STANDARD_MENU_ITEM_CLEAR);          }        else          {           FixUndoMenuItem(whichWindow);           HLock((Handle) myText);           if ( (**myText).selStart != (**myText).selEnd )             {              EnableItem(BufferMenu,LoadSelectionItem);              EnableItem(BufferMenu,BatchSelectionItem);              EnableItem(BufferMenu,EnterFindStringItem);              EnableItem(BufferMenu,FindSelectionItem);             }           HUnlock((Handle) myText);           EnableItem(EditMenu,CompleteItem);           EnableItem(EditMenu,BalanceItem);           EnableItem(EditMenu,SetFontItem);           EnableItem(EditMenu,CommentItem);           EnableItem(EditMenu,UncommentItem);                                 FixSearchMenu();           EnableItem(BufferMenu,LoadBufferItem);           EnableItem(EditMenu,SelectAllItem);          }        break;     }  return(1); }  /*************************************************//* DeterminePositionStartLine: Given a position  *//*   in a text edit buffer, returns the starting *//*   line number of the position.                *//*************************************************/int DeterminePositionStartLine(thePosition,theText)  int thePosition;  TEHandle theText;  {   int theLine;   char lastChar;   char *textPtr;   if ((**theText).nLines == 0)     { return(0); }   for (theLine = 0; theLine < (**theText).nLines; theLine++)     {      if (thePosition < (**theText).lineStarts[theLine+1])        { return(theLine); }     }         if ((thePosition > 0) &&       ((**theText).selStart == (**theText).selEnd))     {        HLock((**theText).hText);      textPtr = *(**theText).hText;      lastChar = textPtr[thePosition-1];      HUnlock((**theText).hText);      if ((lastChar == '\r') || (lastChar == '\n'))        { return(theLine); }     }           return(theLine - 1);  }   /***********************************************//* DeterminePositionEndLine: Given a position  *//*   in a text edit buffer, returns the ending *//*   line number of the position.              *//***********************************************/int DeterminePositionEndLine(thePosition,theText)  int thePosition;  TEHandle theText;  {   int theLine;   if ((**theText).nLines == 0)     { return(0); }   for (theLine = 0; theLine < (**theText).nLines; theLine++)     {      if (thePosition <= (**theText).lineStarts[theLine+1])        { return(theLine); }     }         return(theLine);  } /***************************************************************//* ResetShiftSelectionAnchor: Updates the edit window variable *//*   which indicates the location of the selection starting    *//*   point when the user is selecting text by using the arrow  *//*   keys in conjunction with the shift key.                   *//***************************************************************/void ResetShiftSelectionAnchor(  WindowPtr whichWindow)  {      TEHandle theText;   EWDHandle theData;   Handle dataHandle;   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;      (**theData).shiftSelectionAnchor = -1;  } /********************************************//* DoArrowKey: Processes an arrow keystroke *//*   in an editing buffer.                  *//********************************************/static void DoArrowKey(  int theKey,  int shiftDown,  WindowPtr whichWindow)  {   int start, end;   int startLine, endLine;   int currentOffset;   TEHandle theText;   EWDHandle theData;   Handle dataHandle;   long shiftSelectionAnchor;   int anchorLine;   Handle textHandle;   char *textPtr;   int currentWidth, newWidth, widthChars, endChar;   int theLine, newLine;   /*=======================================================*/   /* Retrieve pointers to the buffer text and information. */   /*=======================================================*/      dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   shiftSelectionAnchor = (**theData).shiftSelectionAnchor;   textHandle = (**theText).hText;   textPtr = *textHandle;      /*====================================*/   /* Determine the start and end of the */   /* current selection in the buffer.   */   /*====================================*/      start = (**theText).selStart;   end = (**theText).selEnd;         startLine = DeterminePositionStartLine(start,theText);   if (shiftDown)     { endLine = DeterminePositionEndLine(end,theText); }   else     { endLine = DeterminePositionStartLine(end,theText); }         /*=========================================================*/   /* According to the human interface guidelines, using just */   /* the left or right arrow keys when there's an active     */   /* selection moves the insertion point respectively to     */   /* either the beginning or end of the current. selection   */   /*=========================================================*/      if ((start != end) && (! shiftDown))     {      if (theKey == LEFT_ARROW_KEY)        {          (**theData).shiftSelectionAnchor = -1;         TESetSelect(start,start,theText);          return;        }      else if (theKey == RIGHT_ARROW_KEY)        {          (**theData).shiftSelectionAnchor = -1;         TESetSelect(end,end,theText);          return;        }     }        /*========================================================*/   /* If a shift extension of the selected text is starting, */   /* remember the anchor point for selection.               */   /*========================================================*/    if (shiftDown && (shiftSelectionAnchor < 0))     {      if ((theKey == RIGHT_ARROW_KEY) ||          (theKey == DOWN_ARROW_KEY))        {         shiftSelectionAnchor = start;         anchorLine = startLine;        }      else /* Left or Up Arrow Key */        {         shiftSelectionAnchor = end;         anchorLine = endLine;        }      (**theData).shiftSelectionAnchor = shiftSelectionAnchor;     }   else if (shiftSelectionAnchor == start)     { anchorLine = startLine; }   else     { anchorLine = endLine; }   /*=========================================================*/   /* The up and down arrow keys do nothing if an appropriate */   /* part of the selection is either at the top or the       */   /* bottom of the editing buffer and moving the cursor in   */   /* the direction of the arrow key would move it beyond the */   /* top/bottom boundary.                                    */   /*=========================================================*/   /*   if ((startLine == 0) &&        ((! shiftDown) || (startLine == endLine)) &&        (theKey == UP_ARROW_KEY))     { return; }        if (((endLine + 1) >= (**theText).nLines) &&        ((! shiftDown) || (startLine == endLine)) &&        (theKey == DOWN_ARROW_KEY))     { return; }   */     if (shiftDown && (startLine != endLine))     {      if (startLine == anchorLine)        {         if ((endLine == 0) && (theKey == UP_ARROW_KEY))           { return; }                    if (((endLine + 1) >= (**theText).nLines) &&             (theKey == DOWN_ARROW_KEY))           { return; }        }      else        {         if ((startLine == 0) && (theKey == UP_ARROW_KEY))           { return; }        }     }       /*===========================================================*/   /* If the shift key isn't down (hence the selection isn't    */   /* being extended), allow TextEdit to handle the key stroke. */   /*===========================================================*/      if (! shiftDown)     {      HandleNonShiftedArrowKey(theKey,theText,theData,whichWindow,startLine);    /*        if (theKey != DOWN_ARROW_KEY)        { TEKey(theKey,theText); }      else        {         theLine = endLine;         currentOffset = end - (**theText).lineStarts[theLine];         newLine = theLine + 1;                  currentWidth = TextWidth(textPtr,(**theText).lineStarts[theLine],currentOffset);               widthChars = (**theText).lineStarts[newLine];         endChar = (**theText).lineStarts[newLine+1];         newWidth = 0;               while ((widthChars < endChar) && (newWidth < currentWidth))           {            newWidth += CharWidth(textPtr[widthChars]);            widthChars++;           }         if ((newWidth < currentWidth) &&              (widthChars > 0) &&             (widthChars < (**theText).teLength))           { TESetSelect(widthChars-1,widthChars-1,theText); }         else           { TESetSelect(widthChars,widthChars,theText); }        }              ResetShiftSelectionAnchor(whichWindow);       */      return;     }        /*=====================================================*/   /* Determine the new values for start and end of the   */   /* selection in response to a shift arrow key command. */   /*=====================================================*/      if (theKey == LEFT_ARROW_KEY)     {       if (start == shiftSelectionAnchor)        { end--; }      else        { start--; }     }   else if (theKey == RIGHT_ARROW_KEY)     {           if (start == shiftSelectionAnchor)        { end++; }      else        { start++; }     }   else if ((theKey == DOWN_ARROW_KEY) ||            (theKey == UP_ARROW_KEY))     {       if (start == shiftSelectionAnchor)        {         theLine = endLine;         currentOffset = end - (**theText).lineStarts[theLine];        }      else        {         theLine = startLine;         currentOffset = start - (**theText).lineStarts[theLine];        }              if (theKey == DOWN_ARROW_KEY)        { newLine = theLine + 1; }      else        { newLine = theLine - 1; }            currentWidth = TextWidth(textPtr,(**theText).lineStarts[theLine],currentOffset);            widthChars = (**theText).lineStarts[newLine];      endChar = (**theText).lineStarts[newLine+1];      newWidth = 0;            while ((widthChars < endChar) && (newWidth < currentWidth))        {         newWidth += CharWidth(textPtr[widthChars]);         widthChars++;        }              if (start == shiftSelectionAnchor)        { end = widthChars; }      else        { start = widthChars; }     }   else     {      Bogus(TRUE);      return;     }       /*====================================================*/   /* Highlight the new selection in the editing buffer. */   /*====================================================*/             if (start < 0) start = 0;   else if (start > (**theText).teLength)     { start = (**theText).teLength; }      if (end < 0) end = 0;   else if (end > (**theText).teLength)     { end = (**theText).teLength; }      if (start <= end)     { TESetSelect(start,end,theText); }   else     { TESetSelect(end,start,theText); }  }/*****************************************************************//* FindBalancingParenthesis                                      *//*****************************************************************/static Boolean FindBalancingParenthesis(  char *textPtr,  long theCharIndex,  long *whichChar)  {   int theChar, depth = 1;   while (theCharIndex >= 0)     {      theChar = textPtr[theCharIndex];      if (theChar == ')')        { depth++; }      else if (theChar == '(')        { depth--; }                 if (depth == 0)        {         *whichChar = theCharIndex;         return(TRUE);        }                 theCharIndex--;     }   return(FALSE);  }/*****************************************************************//* HandleNonShiftedArrowKey: *//*****************************************************************/static void HandleNonShiftedArrowKey(  int theKey,  TEHandle theText,  EWDHandle theData,  WindowPtr whichWindow,  int startLine)  {   int currentOffset;   int currentWidth;   /* int theLine; */   int newLine;   int newWidth;   /* int widthChars, endChar; */   int currentLine;   int position;         int lineCount;   Handle textHandle;   char *textPtr;      /*   int start;   int startLine;   int currentOffset;   TEHandle theText;   EWDHandle theData;   Handle dataHandle;   long shiftSelectionAnchor;   int anchorLine;   Handle textHandle;   int newLine;   */   /*=========================================================*/   /* According to the human interface guidelines, using just */   /* the left or right arrow keys when there's an active     */   /* selection moves the insertion point respectively to     */   /* either the beginning or end of the current selection.   */   /* If the up or down arrow key is pressed when there's an  */   /* active selection, move the cursor respectively to       */   /* the beginning or end of the selection and then allow    */   /* TextEdit to process the arrow key.                      */   /*=========================================================*/      if ((**theText).selStart != (**theText).selEnd)     {      switch (theKey)        {          case LEFT_ARROW_KEY:           (**theData).shiftSelectionAnchor = -1;           TESetSelect((**theText).selStart,(**theText).selStart,theText);            return;                    case RIGHT_ARROW_KEY:           (**theData).shiftSelectionAnchor = -1;           TESetSelect((**theText).selEnd,(**theText).selEnd,theText);            return;                    case UP_ARROW_KEY:           (**theData).shiftSelectionAnchor = -1;           TESetSelect((**theText).selStart,(**theText).selStart,theText);            TEKey(theKey,theText);           return;                    case DOWN_ARROW_KEY:           (**theData).shiftSelectionAnchor = -1;           TESetSelect((**theText).selEnd,(**theText).selEnd,theText);            TEKey(theKey,theText);           return;                    default:           Bogus(TRUE);           return;        }     }      /*============================*/   /* Handle the left arrow key. */   /*============================*/   if (theKey == LEFT_ARROW_KEY)     {      if ((**theText).selStart == 0) return;            position = (**theText).selStart;            if ((position - 1) == (**theText).lineStarts[startLine])        {          (**theText).clikStuff = 255;         TESetSelect(position - 1,position - 1,theText);          return;        }      else         {          TESetSelect(position - 1,position - 1,theText);         return;        }     }        TEKey(theKey,theText);   return;   /*===========================*/   /* Get pointers to the text. */   /*===========================*/      textHandle = (**theText).hText;   textPtr = *textHandle;      /*=================================================*/   /* Let TextEdit process left and right arrow keys. */   /*=================================================*/      if ((theKey == LEFT_ARROW_KEY) ||       (theKey == RIGHT_ARROW_KEY))     {      TEKey(theKey,theText);      return;     }      /*======================================================*/   /* If the up arrow key was pressed, use the selection   */   /* start as the starting position for cursor movement.  */   /* If the down arrow key was pressed, use the selection */   /* end as the starting position for cursor movement.    */   /*======================================================*/      if (theKey == UP_ARROW_KEY)     { position = (**theText).selStart; }   else     { position = (**theText).selEnd; }       /*====================================================*/   /* Because of the screwiness with a carriage return   */   /* as the last character in a TextEdit buffer,        */   /* determine the actual number of lines in the buffer */   /*====================================================*/      lineCount = (**theText).nLines;   if (textPtr[(**theText).teLength - 1] == '\r')     { lineCount++; }   /*================================================*/   /* Determine the line where the caret is located. */   /*================================================*/      for (currentLine = 0; currentLine < (lineCount - 1); currentLine++)     {       if (position < (**theText).lineStarts[currentLine + 1])        { break; }     }      /*===============================================*/   /* If we're on the top line and the up arrow key */   /* is pressed, then the cursor moves to the top  */   /* left corner of the editing buffer.            */   /*===============================================*/   if ((currentLine == 0) && (theKey == UP_ARROW_KEY))     {       TESetSelect(0,0,theText);      ResetShiftSelectionAnchor(whichWindow);      return;      }        /*================================================*/   /* If we're on the bottom line and the down arrow */   /* key is pressed, then the cursor moves to the   */   /* bottom right corner of the editing buffer.     */   /*================================================*/   if (((currentLine + 1) == lineCount) && (theKey == DOWN_ARROW_KEY))     {       TESetSelect((**theText).teLength,(**theText).teLength,theText);      ResetShiftSelectionAnchor(whichWindow);      return;      }        /*===================================*/   /* Determine the width of characters */   /* on the current line.              */    /*===================================*/   currentOffset = position - (**theText).lineStarts[currentLine];   currentWidth = TextWidth(textPtr,                            (**theText).lineStarts[currentLine],                            currentOffset);      /*=======================================================*/   /* Determine the line to which the cursor will be moved. */   /*=======================================================*/      if (theKey == UP_ARROW_KEY)     { newLine = currentLine - 1; }   else     { newLine = currentLine + 1; }   /*=============================================*/   /* Determine the total width of the next line. */   /*=============================================*/      currentOffset = (**theText).lineStarts[newLine + 1] -                   (**theText).lineStarts[newLine];   newWidth = TextWidth(textPtr,                        (**theText).lineStarts[newLine],                        currentOffset);                           if (newWidth <= currentWidth)     {      TEKey(theKey,theText);      return;     }      TEKey(theKey,theText);   return;      /*   theLine = endLine;   newLine = theLine + 1;                return;            widthChars = (**theText).lineStarts[newLine];   endChar = (**theText).lineStarts[newLine+1];   newWidth = 0;               while ((widthChars < endChar) && (newWidth < currentWidth))           {            newWidth += CharWidth(textPtr[widthChars]);            widthChars++;           }         if ((newWidth < currentWidth) &&              (widthChars > 0) &&             (widthChars < (**theText).teLength))           { TESetSelect(widthChars-1,widthChars-1,theText); }         else           { TESetSelect(widthChars,widthChars,theText); }            ResetShiftSelectionAnchor(whichWindow); */      return;  }/*****************************************************//* DrawConstructsMenuArea: Draws the Constructs menu *//*   popup area in the lower left of the window.     *//*****************************************************/void DrawConstructsMenuArea(  WindowPtr whichWindow,  Boolean hilited)  {      Rect theRect;   short theHeight, theWidth;   PicHandle thePic;   if (WindowDepth(whichWindow) < 8)     {       if (hilited) thePic = ConstructsAreaBWHilitePic;      else thePic = ConstructsAreaBWPic;      }   else     {       if (hilited) thePic = ConstructsAreaColorHilitePic;      else thePic = ConstructsAreaColorPic;      }   theRect = (*thePic)->picFrame;   theHeight = (*thePic)->picFrame.bottom -               (*thePic)->picFrame.top;   theWidth = (*thePic)->picFrame.right -               (*thePic)->picFrame.left;   OffsetRect(&theRect,-1,(*whichWindow).portRect.bottom - (theHeight - 1));   DrawPicture(thePic,&theRect);  } /************************************************//* ClickInConstructsAreaRect: Returns TRUE if a *//*   mouse click occurred in the construct list *//*   menu popup area in an editing window.      *//************************************************/   Boolean ClickInConstructsAreaRect(  WindowPtr whichWindow,  Point thePoint)  {   Rect theRect;   PicHandle thePic;      short theHeight, theWidth;   /*===============================*/   /* Determine the location of the */   /* constructs area rectangle.    */   /*===============================*/      thePic = ConstructsAreaColorPic;    theRect = (*thePic)->picFrame;   theHeight = (*thePic)->picFrame.bottom -               (*thePic)->picFrame.top;   theWidth = (*thePic)->picFrame.right -               (*thePic)->picFrame.left;   OffsetRect(&theRect,-1,(*whichWindow).portRect.bottom - (theHeight - 1));   /*====================================*/   /* Is the point within the rectangle? */   /*====================================*/      if (PtInRect(thePoint,&theRect))     { return(true); }        return(false);  } /************************************************//* GetConstructsAreaRect: Returns the rectangle *//*   containing the construct list popup menu.  *//************************************************/   void GetConstructsAreaRect(  WindowPtr whichWindow,  Rect *theRect,  Boolean globalCoordinates)  {   PicHandle thePic;   short theHeight, theWidth;   Point globalPoint;      thePic = ConstructsAreaColorPic;    *theRect = (*thePic)->picFrame;   theHeight = (*thePic)->picFrame.bottom -               (*thePic)->picFrame.top;   theWidth = (*thePic)->picFrame.right -               (*thePic)->picFrame.left;   OffsetRect(theRect,-1,(*whichWindow).portRect.bottom - (theHeight - 1));      if (! globalCoordinates) return;      globalPoint.v = theRect->top;   globalPoint.h = theRect->left;      LocalToGlobal(&globalPoint);      theRect->top = globalPoint.v;   theRect->left = globalPoint.h;   globalPoint.v = theRect->bottom;   globalPoint.h = theRect->right;      LocalToGlobal(&globalPoint);      theRect->bottom = globalPoint.v;   theRect->right = globalPoint.h;     } 