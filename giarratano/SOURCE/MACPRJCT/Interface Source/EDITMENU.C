   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*            Macintosh Version 3.2  05/12/93          */   /*                                                     */   /*                  EDIT MENU MODULE                   */   /*******************************************************//*************************************************************//* Purpose:                                                  *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#define _EDITMENU_SOURCE_#include "setup.h"#include "stnrdmac.h"#include <stddef.h>#include <OSUtils.h>#include <Memory.h>#include <TextEdit.h>#include <Devices.h>/* #include <Desk.h> */#include <Menus.h>#include <Scrap.h>#include <Dialogs.h>#if MAC_MCW || MAC_SC7 || MAC_MPW || MAC_SC8#include <Printing.h>#else#include <PrintTraps.h>#endif#include <Events.h>#include <Controls.h>#if MAC_MCW || MAC_SC8#define ModalPtr ModalFilterUPP#else#define ModalPtr ModalFilterProcPtr#endif#include "interface.h"#include "macinit.h"#include "undo.h"#include "fontpick.h"#include "displayw.h"#include "dsplscrl.h"#include "search.h"#include "window.h"#include "clpscrap.h"#include "mainloop.h"#include "editw.h"#include "editscrl.h"#include "menucmds.h"#include "editdlog.h"#include "editmenu.h"/***************//* DEFINITIONS *//***************/#define UNDO_CMD  0#define CUT_CMD   2#define COPY_CMD  3#define PASTE_CMD 4#define CLEAR_CMD 5/***************************************//* LOCAL INTERNAL FUNCTION DEFINITIONS *//***************************************/   static void                   DoCut(WindowPtr);   static void                   DoCopy(WindowPtr);   static void                   DoPaste(WindowPtr);   static void                   DoClear(WindowPtr);   static void                   DoBalance(WindowPtr);   static void                   BalanceIt(int,int,int,int,char *,int,TEHandle,WindowPtr);   static void                   FixOptionNumber(DialogPtr,int,int);   static void                   SetFontAttributes(short,short,WindowPtr);   static void                   DoComment(WindowPtr);   static void                   DoUncomment(WindowPtr);/************************************************//* DoEditChoice:  Handle choice from edit menu. *//************************************************/void DoEditChoice(theItem,whichWindow)  int theItem;  WindowPtr whichWindow;  {   short int newFont, newSize;   switch(theItem)     {      /*======================*/      /* Handle Undo command. */      /*======================*/      case UndoItem:        if (! SystemEdit(UNDO_CMD)) DoUndo(whichWindow);        break;      /*=====================*/      /* Handle Cut command. */      /*=====================*/      case CutItem:        if (! SystemEdit(CUT_CMD)) DoCut(whichWindow);        break;      /*======================*/      /* Handle Copy command. */      /*======================*/      case CopyItem:        if (! SystemEdit(COPY_CMD))          {           if (whichWindow == DisplayWindow) DisplayCopy();           else DoCopy(whichWindow);          }        break;      /*=======================*/      /* Handle Paste command. */      /*=======================*/      case PasteItem:        if (! SystemEdit(PASTE_CMD))          {           if (whichWindow == DisplayWindow) DisplayPaste();           else DoPaste(whichWindow);          }        break;      /*=======================*/      /* Handle Clear command. */      /*=======================*/      case ClearItem:        if (! SystemEdit(CLEAR_CMD)) DoClear(whichWindow);        break;              /*============================*/      /* Handle Select All command. */      /*============================*/      case SelectAllItem:        if (whichWindow == DisplayWindow)           { DisplaySelectAll(whichWindow); }        else if (WindowType(whichWindow) == EDIT_WINDOW)          { DoSelectAllEditWindow(whichWindow); }        break;      /*=========================*/      /* Handle Balance command. */      /*=========================*/      case BalanceItem:        DoBalance(whichWindow);        break;      /*=============================*/      /* Handle Complete... command. */      /*=============================*/      case CompleteItem:        DoCommandCompletion(whichWindow);        break;      /*=========================*/      /* Handle Comment command. */      /*=========================*/      case CommentItem:        DoComment(whichWindow);        break;              /*===========================*/      /* Handle Uncomment command. */      /*===========================*/      case UncommentItem:        DoUncomment(whichWindow);        break;      /*=============================*/      /* Handle Set Font... command. */      /*=============================*/      case SetFontItem:        GetFontAttributes(&newFont,&newSize,whichWindow);        if (DoSetFont(&newFont,&newSize))          { SetFontAttributes(newFont,newSize,whichWindow); }        break;      /*==============================*/      /* Handle Clear Window command. */      /*==============================*/      case ClearWindowItem:        ClearDisplayWindow();        break;      /*============================*/      /* Handle Options... command. */      /*============================*/      case PreferencesItem:        DoPreferences();        break;     }  }/******************************//* DoCut: Handle Cut command. *//******************************/static void DoCut(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=====================================*/   /* Make sure the selection is visible. */   /*=====================================*/   ScrollToSelection(false,whichWindow);   /*====================================*/   /* Save information for undo command. */   /*====================================*/   SaveUndoInfo(whichWindow,myText,UNCUT,0,0,NULL);   /*====================*/   /* Cut the selection. */   /*====================*/   TECut(myText);   ResetShiftSelectionAnchor(whichWindow);   /*==================================================================*/   /* Adjust the scroll bar to the length of the text, adjust the text */   /* to match the scroll bar, and keep the insertion point visible.   */   /*==================================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(false,whichWindow);   /*=====================================*/   /* Mark the scrap and window as dirty. */   /*=====================================*/   SetScrapDirtyStatus(TRUE);   WindowDirty(whichWindow,TRUE);   /*=============================*/   /* Fix undo item in Edit menu. */   /*=============================*/   SetUndoItem(whichWindow,UNCUT);  }/*********************************//* DoCopy: Handles copy command. *//*********************************/static void DoCopy(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=====================================*/   /* Make sure the selection is visible. */   /*=====================================*/   ScrollToSelection(false,whichWindow);   /*=====================*/   /* Copy the selection. */   /*=====================*/   TECopy(myText);   /*==========================*/   /* Mark the scrap as dirty. */   /*==========================*/   SetScrapDirtyStatus(TRUE);  }/**********************************//* DoPaste: Handle Paste command. *//**********************************/static void DoPaste(whichWindow)  WindowPtr whichWindow;  {   long int size;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*================================================*/   /* Don't perform the paste if the new buffer size */   /* would exceed the maximum buffer size.          */   /*================================================*/   size = (**myText).teLength;   size += TEGetScrapLen();   if (size >= MAX_BUFFER_SIZE)     {      InitCursor();      ParamText("\pCan't Paste ",                "\p(only files 32K or smaller can be edited)","\p","\p");      StopAlert(StopCantDoID,(ModalPtr) DefaultDialogFilterRef);      return;     }   /*====================================*/   /* Save information for undo command. */   /*====================================*/   SaveUndoInfo(whichWindow,myText,UNPASTE,0,0,NULL);   /*=================================*/   /* Make sure selection is visible. */   /*=================================*/   ScrollToSelection(false,whichWindow);   /*==================*/   /* Paste the Scrap. */   /*==================*/   TEPaste(myText);   ResetShiftSelectionAnchor(whichWindow);   /*==================================================*/   /* Adjust scroll bar to length of text, adjust text */   /* to match scroll bar, and keep selection visible. */   /*==================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(false,whichWindow);   /*===========================*/   /* Mark the window as dirty. */   /*===========================*/   WindowDirty(whichWindow,TRUE);   /*=============================*/   /* Fix undo item in Edit menu. */   /*=============================*/   SetUndoItem(whichWindow,UNPASTE);  }/**********************************//* DoClear: Handle Clear command. *//**********************************/static void DoClear(whichWindow)  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=================================*/   /* Make sure selection is visible. */   /*=================================*/   ScrollToSelection(false,whichWindow);   /*====================================*/   /* Save information for undo command. */   /*====================================*/   SaveUndoInfo(whichWindow,myText,UNCLEAR,0,0,NULL);   /*=======================*/   /* Delete the selection. */   /*=======================*/   TEDelete(myText);   ResetShiftSelectionAnchor(whichWindow);   /*==================================================*/   /* Adjust scroll bar to length of text, adjust text */   /* to match scroll bar, and keep selection visible. */   /*==================================================*/   AdjustScrollBar(whichWindow);   EditAdjustText(whichWindow);   ScrollToSelection(false,whichWindow);   /*===========================*/   /* Mark the window as dirty. */   /*===========================*/   WindowDirty(whichWindow,TRUE);   /*=============================*/   /* Fix undo item in Edit menu. */   /*=============================*/   SetUndoItem(whichWindow,UNCLEAR);  }/**************************************//* DoBalance: Handle Balance command. *//**************************************/static void DoBalance(whichWindow)  WindowPtr whichWindow;  {   int leftMiddle, rightMiddle, text_length;   Handle textHandle;   char *text_ptr;   int leftCount, rightCount;   int count, i;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   /*====================================================*/   /* Check to make sure there is an active edit record. */   /* This check should be unnecessary.                  */   /*====================================================*/   if ((*theData)->windowInfo.windowType != EDIT_WINDOW) return;   /*=============================================================*/   /* Get information about the current selection to be balanced. */   /*=============================================================*/   myText = (**theData).editRec;   leftMiddle = (**myText).selStart;   rightMiddle = (**myText).selEnd;   text_length = (**myText).teLength;   textHandle = (**myText).hText;   text_ptr = *textHandle;   /*===================================*/   /* If the selection is empty then... */   /*===================================*/   if (leftMiddle == rightMiddle)     {      /*============================================*/      /* If '(' is to the right of the cursor, then */      /* all balancing should occur to the right.   */      /*============================================*/      if ((text_ptr[leftMiddle] == '(') && (leftMiddle < text_length))        { BalanceIt(leftMiddle-1,leftMiddle+1,1,0,text_ptr,text_length,myText,whichWindow); }      /*================================================*/      /* Else if ')' is to the left of the cursor, then */      /* all balancing should occur to the left.        */      /*================================================*/      else if ((leftMiddle > 0) ? (text_ptr[leftMiddle - 1] == ')') : 0)        { BalanceIt(leftMiddle-2,leftMiddle,0,-1,text_ptr,text_length,myText,whichWindow); }      /*====================================================*/      /* Else balancing occurs to left and right of cursor. */      /*====================================================*/      else        { BalanceIt(leftMiddle-1,rightMiddle,0,0,text_ptr,text_length,myText,whichWindow); }     }   /*===================================================*/   /* Otherwise the selection is non-empty therefore... */   /*===================================================*/   else     {      /*===============================================*/      /* Determine the number of right parentheses ')' */      /* that need to be balanced from the left side.  */      /*===============================================*/      count = 0;      leftCount = 0;      for (i = leftMiddle ; i < rightMiddle ; i++)        {         if (text_ptr[i] == '(') count++;         else if (text_ptr[i] == ')') count--;         if (count < leftCount) leftCount = count;        }      /*===============================================*/      /* Determine the number of left parentheses '('  */      /* that need to be balanced from the right side. */      /*===============================================*/      count = 0;      rightCount = 0;      for (i = rightMiddle - 1 ; i >= leftMiddle ; i--)        {         if (text_ptr[i] == '(') count++;         else if (text_ptr[i] == ')') count--;         if (count > rightCount) rightCount = count;        }      /*==============================================*/      /* Balance to the left and right of the cursor. */      /*==============================================*/      BalanceIt(leftMiddle-1,rightMiddle,leftCount,rightCount,                text_ptr,text_length,myText,whichWindow);     }      ResetShiftSelectionAnchor(whichWindow);  }/********************************************************//* BalanceIt: Balances a selection of text by extending *//* it to the left and right until the number of left    *//* and right parentheses is balanced.                   *//********************************************************/static void BalanceIt(leftMiddle,rightMiddle,leftCount,rightCount,                      text_ptr,text_length,myText,whichWindow)  int leftMiddle, rightMiddle;  int leftCount, rightCount;  char *text_ptr;  int text_length;  TEHandle myText;  WindowPtr whichWindow;  {   /*==========================================================*/   /* Balance the left side of the text by moving left and up. */   /*==========================================================*/   while (leftCount <= 0)     {      if (leftMiddle < 0)        {         SysBeep(10);         return;        }      if (text_ptr[leftMiddle] == '(') leftCount++;      else if (text_ptr[leftMiddle] == ')') leftCount--;      leftMiddle--;     }   /*==============================================================*/   /* Balance the right side of the text by moving right and down. */   /*==============================================================*/   while (rightCount >= 0)     {      if (rightMiddle > text_length)        {         SysBeep(10);         return;        }      if (text_ptr[rightMiddle] == '(') rightCount++;      else if (text_ptr[rightMiddle] == ')') rightCount--;      rightMiddle++;     }  /*=============================================*/  /* Set the current selection to balanced text. */  /*=============================================*/  TESetSelect((long int) leftMiddle + 1,(long int) rightMiddle,myText);  /*=====================================*/  /* Make sure the selection is visible. */  /*=====================================*/  ScrollToSelection(TRUE,whichWindow); }/*******************************************************************//* SetFontAttributes: Resets the font attributes of a text window. *//*******************************************************************/static void SetFontAttributes(short newFont,short newSize,WindowPtr whichWindow)  {   FontInfo finfo;   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) myText);   /*=============================================*/   /* Change the font attributes for the window.  */   /*=============================================*/   TextFont(newFont);   TextSize(newSize);   (**myText).txFont = newFont;   (**myText).txSize = newSize;   GetFontInfo(&finfo);   (**myText).lineHeight = finfo.ascent + finfo.descent + finfo.leading;   (**myText).fontAscent = finfo.ascent;   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock( (Handle) myText);   /*=====================*/   /* Redisplay the text. */   /*=====================*/   EraseRect(&(*whichWindow).portRect);   InvalRect(&(*whichWindow).portRect);   TECalText(myText);   FixText(whichWindow);  }/**********************************************************************//* GetFontAttributes: Retrieves the font attributes of a text window. *//**********************************************************************/void GetFontAttributes(theFont,theSize,whichWindow)  short int *theFont, *theSize;  WindowPtr whichWindow;  {   EWDHandle theData;   Handle dataHandle;   TEHandle myText;   /*=============================================================*/   /* Get the window data and convert the data to a typed handle. */   /* Get a pointer to the window's edit record.                  */   /*=============================================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   myText = (**theData).editRec;   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) myText);   /*=============================================*/   /* Change the font attributes for the window.  */   /*=============================================*/   *theFont = (**myText).txFont;   *theSize = (**myText).txSize;   /*=========================*/   /* Unlock the edit record. */   /*=========================*/   HUnlock( (Handle) myText);  }  /*********************************************//* DoComment: Handles the Comment menu item. *//*********************************************/static void DoComment(  WindowPtr whichWindow)  {   EWDHandle theData;   Handle dataHandle;   TEHandle theText;   int startLine, endLine, theLine;   /*==========================================*/   /* Get the window data and convert the data */   /* to a typed handle. Get a pointer to the  */   /* window's edit record.                    */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   /*=============================================*/   /* Determine the start and end lines selected  */   /* or the line containing the insertion point. */   /*=============================================*/      startLine = DeterminePositionStartLine((**theText).selStart,theText);   endLine = DeterminePositionEndLine((**theText).selEnd,theText);   if (endLine < startLine) endLine = startLine;     /*===============================================*/   /* Add a semicolon (the comment marker) to the   */   /* beginning of each line in the selected range. */   /*===============================================*/      for (theLine = startLine; theLine <= endLine; theLine++)     {      TESetSelect((long int) (**theText).lineStarts[theLine],                  (long int) (**theText).lineStarts[theLine],                  theText);      TEKey(';',theText);      WindowDirty(whichWindow,TRUE);     }      /*=======================================*/   /* Select all the text on the lines that */   /* had the comment character added.      */   /*=======================================*/      if (endLine != (**theText).nLines)     {      TESetSelect((long int) (**theText).lineStarts[startLine],                  (long int) (**theText).lineStarts[endLine+1],                  theText);     }   else     {      TESetSelect((long int) (**theText).lineStarts[startLine],                  (long int) (**theText).teLength,                  theText);     }        ResetShiftSelectionAnchor(whichWindow);   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) theText);  }/*************************************************//* DoUncomment: Handles the Uncomment menu item. *//*************************************************/static void DoUncomment(  WindowPtr whichWindow)  {   EWDHandle theData;   Handle dataHandle;   TEHandle theText;   int startLine, endLine, theLine;   char *textPtr;   /*==========================================*/   /* Get the window data and convert the data */   /* to a typed handle. Get a pointer to the  */   /* window's edit record.                    */   /*==========================================*/   dataHandle = (Handle) GetWRefCon(whichWindow);   theData = (EWDHandle) dataHandle;   theText = (**theData).editRec;   /*=============================================*/   /* Determine the start and end lines selected  */   /* or the line containing the insertion point. */   /*=============================================*/      startLine = DeterminePositionStartLine((**theText).selStart,theText);   endLine = DeterminePositionEndLine((**theText).selEnd,theText);   if (endLine < startLine) endLine = startLine;     /*==================================================*/   /* Remove a semicolon (the comment marker) from the */   /* beginning of each line in the selected range.    */   /*==================================================*/      HLock((**theText).hText);   textPtr = *(**theText).hText;         for (theLine = startLine; theLine <= endLine; theLine++)     {      if (((**theText).lineStarts[theLine] < (**theText).teLength) &&          (textPtr[(**theText).lineStarts[theLine]] == ';'))        {         TESetSelect((long int) (**theText).lineStarts[theLine],                     (long int) (**theText).lineStarts[theLine]+1,                     theText);         TEDelete(theText);         WindowDirty(whichWindow,TRUE);        }     }      HUnlock((**theText).hText);         /*=======================================*/   /* Select all the text on the lines were */   /* checked for the comment character.    */   /*=======================================*/      if (endLine != (**theText).nLines)     {      TESetSelect((long int) (**theText).lineStarts[startLine],                  (long int) (**theText).lineStarts[endLine+1],                  theText);     }   else     {      TESetSelect((long int) (**theText).lineStarts[startLine],                  (long int) (**theText).teLength,                  theText);     }        ResetShiftSelectionAnchor(whichWindow);   /*=======================*/   /* Lock the edit record. */   /*=======================*/   HLock((Handle) theText);  }