   /*******************************************************/   /*      "C" Language Integrated Production System      */   /*                                                     */   /*             CLIPS Version 6.05  04/09/97            */   /*                                                     */   /*                 SYMBOL HEADER FILE                  */   /*******************************************************//*************************************************************//* Purpose: Manages the atomic data value hash tables for    *//*   storing symbols, integers, floats, and bit maps.        *//*   Contains routines for adding entries, examining the     *//*   hash tables, and performing garbage collection to       *//*   remove entries no longer in use.                        *//*                                                           *//* Principal Programmer(s):                                  *//*      Gary D. Riley                                        *//*                                                           *//* Contributing Programmer(s):                               *//*                                                           *//* Revision History:                                         *//*                                                           *//*************************************************************/#ifndef _H_symbol#define _H_symbolstruct symbolHashNode;struct floatHashNode;struct integerHashNode;struct bitMapHashNode;struct genericHashNode;struct symbolMatch;#ifdef LOCALE#undef LOCALE#endif#ifdef _SYMBOL_SOURCE_#define LOCALE#else#define LOCALE extern#endif#define SYMBOL_HASH_SIZE        1013#define FLOAT_HASH_SIZE          503 #define INTEGER_HASH_SIZE        167 #define BITMAP_HASH_SIZE        167/************************************************************//* symbolHashNode STRUCTURE:                                *//************************************************************/struct symbolHashNode  {   struct symbolHashNode *next;   long count;   int depth;   unsigned int markedEphemeral : 1;   unsigned int neededSymbol : 1;#if (IBM_TBC && (! WIN_32)) || MAC_SC7   unsigned int bucket : 14;#else   unsigned int bucket : 30;#endif   char *contents;  };  /************************************************************//* floatHashNode STRUCTURE:                                  *//************************************************************/struct floatHashNode  {   struct floatHashNode *next;   long count;   int depth;   unsigned int markedEphemeral : 1;   unsigned int neededFloat : 1;#if (IBM_TBC && (! WIN_32)) || MAC_SC7   unsigned int bucket : 14;#else   unsigned int bucket : 30;#endif   double contents;  };/************************************************************//* integerHashNode STRUCTURE:                               *//************************************************************/struct integerHashNode  {   struct integerHashNode *next;   long count;   int depth;   unsigned int markedEphemeral : 1;   unsigned int neededInteger : 1;#if (IBM_TBC && (! WIN_32)) || MAC_SC7   unsigned int bucket : 14;#else   unsigned int bucket : 30;#endif   long int contents;  };  /************************************************************//* bitMapHashNode STRUCTURE:                                *//************************************************************/struct bitMapHashNode  {   struct bitMapHashNode *next;   long count;   int depth;   unsigned int markedEphemeral : 1;   unsigned int neededBitMap : 1;#if (IBM_TBC && (! WIN_32)) || MAC_SC7   unsigned int bucket : 14;#else   unsigned int bucket : 30;#endif   char *contents;   unsigned short size;  };  /************************************************************//* genericHashNode STRUCTURE:                               *//************************************************************/struct genericHashNode  {   struct genericHashNode *next;   long count;   int depth;   unsigned int markedEphemeral : 1;   unsigned int needed : 1;#if (IBM_TBC && (! WIN_32)) || MAC_SC7   unsigned int bucket : 14;#else   unsigned int bucket : 30;#endif  };  /************************************************************//* symbolMatch STRUCTURE:                               *//************************************************************/struct symbolMatch  {   struct symbolHashNode *match;   struct symbolMatch *next;  };  typedef struct symbolHashNode SYMBOL_HN;typedef struct floatHashNode FLOAT_HN;typedef struct integerHashNode INTEGER_HN;typedef struct bitMapHashNode BITMAP_HN;typedef struct genericHashNode GENERIC_HN;#define ValueToString(target) (((struct symbolHashNode *) (target))->contents)#define ValueToDouble(target) (((struct floatHashNode *) (target))->contents)#define ValueToLong(target) (((struct integerHashNode *) (target))->contents)#define ValueToInteger(target) ((int) (((struct integerHashNode *) (target))->contents))#define ValueToBitMap(target) ((VOID *) ((struct bitMapHashNode *) (target))->contents)#define IncrementSymbolCount(theValue) (((SYMBOL_HN *) theValue)->count++)#define IncrementFloatCount(theValue) (((FLOAT_HN *) theValue)->count++)#define IncrementIntegerCount(theValue) (((INTEGER_HN *) theValue)->count++)#define IncrementBitMapCount(theValue) (((BITMAP_HN *) theValue)->count++)/*****************************************************//* The FindSymbol function is remapped under certain *//* conditions because it conflicts with a Metroworks *//* Code Warrior library function.                    *//*****************************************************/#if MAC_MCW#define FindSymbol MCWFindSymbol  #endif#if ANSI_COMPILER   LOCALE VOID                          *AddSymbol(char *);   LOCALE SYMBOL_HN                     *FindSymbol(char *);   LOCALE VOID                          *AddDouble(double);   LOCALE VOID                          *AddLong(long int);   LOCALE VOID                          *AddBitMap(VOID *,int);   LOCALE INTEGER_HN                    *FindLong(long int);   LOCALE VOID                           InitializeAtomTables(void);   LOCALE int                            HashSymbol(char *,int);   LOCALE int                            HashFloat(double,int);   LOCALE int                            HashInteger(long int,int);   LOCALE int                            HashBitMap(char *,int,int);   LOCALE VOID                           DecrementSymbolCount(struct symbolHashNode *);   LOCALE VOID                           DecrementFloatCount(struct floatHashNode *);   LOCALE VOID                           DecrementIntegerCount(struct integerHashNode *);   LOCALE VOID                           DecrementBitMapCount(struct bitMapHashNode *);   LOCALE VOID                           RemoveEphemeralAtoms(void);    LOCALE struct symbolHashNode        **GetSymbolTable(void);   LOCALE VOID                           SetSymbolTable(struct symbolHashNode **);   LOCALE struct floatHashNode          **GetFloatTable(void);   LOCALE VOID                           SetFloatTable(struct floatHashNode **);   LOCALE struct integerHashNode       **GetIntegerTable(void);   LOCALE VOID                           SetIntegerTable(struct integerHashNode **);   LOCALE struct bitMapHashNode        **GetBitMapTable(void);   LOCALE VOID                           SetBitMapTable(struct bitMapHashNode **);   LOCALE VOID                           RefreshSpecialSymbols(void);   LOCALE struct symbolMatch            *FindSymbolMatches(char *,int *,int *);   LOCALE VOID                           ReturnSymbolMatches(struct symbolMatch *);   LOCALE SYMBOL_HN                     *GetNextSymbolMatch(char *,int,SYMBOL_HN *,int,int *);   LOCALE VOID                           ClearBitString(VOID *,int);   LOCALE VOID                           SetAtomicValueIndices(int);   LOCALE VOID                           RestoreAtomicValueBuckets(void);#else   LOCALE VOID                          *AddSymbol();   LOCALE SYMBOL_HN                     *FindSymbol();   LOCALE VOID                          *AddDouble();   LOCALE VOID                          *AddLong();   LOCALE VOID                          *AddBitMap();   LOCALE INTEGER_HN                    *FindLong();   LOCALE VOID                           InitializeAtomTables();   LOCALE int                            HashSymbol();   LOCALE int                            HashFloat();   LOCALE int                            HashInteger();   LOCALE int                            HashBitMap();   LOCALE VOID                           DecrementSymbolCount();   LOCALE VOID                           DecrementFloatCount();   LOCALE VOID                           DecrementIntegerCount();   LOCALE VOID                           DecrementBitMapCount();   LOCALE VOID                           RemoveEphemeralAtoms();    LOCALE struct symbolHashNode        **GetSymbolTable();   LOCALE VOID                           SetSymbolTable();   LOCALE struct floatHashNode          **GetFloatTable();   LOCALE VOID                           SetFloatTable();   LOCALE struct integerHashNode       **GetIntegerTable();   LOCALE VOID                           SetIntegerTable();   LOCALE struct bitMapHashNode        **GetBitMapTable();   LOCALE VOID                           SetBitMapTable();   LOCALE VOID                           RefreshSpecialSymbols();   LOCALE struct symbolMatch            *FindSymbolMatches();   LOCALE VOID                           ReturnSymbolMatches();   LOCALE SYMBOL_HN                     *GetNextSymbolMatch();   LOCALE VOID                           ClearBitString();   LOCALE VOID                           SetAtomicValueIndices();   LOCALE VOID                           RestoreAtomicValueBuckets();#endif#ifndef _SYMBOL_SOURCE   extern VOID                   *CLIPSTrueSymbol;   extern VOID                   *CLIPSFalseSymbol;   extern VOID                   *NegativeInfinity;   extern VOID                   *PositiveInfinity;   extern VOID                   *Zero;#endif#endif